<!DOCTYPE html><!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><title>How we made our pre-commit check 7x faster</title><link rel="stylesheet" href="/css/style.css"><link rel="canonical" href="https://blog.thoughtspile.tech/2021/06/14/faster-pre-commit/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>How we made our pre-commit check 7x faster</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline"></h1></header><div class="content" itemprop="articleBody"><p>As a guy who's somewhat responsible for a large chunk of front-end development infrastructure at our company, I've spent the last couple of months woried about the performance of our pre-commit checks. We have around 50 projects on a standard react + typescript stack, and a corresponding set of pre-commit checks: <code>eslint</code> + <code>stylelint</code> + <code>tsc</code> + sometimes, <code>jest</code>. This suite was taking anywhere from 10s on a starter project to 50s on a monstrous app — not fun. I set out to fix this — and I did.</p><h2>Cache your linters</h2><p>The quick fix was to add <code>--cache</code> flag to <a href="https://eslint.org/docs/user-guide/command-line-interface#options" target="_blank" rel="noopener">eslint</a> and <a href="https://stylelint.io/user-guide/usage/options/#cache" target="_blank" rel="noopener">stylelint</a> calls. These tools process one file at a time, and caching makes them run very fast (around 1s for a normal commit instead of 10+). A quick <a href="https://github.com/search?l=JSON&amp;q=eslint+src&amp;type=Code" target="_blank" rel="noopener">github search</a> makes me sad, because few people seem to do this. Also don't forget to gitignore <code>.stylelintcache</code> and <code>.eslintcache</code>. <strong>Gain:</strong> 50 -&gt; 30s.</p><h2>Run the checks concurrently</h2><p>Most checks were written like <code>eslint src &amp;&amp; stylelint src/**/*.css &amp;&amp; tsc --noEmit</code> — I assume the code was just being copied over. It's a waste for multi-core developer machines, and has an extra drawback of being unusable on windows (I don't think many front-end devs run windows, anyways). Making the checks run in parallel using <a href="https://github.com/kimmobrunfeldt/concurrently" target="_blank" rel="noopener"><code>concurrently</code></a> or <a href="https://github.com/mysticatea/npm-run-all/blob/master/docs/npm-run-all.md" target="_blank" rel="noopener"><code>npm-run-all</code></a> essentially makes the check run as fast as the slowest check — in our case, we were getting linters and jest for free, and <code>tsc</code> became the limiting factor. <strong>Gain:</strong> 30 -&gt; 28s.</p><h2>Cache tsc</h2><p><a href="https://www.typescriptlang.org/tsconfig/#noEmit" target="_blank" rel="noopener"><code>tsc --noEmit</code></a> sounds like the way to go if you run <code>tsc</code> to type-check your code, not to build anything. However, it was impossible to combine <code>--noEmit</code> with <code>--incremental</code> for a long time, leaving you with no caching and slow builds. Luckily, <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-beta/#noemit-and-incremental" target="_blank" rel="noopener">TS 4.0+ supports</a> this combination — just drop an <code>--incremental</code> flag and save time. If you're not ready to upgrade, <a href="https://stackoverflow.com/a/62622318" target="_blank" rel="noopener">a workaround</a> exists — you want the check to be faster, not to write exactly zero files, don't you? <strong>Gain:</strong> 28 -&gt; 7s.</p><h2>Do not break jest dependency detection</h2><p>Lastly, I wanted to cover several ways to speed up <a href="https://jestjs.io/" target="_blank" rel="noopener">jest</a> if you happen to run it in your pre-commit (this is pretty rare). Obviously, you want to use <a href="https://jestjs.io/docs/cli#--onlychanged" target="_blank" rel="noopener"><code>jest --onlyChanged</code></a> (or <code>jest -o</code>) to test only the files changed in the commit, not all the project. <code>jest</code> uses simple file-based dependency detection, no tree-shaking or anything — if you change file A, all the files that <code>import A</code> may have changed, and so on, and jest must run the tests for all the files that depend on A, too. You can work with this if you follow 2 rules:</p><ol><li>Do no import <code>index.js</code> inside your project — this erases granular change checks for individual modules re-exported via index. In the worst case, if you import from a root-level index, <em>every</em> change triggers all the tests.</li><li>Break frequently changed files into smaller chunks. Granted, it's good to use smaller modules in any case, but I bet you could start with your <code>utils.js</code> that contains 200 helpers. This will allow jest to make better guesses about what actually changed.</li></ol><hr><p>When pre-commit checks get slower, I see a lot of pressure to drop some checks and move them to CI. If you stick with slow checks instead, rest assured many developers will just <code>--no-verify</code> when commiting, which is probably not what you wanted to achieve. Lukily, you can easily make your pre-commit checks run in under 10 seconds:</p><ol><li>Use <code>eslint --cache</code> and <code>stylelint --cache</code></li><li>Run <code>tsc</code> with <code>--incremental</code> flag, or use a <a href="https://stackoverflow.com/a/62622318" target="_blank" rel="noopener">workaround</a> for TS &lt;4.0</li><li>Parallelize the checks using <code>concurrently</code> or <code>npm-run-all</code></li><li>Use <code>jest -o</code>, don't <code>import index</code>, and use smaller modules.</li></ol><p>This can be done in 15 minutes, really. I've run some calculations for you — if you manage to strip 30s off your check time, assuming you make 5 commits a day and have a 3-person team (all this sound plausible), you're saving your team <code>3 * 5 * 0.5 * 250 / 60</code> = 31 hours a year, that's almost a week to spend better than waiting for pre-commit cheks. I really really hope you go and see if you can apply some of these techniques right now.</p></div><span class="share"><div><a href="https://twitter.com/share?url=&text= by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2021/06/14/faster-pre-commit/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All posts ever</a> <a class="tag-link-link" href="/tags/infra" rel="tag">infra</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/typescript" rel="tag">typescript</a> <a class="tag-link-link" href="/tags/eslint" rel="tag">eslint</a></div><div class="post-actions">Written in <time>2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank" rel="noopener">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" href="https://buymeacoffee.com/thoughtspile" target="_blank" rel="noopener">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/06/11/cleaner-dynamic-arrays/"><div class="post-siblings__direction">Older</div><span class="link__text">Cleaner ways to build dynamic JS arrays</span> </a><a class="link--bare" href="/2021/09/21/useeffect-derived-state/"><div class="post-siblings__direction">Newer</div><span class="link__text">useLayoutEffect is a bad place for deriving state</span></a></div></article></div></body></html><script type="text/javascript">(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-121445688-1', 'auto');
    ga('send', 'pageview');</script><script src="/js/share.js"></script>