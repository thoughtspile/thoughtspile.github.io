<!DOCTYPE html><!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1"
    />
    <meta name="yandex-verification" content="635edef3908320be" />
    <meta
      name="google-site-verification"
      content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"
    />
    <title>
      Advanced Promises Coordination: Serialization and Concurrency Limiting
    </title>
    <link rel="stylesheet" href="/css/style.css" />
    <link
      rel="canonical"
      href="https://blog.thoughtspile.tech/2018/06/20/serialize-promises/"
    />
    <link
      rel="alternate"
      href="/atom.xml"
      title="Vladimir Klepov as a Coder"
      type="application/atom+xml"
    />
  </head>
  <body class="max-width mx-auto px3">
    <div class="content index">
      <a href="/" id="header" class="header header--post"
        ><div id="logo"></div>
        <header id="title">
          <h1>
            Advanced Promises Coordination: Serialization and Concurrency
            Limiting
          </h1>
        </header></a
      >
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <header><h1 class="posttitle" itemprop="name headline"></h1></header>
        <div class="content" itemprop="articleBody">
          <p>
            I'm sure you can chain promises with
            <code>doBefore().then(() =&gt; doAfter())</code> and even run
            multiple promises in parallel using <code>Promise.any</code>.
            However, chaining an unknown count of homogenous promises is
            trickier. Let me teach you to serialze promises like a pro!
          </p>
          <p>
            Suppose we want a list of all the cafes in a mid-sized european
            country.However, the API only lets you query the cafes by city. No
            problem — we have a list of all the cities, and will send a request
            for each one, then assemble the results.
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">const</span> cities <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token string">"Abertamy"</span><span class="token punctuation">,</span><br>  <span class="token string">"Adamov (Blansko District)"</span><span class="token punctuation">,</span><br>  <span class="token string">"Aš"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bakov nad Jizerou"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bavorov"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bechyně"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bečov nad Teplou"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bělá nad Radbuzou"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bělá pod Bezdězem"</span><span class="token punctuation">,</span><br>  <span class="token comment">// ... and 200 more</span><br><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token function-variable function">loadCafes</span> <span class="token operator">=</span> <span class="token parameter">city</span> <span class="token operator">=></span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">api.fivecircle.com/city/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>city<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <h2>How Not to Chain Promises</h2>
          <p>The first naive attempts are no good:</p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token comment">// All gone in a glimpse of eye:</span><br>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>areas<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>loadCafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cafes</span> <span class="token operator">=></span> db<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">flatten</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Still not good</span><br>areas<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">area</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>storeData<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// More of the same</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> area <span class="token keyword">in</span> areas<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>storeData<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
          <p>
            Since promises start executing once created, each of these options
            fires all the requests at once. With sane rate limiting
            restrictions, it will fail. A less elaborate server could even
            crash.
          </p>
          <p>We could, of course, use <code>await</code>:</p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">let</span> cafes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> area <span class="token keyword">of</span> areas<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  cafes <span class="token operator">=</span> cafes<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token function">storeData</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>
            But I'm not a fan of this syntax — the code is now arguably C-like.
            I also find error handling in promises cleaner. And now we have more
            preprocessing to do for the code to work, which is nothing to be
            proud of. So let's go on and write this in pure promises instead.
          </p>
          <h2>Explicit Serialization</h2>
          <p>
            The best-known trick from this bunch is explicitly chaining an array
            of promises with <code>&lt;Array&gt;.reduce</code>. It works best
            for fire-and-forget promises, like redux actions:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">return</span> actions<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><br>  <span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> before<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>However, assembling return values is a bit awkward:</p>
          <pre
            class="language-js"
          ><code class="language-js">areas<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">before<span class="token punctuation">,</span> area</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> before<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">acc</span> <span class="token operator">=></span> <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cafes</span> <span class="token operator">=></span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cafes</span> <span class="token operator">=></span> db<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>
            Overall, this is good enough when you have an array of data you want
            to run the actions on beforehand. But what if you don't?
          </p>
          <h2>Implicit Serialization</h2>
          <p>
            We can actually write a wrapper for arbitrary promise-returning
            functions that makes any call wait for the previous ones to finish.
            This wrapper is completely transparent, leaving the function's
            interface intact — good for composability. Here it is:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">function</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token parameter">immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// This works as our promise queue</span><br>  <span class="token keyword">let</span> last <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Catch is necessary here — otherwise a rejection in a promise will</span><br>    <span class="token comment">// break the serializer forever</span><br>    last <span class="token operator">=</span> last<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">immediate</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> last<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
          <p>
            Now we can just wrap our function and never have to worry about
            flooding the API again:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">const</span> loadCafesSafe <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span>loadCafes<span class="token punctuation">)</span><span class="token punctuation">;</span><br>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>areas<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=></span> <span class="token function">loadCafesSafe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>
            It's so easy it doesn't warrant a library — just five lines of code.
            And we can take this idea further with...
          </p>
          <h2>Concurrency Limiting</h2>
          <p>
            Serialization effectively forces our promises to run in one thread.
            To make them go faster, we can generalize the serializer to allow
            not one, but at most N promises to run simultaneously:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">function</span> <span class="token function">limitConcurrency</span><span class="token punctuation">(</span><span class="token parameter">immediate<span class="token punctuation">,</span> maxConcurrent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Each element holds its index, or a promise resolving with the index</span><br>  <span class="token keyword">const</span> workers <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>maxConcurrent<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Without this serialization, Promise.race would resolve with the same</span><br>  <span class="token comment">// worker whenever a concurrency-limited function was synchronously called</span><br>  <span class="token comment">// multiple times.</span><br>  <span class="token keyword">const</span> findWorker <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>workers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// race resolves with the first free worker</span><br>    <span class="token keyword">return</span> <span class="token function">findWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token comment">// and here we start the action and update the worker correspondingly:</span><br>      <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token function">immediate</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      workers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">return</span> promise<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
          <p>
            The idea is the same, but we replaced the single
            <code>last</code> promise with an array of N workers and added some
            bookkeeping. This code packs promises into threads as tightly as
            possible, with no idle time.
          </p>
          <p>
            Also note that <code>serializePromises</code> is the same as
            <code>a =&gt; limitConcurrency(a, 1)</code>.
          </p>
          <p>
            If you want to impose joint limiting on several arbitrary functions,
            you can tweak the code — I leave this to you as an exercise ;-)
          </p>
          <h2>Propagating Rate Errors</h2>
          <p>
            Now that our code manages a promise queue, we can see a potential
            problem in it. The system can smooth activity spikes without
            propagating these upstream. However, if the request rate is higher
            than what the upstream can handle for an extended period of time,
            our queue can overfill and blow up the memory limit.
          </p>
          <p>
            The problem still existed before we added the limiter, but would
            occurred upstream instead. No wrapper can magically improve service
            throughput.
          </p>
          <p>
            To handle these errors without crashing our process, we can put a
            hard limit on queue size. Here's how it can be done for the generic
            <code>limitConcurrency</code>:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">function</span> <span class="token function">limitConcurrency</span><span class="token punctuation">(</span><span class="token parameter">immediate<span class="token punctuation">,</span> maxConcurrent<span class="token punctuation">,</span> maxQueue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// this is our queue counter</span><br>  <span class="token keyword">let</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> workers <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>maxConcurrent<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> findWorker <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>workers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queued <span class="token operator">>=</span> maxQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Max queue size reached'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    queued <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token function">findWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      queued <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>      <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token function">immediate</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      workers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">return</span> promise<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
          <p>
            Now, instead of uncontrollably enqueueing, the coordinator rejects
            when there's already too much work ahead. The consumers can handle
            these errors and retry later.
          </p>
          <h2>Use Cases</h2>
          <p>
            So far we've been discussing an example with API requests, and you
            might argue that concurrency limiting functionality should be
            provided bt the HTTP client library. That's true, but the power of
            our promise-based strategy is its generality. Here are some
            unorthodox use cases:
          </p>
          <h3>&quot;Sloppy Transactions&quot; with Serialization</h3>
          <p>
            Suppose an action involves reading an external data source,
            computing on the response and issuing an update. If the source
            changes between the read and the update, you've corrupted your data
            beyond repair. You can instead wrap the action with our
            &quot;promise serializer&quot;. Of course, this assumes that the
            relevant data is only accessed by your wrapper, and only by a single
            process. You can even build a simple file-based database.
          </p>
          <h3>Prevent Notification Flood with Concurrency Limiting</h3>
          <p>
            A front-end idea. You probably have a notification area somewhere on
            the screen. However, if a large batch of notifications just arrived,
            the users are likely to miss some of those. But now you can treat
            the currently visible notifications as the running threads and apply
            <code>limitConcurrecny</code>!
          </p>
          <p>
            A similar use case for modal windows uses serialized promises — you
            can't show multiple modals at the same time, but now you can enqueue
            the next one instead.
          </p>
          <h3>Web Worker Thread Pool</h3>
          <p>
            Finally, time for some cutting-edge tech. If your web app heavily
            uses web workers for background processing, you can wrap web worker
            access with a promise-based API, then use our wrapper to limit the
            number of simultaneously active workers. With several kinds of
            specialized workers, you might choose to use a multi-factory flavour
            of our <code>limitConcurrecny</code> instead. I'll delve deeper into
            this this case with an upcoming article on load balancing.
          </p>
          <h2>Summary</h2>
          <p>
            We've learnt how to force promises to run consecutively and even to
            limit the number of pending promises to a specified number. This
            technique can be used for safer back-end access, and its generality
            allows to use it for any promise-based API.
          </p>
          <p>
            I'm not too good at writing: the topics kept expanding in my head,
            and I have had a hard time finishing this article. I have two other
            interesting promise coordination patterns to handle in future
            articles of this series:
          </p>
          <ul>
            <li>Rate Limiting</li>
            <li>Load Balancing</li>
          </ul>
          <p>
            Wish me luck writing these! If you have some tips or want to argue,
            drop me an e-mail.
          </p>
          <p><strong>Advanced Promise Coordination Series</strong></p>
          <ul>
            <li>
              <a href="/2018/06/20/serialize-promises/"
                >Serialization and Concurrency Limiting</a
              >
            </li>
            <li>
              <a href="/2018/07/07/rate-limit-promises/">Rate Limiting</a>
            </li>
          </ul>
        </div>
        <span class="share"
          ><div>
            <a
              href="https://twitter.com/share?url=&text= by @thoughtspile"
              target="_blank"
              rel="noopener"
              >Tweet</a
            >
          </div>
          <div id="share-button"><a>Share</a></div>
          <div>
            <a
              href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2018/06/20/serialize-promises/"
              target="_blank"
              rel="noopener"
              >Discuss on Twitter</a
            >
          </div></span
        >
        <div class="post-related">
          More? <a class="tag-link-link" href="/">All posts ever</a>
          <a class="tag-link-link" href="/tags/promises" rel="tag">promises</a>
          <a class="tag-link-link" href="/tags/javascript" rel="tag"
            >javascript</a
          >
          <a class="tag-link-link" href="/tags/programming" rel="tag"
            >programming</a
          >
          <a class="tag-link-link" href="/tags/concurrency" rel="tag"
            >concurrency</a
          >
        </div>
        <div class="post-actions">
          Written in <time>2018</time> by&nbsp;your friend,
          <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a
            href="https://twitter.com/thoughtspile"
            target="_blank"
            rel="noopener"
            >Twitter</a
          >
          to&nbsp;get post updates. I&nbsp;have
          <a href="/atom.xml">RSS,</a> too. And you can
          <a
            class="bmc link--bare"
            href="https://buymeacoffee.com/thoughtspile"
            target="_blank"
            rel="noopener"
            >buy me a coffee!</a
          >
        </div>
        <div class="post-siblings">
          <a class="link--bare" href="/2018/07/07/rate-limit-promises/"
            ><div class="post-siblings__direction">Newer</div>
            <span class="link__text"
              >Advanced Promise Coordination: Rate Limiting</span
            ></a
          >
        </div>
      </article>
    </div>
  </body>
</html>
<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );
  ga("create", "UA-121445688-1", "auto");
  ga("send", "pageview");
</script>
<script src="/js/share.js"></script>
