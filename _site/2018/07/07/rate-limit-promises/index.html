<!DOCTYPE html><!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1"
    />
    <meta name="yandex-verification" content="635edef3908320be" />
    <meta
      name="google-site-verification"
      content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"
    />
    <title>Advanced Promise Coordination: Rate Limiting</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link
      rel="canonical"
      href="https://blog.thoughtspile.tech/2018/07/07/rate-limit-promises/"
    />
    <link
      rel="alternate"
      href="/atom.xml"
      title="Vladimir Klepov as a Coder"
      type="application/atom+xml"
    />
  </head>
  <body class="max-width mx-auto px3">
    <div class="content index">
      <a href="/" id="header" class="header header--post"
        ><div id="logo"></div>
        <header id="title">
          <h1>Advanced Promise Coordination: Rate Limiting</h1>
        </header></a
      >
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <header><h1 class="posttitle" itemprop="name headline"></h1></header>
        <div class="content" itemprop="articleBody">
          <p>
            In the
            <a href="/2018/06/20/serialize-promises/">previous post</a> we
            learnt to serialize and concurrecy-limit promise-based operations in
            js. This time we dive further and handle rate limiting.
          </p>
          <h2>What Exactly to Rate Limit</h2>
          <p>
            Let's get terminological matters out of the way first. Promises
            represent operations that last a certain amount of time, while rate
            limiting is applied to discrete events. Over its life, a promise
            starts and terminates (with a success or a failure, not important
            now). It makes most sense to rate limit promise creations (starts).
            Rate limiting promise resolutions can be done by appending a
            start-rate-limited promise onto the end of the running promise. We
            could also limit the gap between operations, but I have no idea how
            that would be useful.
          </p>
          <h2>Rate vs concurrency limiting</h2>
          <p>
            While both rate and concurrency limits are trying to prevent a
            client from overloading the server by making too many calls too
            fast, they do not replace one another, and are implemented
            differently.
          </p>
          <p>
            Suppose an API is rate-limited to 1 request per second. Even
            1-concurrent requests break the rate limit if they complete in under
            1s. On the other hand, if the requests take 3 seconds to complete,
            we can only have 3 of them running at the same time:
          </p>
          <pre><code>...
 ...
  ...
</code></pre>
          <p>
            We could derive a bunch of formulae to connect the concurrency, rate
            and running time of operations, but that's completely beside the
            point. The thing to remember here is that without strict guarantees
            on operation duration you can not replace concurrency limit with
            rate limit or vice versa.
          </p>
          <h2>Rate limiting individual operations</h2>
          <p>
            The simplest form of rate limiting is &quot;1 operation per N
            seconds&quot;. This one is straightforward, but first we need a
            building block â€” the promise counterpart of <code>setTimeout</code>:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">resolveAfter</span> <span class="token operator">=</span> <span class="token parameter">ms</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">ok</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>ok<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>
            <code>resolveAfter</code> is self-explanatory: it returns a promise
            that resolves after the specified time has elapsed. Now, for the
            actual rate limiter:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">function</span> <span class="token function">rateLimit1</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> msPerOp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> wait <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">// We use the queue tail in wait to start both the</span><br>    <span class="token comment">// next operation and the next delay</span><br>    <span class="token keyword">const</span> res <span class="token operator">=</span> wait<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    wait <span class="token operator">=</span> wait<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolveAfter</span><span class="token punctuation">(</span>msPerOp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
          <p>
            Now we can, as usual, wrap the promise and call with no worries, the
            operations are magically delayed:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">const</span> slowFetch <span class="token operator">=</span> <span class="token function">rateLimit1</span><span class="token punctuation">(</span>fetch<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">u</span> <span class="token operator">=></span> <span class="token function">slowFetch</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">raw</span> <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>raw<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">p</span> <span class="token operator">=></span> p<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">pages</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pages<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>
            The 1-rate-limiter can also be elegantly implemented on top of
            serializer with the pitfall of unnecessarily delaying the first
            operation:
          </p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">function</span> <span class="token function">rateLimit1</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> msPerOp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> wait <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolveAfter</span><span class="token punctuation">(</span>msPerOp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
          <h2>Rate limiting multiple operations</h2>
          <p>
            Many APIs feature soft rate limits instead: they allow
            <code>M request per N seconds</code>. That is not equivalent to
            <code>1 request per N/M seconds</code>! Converting the multiple rate
            limit into individual one does fulfil the rate limit, but is overly
            harsh and non-optimal. Let's see this through examples.
          </p>
          <h3>Difference from individual rate limit, by example</h3>
          <p>
            Suppose you're flying a plane, and the airline allows 10 kg of
            luggage per passenger. If you're travelling with a girl, and have
            one 16-kg bag with both your things. At the check-in desk you're
            asked to take out half the stuff in your bag to make two 8-kg items.
            While formally correct, it feels idiotic â€” you still add the exact
            same weight to the plane! But now, why would you enforce such a
            stupid restriction on your own operations if you can do better?
          </p>
          <p>
            Closer to the topic, let's try 2-req-per-2-sec rate limit for
            operations lasting 2 seconds. If you immediately fire 2 requests,
            you're done in 2 seconds:
          </p>
          <pre><code>----| 2 seconds, all done!
----|
</code></pre>
          <p>
            Converting this into 1-req-per-1-sec delays the second request by
            1s, and now the same 2 requests take 3 seconds! You just lost a
            second for no reason.
          </p>
          <pre><code>----  | 3 seconds
  ----|
</code></pre>
          <h3>Understanding</h3>
          <p>
            To understand what we should do, let's have a closer look at the
            1-rate-limit. We essentially make a queue of promises that never
            resolve closer than <code>delay</code> apart. We use the resolutions
            to start the next operations, and don't care about its termination
            at all:
          </p>
          <pre><code>*--*--     *--*--
</code></pre>
          <p>
            This view extends to N-rate-limit: create N independent queues and
            put these into a circular queue (yes, a queue of queues makes a good
            <em>in Soviet Russia</em> joke):
          </p>
          <pre><code>*--*-- *--*--
 *-- *--*--  *--
 *--  *-- *--    *--
</code></pre>
          <p>
            The individual queues are unchanged, and never fire more than 1
            operation per N seconds. Thus, M queues can fire at most M
            operations during the window.
          </p>
          <h3>Implementing</h3>
          <p>With this plan in mind, we can generalize the implementation:</p>
          <pre
            class="language-js"
          ><code class="language-js"><span class="token keyword">function</span> <span class="token function">rateLimit</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> windowMs<span class="token punctuation">,</span> reqInWindow <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// A battery of 1-rate-limiters</span><br>  <span class="token keyword">const</span> queue <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>reqInWindow<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">rateLimit1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> windowMs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Circular queue cursor</span><br>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token comment">// to enqueue, we move the cursor...</span><br>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> reqInWindow<span class="token punctuation">;</span><br>    <span class="token comment">// and return the rate-limited operation.</span><br>    <span class="token keyword">return</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
          <h2>Preventing queue overflow</h2>
          <p>
            Just as before, we run into problems if the operations are
            consistently inserted into the queue faster than the rate limit. The
            solution is the same: once the queue exceeds the specified number of
            items, we immediately reject the incoming operations.
          </p>
          <h2>Combining with concurrency limiting</h2>
          <p>
            Now that we know how to limit both the rate and the number of
            simultaneously running operations, and since neither is a substitute
            for another, we want a way to combine the two limits. But can we
            build the joint rate/concurrency limiter by composing the primitive
            limiters? Turns out we can, but should carefully choose the order.
          </p>
          <p>
            <code>rateLimit(concurrencyLimit(fetch, N), ms)</code>, limits the
            rate at which the operations enter the concurrency-limit queue.
            Serialized (1-concurrent) promises rate-limited to 1 second break
            this combination. Suppose the first operation runs for 2 seconds,
            and during that time we throw 2 fast operations, O_2 and O_3 (say,
            10 ms each) into the serializer. Instead of waiting for 1 second,
            the O_3 starts right after O_2 completes, or 10ms after it starts,
            breaking the rate limit.
          </p>
          <p>
            <code>concurrencyLimit(rateLimit(fetch, ms), N)</code> limits the
            number of operations in the rate-limit queue. Since the rate limiter
            only sees N operations at a time, it has no chance to fire more than
            N, which is exactly what we want. Hence,
            <strong>Chaining Rule 1: limit concurrency before rate.</strong>
          </p>
          <h2>Use cases</h2>
          <p>
            The classic and most appropriate rate-limiting use case is for API
            requests. But now that you know the pattern, you will see it in your
            own tasks and, hopefully, use it ;-)
          </p>
          <p>
            Promise-based rate limiting is a great way to quickly hack together
            a safe API wrapper without depending on the underlying HTTP / TCP /
            WebSocket client.
          </p>
          <p>
            Frankly, other use cases I can come up with off the top of my head
            (render throttling and preventing too many e-mail notifications) are
            better served by batching. Maybe, you'll have better luck.
          </p>
          <h2>Summary</h2>
          <p>
            We've learnt to rate-limit promise-based APIs, both for the simple
            &quot;1-action-per-N-seconds&quot; and the more general M-actions
            case. Together with the previously discussed concurrency limiter,
            these patterns allow us to build robust service gateways with
            node.js, safely call external APIs and do all the other things you
            come up with.
          </p>
          <p>
            Planning note: I've decided to throw away the excessively tricky
            part on load balancing and go with super fun and useful posts on
            <em>batching</em> and <em>handling failure</em>. I have RSS now, so
            be sure to stay tuned!
          </p>
          <p><strong>Advanced Promise Coordination Series</strong></p>
          <ul>
            <li>
              <a href="/2018/06/20/serialize-promises/"
                >Serialization and Concurrency Limiting</a
              >
            </li>
            <li>
              <a href="/2018/07/07/rate-limit-promises/">Rate Limiting</a>
            </li>
          </ul>
        </div>
        <span class="share"
          ><div>
            <a
              href="https://twitter.com/share?url=&text= by @thoughtspile"
              target="_blank"
              rel="noopener"
              >Tweet</a
            >
          </div>
          <div id="share-button"><a>Share</a></div>
          <div>
            <a
              href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2018/07/07/rate-limit-promises/"
              target="_blank"
              rel="noopener"
              >Discuss on Twitter</a
            >
          </div></span
        >
        <div class="post-related">
          More? <a class="tag-link-link" href="/">All posts ever</a>
          <a class="tag-link-link" href="/tags/promises" rel="tag">promises</a>
          <a class="tag-link-link" href="/tags/javascript" rel="tag"
            >javascript</a
          >
          <a class="tag-link-link" href="/tags/programming" rel="tag"
            >programming</a
          >
          <a class="tag-link-link" href="/tags/high availability" rel="tag"
            >high availability</a
          >
        </div>
        <div class="post-actions">
          Written in <time>2018</time> by&nbsp;your friend,
          <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a
            href="https://twitter.com/thoughtspile"
            target="_blank"
            rel="noopener"
            >Twitter</a
          >
          to&nbsp;get post updates. I&nbsp;have
          <a href="/atom.xml">RSS,</a> too. And you can
          <a
            class="bmc link--bare"
            href="https://buymeacoffee.com/thoughtspile"
            target="_blank"
            rel="noopener"
            >buy me a coffee!</a
          >
        </div>
        <div class="post-siblings">
          <a class="link--bare" href="/2018/06/20/serialize-promises/"
            ><div class="post-siblings__direction">Older</div>
            <span class="link__text"
              >Advanced Promises Coordination: Serialization and Concurrency
              Limiting</span
            > </a
          ><a class="link--bare" href="/2018/07/14/docx-is-a-zip-archive/"
            ><div class="post-siblings__direction">Newer</div>
            <span class="link__text">Quick Tip: docx is a zip Archive</span></a
          >
        </div>
      </article>
    </div>
  </body>
</html>
<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );
  ga("create", "UA-121445688-1", "auto");
  ga("send", "pageview");
</script>
<script src="/js/share.js"></script>
