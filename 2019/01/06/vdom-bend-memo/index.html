<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    
      <meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc" />
    
    <meta name="description" content="The other day I was working on a React-based library of huge, reusable SVG images, and I ran into performance problems. Just kidding, I’ve never had a problem I’m solving here, but I’ve had great fun">
<meta name="keywords" content="javascript,programming,frontend,react">
<meta property="og:type" content="article">
<meta property="og:title" content="Extravagantly fast rendering with React benders">
<meta property="og:url" content="https://thoughtspile.github.io/2019/01/06/vdom-bend-memo/index.html">
<meta property="og:site_name" content="Vladimir Klepov as a Coder">
<meta property="og:description" content="The other day I was working on a React-based library of huge, reusable SVG images, and I ran into performance problems. Just kidding, I’ve never had a problem I’m solving here, but I’ve had great fun">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-04-09T18:05:50.258Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Extravagantly fast rendering with React benders">
<meta name="twitter:description" content="The other day I was working on a React-based library of huge, reusable SVG images, and I ran into performance problems. Just kidding, I’ve never had a problem I’m solving here, but I’ve had great fun">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Extravagantly fast rendering with React benders</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml" />
    

    <script type='text/javascript' src='//platform-api.sharethis.com/js/sharethis.js#property=5c1957fa423bba0012ec3bd1&product=inline-share-buttons'
      async='async'></script>

</head>

<body class="max-width mx-auto px3">
    <div class="content index my4">
        <a href="/" id="header" class="header header--post">
  
    
    <div id="logo" style="background-image: url(/images/logo.png);"></div>
  
  <header id="title">
    <h1>Vladimir Klepov as a Coder</h1>
  </header>
</a>

        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Extravagantly fast rendering with React benders
    </h1>



    <div class="meta">
      
    <div class="postdate">
        <time datetime="2019-01-06T08:02:42.000Z" itemprop="datePublished">06.01.2019</time>
    </div>


      
    <div class="article-tag">
        <a class="tag-link" href="/tags/frontend/">frontend</a>, <a class="tag-link" href="/tags/javascript/">javascript</a>, <a class="tag-link" href="/tags/programming/">programming</a>, <a class="tag-link" href="/tags/react/">react</a>
    </div>


    </div>
  </header>
  <div class="content" itemprop="articleBody">
    <p>The other day I was working on a React-based library of huge, reusable SVG images, and I ran into performance problems. Just kidding, I’ve never had a problem I’m solving here, but I’ve had great fun working around it. I wanted to make components producing mostly static DOM as fast to render as humanly possible. And I’m not talking just about updates — I wanted to optimize mounting. Of course, normally you’d just skip remounting and hide / show the component with CSS, but that’s not fun enough for me. Let’s say we want to render it fast in random locations of your app.</p>
<p>Let’s start with something simple — a component with no props. Since the renders are pure, the component always returns the same markup, which makes it a perfect candidate for our game. I know, I know, context and connected components, but let’s ignore these for a while. An SVG image works well — think this one, but huge:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Icon = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;svg xmlns=<span class="string">"http://www.w3.org/2000/svg"</span> version=<span class="string">"1.1"</span> width=<span class="string">"192.25"</span> height=<span class="string">"66.056"</span> viewBox=<span class="string">"4.5 -5.222 192.25 66.056"</span>&gt;</span><br><span class="line">    &lt;circle fill=<span class="string">"#000000"</span> cx=<span class="string">"37.637"</span> cy=<span class="string">"28.418"</span> r=<span class="string">"28.276"</span>/&gt;</span><br><span class="line">  &lt;<span class="regexp">/svg&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>Also check out the <a href="https://codesandbox.io/s/j9xp6pqo5" target="_blank" rel="noopener">codesandbox</a> with the complete code.</p>
<h2 id="Pure"><a href="#Pure" class="headerlink" title="Pure"></a>Pure</h2><p>Our first intuitive take is to make the component pure:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PureIcon</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Icon</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// or, with a dash recompose</span></span><br><span class="line"><span class="xml">const PureIcon = pure(Icon);</span></span><br></pre></td></tr></table></figure>
<p>Fine, this helps make the updates almost free. But mounting the component still takes time. Honestly, does it make sense to build the vDOM every time we mount, given that we know it’ll always be the same? No. Great, we can make it better.</p>
<h2 id="Global-vDOM-memoization"><a href="#Global-vDOM-memoization" class="headerlink" title="Global vDOM memoization"></a>Global vDOM memoization</h2><p>So, we want to cache the vDOM globally instead of building it from scratch every time we mount. Note that we can’t use <code>_.memoize(Icon)</code> because Icon is still called with the props argument that gets a new reference every time. No problem, we’ll write it ourselves:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> ManualMemoIcon = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache) &#123;</span><br><span class="line">    cache = <span class="xml"><span class="tag">&lt;<span class="name">Icon</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return cache;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>So, we only build the vDOM (<code>&lt;Icon /&gt;</code>) on the first mount, application-wide. Should be good? It’s not. The premise of React that building vDOM is cheap is true, after all. Once React quickly gets the vDOM, it goes and starts building the real DOM — painfully slowly. We can strip a fraction of the mount time, but the updates were better with <code>Pure</code>. We have to skip the vDOM-to-DOM step if we want to succeed. Can I do that? You bet I can!</p>
<h2 id="DOM-memoization"><a href="#DOM-memoization" class="headerlink" title="DOM memoization"></a>DOM memoization</h2><p>So, caching vDOM does not help us much — we need to cache the real DOM. The plan is simple: when we first (application-wide first) mount the component, we take the resulting DOM and put it into a variable. On subsequent mounts we don’t really render anything, but clone the saved DOM subtree into our mount point. In code:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> domCache;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DomMemoIcon</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (domCache) &#123;</span><br><span class="line">      <span class="keyword">this</span>.el.appendChild(domCache.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      domCache = <span class="keyword">this</span>.el.firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// yes, there may be minor trouble with simultaneous first mounts</span></span><br><span class="line">    <span class="keyword">const</span> children = domCache ? <span class="literal">null</span> : <span class="xml"><span class="tag">&lt;<span class="name">Icon</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;e</span> =&gt;</span> this.el = e&#125;&gt;&#123; children &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>This works! In my truck benchmark, we’re down from 25 to 5 ms — pretty amazing! Let’s now focus on what we’ve lost in the process:</p>
<ul>
<li>No props. We can get away with some <em>if</em> we promise that they’ll always be the same.</li>
<li>No context, no connected children.</li>
</ul>
<p>Sounds like a fair deal to me. But can we go faster yet? Ha-ha, we can. If you never have more than one component instance mounted at the same time, you can skip the <code>.cloneNode</code>. Or you could add instance counting to treat this as a special case.</p>
<h2 id="Adding-props"><a href="#Adding-props" class="headerlink" title="Adding props"></a>Adding props</h2><p>But we like props, props are cool! Can we please have them back? Maybe we can. If the component’s <em>prop space</em> — that is, all the prop combinations we ever use — is fairly small, we could put the DOMs for each prop object into a map of sorts: <code>{ [prop object] -&gt; resulting DOM }</code>, then try to retrieve the DOM from cache on each mount / update. I’ll leave implementing this to you as an exercise.</p>
<hr>
<p>So, do I suggest actually using this? Probably not, it’s very tricky and not very useful. If you can make it work for you — great, let me know. Anyways, it’s very cool that we can stuff like this is doable with React.</p>

  </div>
  <div class="call-to-action clearfix">
    
      <a class="call-to-action__item left" href="/2018/12/17/design-crash-course/">
        <i class="fas fa-chevron-left fa-3x"></i>
        <span class="call-to-action__item__name">10 Design Rules for Programmers</span>
      </a>
    
    
      <a class="call-to-action__item right" href="/2021/04/02/promise-timeout/">
        <span class="call-to-action__item__name">How to timeout a promise</span>
        <i class="fas fa-chevron-right fa-3x"></i>
      </a>
    
  </div>
</article>
<div class="sharethis-inline-share-buttons"></div>



    </div>
    <footer id="footer">
  <a href="/">
    A blog by Vladimir Klepov
  </a>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-121445688-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


