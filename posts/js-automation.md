---
title: Why I prefer JS for front-end build automation
date: 2022-02-14
tags: 
  - javascript
  - programming
  - frontend
  - developer experience
---

<p>Every front-end project involves some automation to build it, test it, lint it, run dev servers, measure bundle size, and what not. npm scripts are fine for one-liners, but as the workflows grow more complex — run these things in parallel, then do something else, but only if building for production — you need a more coherent orchestration solution. In many projects, this means <code>bash</code> — it can handle anything, from the trivial <code>&amp;&amp;</code> to <code>if .. fi</code> mostrosities in separate shell scripts.</p><p>I must confess, I’ve never been comfortable with <code>bash</code>, and for years I’ve seen this as a weakness. But at some point I realized most front-end devs feel the same way. I took a closer look at JS, and it turned out to be a very nice tool for managing automation workflows! In this article, I’ll tell you what made me change my mind:</p><ul><li>Your team is probably most comfortable with JS</li><li>Node is likely installed on your dev and CI machines</li><li>Direct access to other JS tools</li><li>Node is a cross-platform runtime</li><li>Inter-process communication is async and fairly convenient</li></ul><p>Let’s go — see if this convinces you to stop worrying and embrace JS for your automation. Many of these points also apply when comparing to <code>make</code> or <code>python</code> (yes, I’ve seen a JS project with python automation once). Here’s a quick comparison table, if you’re in a hurry:</p><p><img src="/images/node-vs-bash.png"></p><h2 id="It’s-your-team’s-primary-language"><a href="#It’s-your-team’s-primary-language" class="headerlink" title="It’s your team’s primary language"></a>It’s your team’s primary language</h2><p>Most front-end teams know JS better than bash or any other language. Sure, node has special APIs, but overall it’s the same familiar landscape of first-class functions, loops and promises. <code>bash</code>? I’ve spent years around it, and I’m still not sure how it works — the syntax is similar but different in unexpected ways, most variables are strings, do modules even exist? Pls don’t correct me if I’m wrong, I’m not 100% certain on this and I don’t care any more. I just google all the time.</p><p>Analogy time: Chinese language is beautiful and useful, but you probably don’t insist on speaking it at dailies unless your team is Chinese. Why would you go that way about programming languages? The argument that every half-decent programmer <em>must</em> learn bash is ill-conceived — sure, it’s helpful in some cases, but why make it a requirement?</p><p>Your colleagues with other profiles (back-end friends or admins) who need to make an urgent change in your project are likely to know some JS, too. Many have done a random JS project or two, and the C-style syntax lets anybody get at least some idea of what’s going on. Granted, this is also the case with bash, but JS is no worse in this regard.</p><p>So, using JS for automation in a JS-first team is the most logical choice.</p><h2 id="The-runtime-is-likely-already-installed"><a href="#The-runtime-is-likely-already-installed" class="headerlink" title="The runtime is likely already installed"></a>The runtime is likely already installed</h2><p>Your trouble doesn’t end once you get your <code>bash</code> script to work, because it will often fail on another machines (looking at you, alpine docker containers). <a href="https://en.wikipedia.org/wiki/Shell_script">Various shells</a> (sh, ash, bash, zsh) are slightly different, and the available commands differ across linux distros. Fine, you can manually pick the necessary packages (more on that in a minute), or painfully recreate your logic manually, but it’s all a waste of time.</p><p>With node, the problem of missing runtimes is very rare — the CI machines probably run <code>npm</code> / <code>yarn</code> anyways, and these come bundled with <code>node</code>. Also, once your node program runs, it usually runs on every machine.</p><h2 id="Cross-platform-out-of-the-box"><a href="#Cross-platform-out-of-the-box" class="headerlink" title="Cross-platform out of the box"></a>Cross-platform out of the box</h2><p>Which brings us to the next point — node is a cross-platform runtime that works fine on linux, mac, and windows. OK, MacOS is POSIX-compliant, but many commands still have minor differences in options and output format. Now, do you need Windows support? Most front-end devs I’ve seen use macs, and bash ports for Win exist. Still, supporting Win out of the box for free is always nice:</p><ul><li>It lowers barrier to contribution for open-source projects.</li><li>Once I had to hastily launch a dev server on a Windows server, which was not pleasant.</li><li>A manager wants to play around with your project, but he runs Win.</li></ul><p>Node team has spent a lot of time abstracting the OS differences away. Ignoring that and sticking with bash is counter-productive.</p><h2 id="Direct-access-to-other-JS-tools"><a href="#Direct-access-to-other-JS-tools" class="headerlink" title="Direct access to other JS tools"></a>Direct access to other JS tools</h2><p>Most tools in your front-end workflows (webpack / parcel / babel / postcss) expose node APIs. Even non-JS-based tools like <a href="https://esbuild.github.io/getting-started/#deno">esbuild</a> and <a href="https://github.com/swc-project/swc/tree/main/node-swc">swc</a> provide node bindings. If your orchestration runs on node, accessing these APIs is trivial: just import the package, and call the function.</p><p>With bash, you have two lousy options to integrate with node-based tools:</p><ul><li>Jump through hoops of calling the tools’ CLI with weird option formatting.</li><li>Write a minimal JS wrapper to call the node API, and call it from bash, wondering where to draw the boundary.</li></ul><p>As an added benefit, since many tools’ CLI lives in a separate package (like <a href="https://www.npmjs.com/package/@babel/cli"><code>@babel/cli</code></a>), you can skip installing it if you use the node API directly, shaving off a bit of <code>npm i</code> time.</p><h2 id="Decent-inter-process-communication"><a href="#Decent-inter-process-communication" class="headerlink" title="Decent inter-process communication"></a>Decent inter-process communication</h2><p>One positive technical aspect of node as an automation runtime is its IPC capabilities. Sometimes you prefer to use another tool via CLI over the node API. Cool — in node, this can be done with <a href="https://nodejs.org/api/child_process.html">child_process</a> — asynchronously, and in a cross-platform way! You can even pipe output between different processes, as with shell pipe <code>|</code>. Yes, the built-in <code>Stream</code> and <code>child_process</code> APIs are not too ergonomic, but you can always use a wrapper for your taste — I like <a href="https://stackoverflow.com/questions/3004811/how-do-you-run-multiple-programs-in-parallel-from-a-bash-script">execa.</a></p><p><code>bash</code> is good at process management, too, but there are just too many possibilities for my taste — <a href="https://stackoverflow.com/questions/3004811/how-do-you-run-multiple-programs-in-parallel-from-a-bash-script">this SO questions has five distinct ways of running commands in parallel,</a> and this makes it easy to shoot yourself in the foot if you don’t know what you’re doing (see point on familiarity).</p><h2 id="Vast-ecosystem"><a href="#Vast-ecosystem" class="headerlink" title="Vast ecosystem"></a>Vast ecosystem</h2><p><code>npm</code> has great packages for all sorts of problems. My favorites are <a href="https://github.com/sindresorhus/execa">execa</a> for managing child processes, <a href="https://github.com/yargs/yargs">yargs</a> for handling CLI options and <a href="https://github.com/chalk/chalk">chalk</a> for output styling.</p><p>Yes, many command-line tools exist as well, but you must install them using an OS-specific package manager (apt? brew? apk?). Nobody really wants to deal with this, so you settle on lowest denominator of universal functionality. Besides, any CLI package that you happen to install can be used from node via spawn / exec just as well.</p><hr><p>So, here are my top reasons to pick JS / node for managing complex automation workflows:</p><ol><li>JS is your team’s primary language!</li><li><code>node</code> runtime is usually installed both locally and in CI, since you’re dealing with <code>npm / yarn</code>.</li><li><code>node</code> runs cross-platform, unlike bash and make.</li><li><code>node</code> can directly access other JS tools.</li><li><code>node</code> IPC (for orchestrating CLI tools) is very decent, especially with <a href="https://github.com/sindresorhus/execa">execa.</a></li><li>Many good packages exist for writing CLI tools in node.</li></ol><p>There are reasons to <em>avoid</em> node (like the lack of tutorials on automation use cases and the complexity of async for people unfamiliar with it), but I still believe it’s the most solid choice for build automation in JS projects.</p>
