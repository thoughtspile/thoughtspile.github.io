<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2021/11/30/lazy-useref/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="I love useRef, but it lacks the lazy initializer functionality found in other hooks (useState &#x2F; useReducer &#x2F; useMemo). useRef(&amp;#123; x: 0, y: 0 &amp;#125;) creates an object &amp;#123; x: 0, y: 0 &amp;#125; on ev"><meta property="og:type" content="article"><meta property="og:title" content="Make useRef lazy — 4 ways"><meta property="og:url" content="https://thoughtspile.github.io/2021/11/30/lazy-useref/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="I love useRef, but it lacks the lazy initializer functionality found in other hooks (useState &#x2F; useReducer &#x2F; useMemo). useRef(&amp;#123; x: 0, y: 0 &amp;#125;) creates an object &amp;#123; x: 0, y: 0 &amp;#125; on ev"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/lazy-useref-sofa.jpg"><meta property="article:published_time" content="2021-11-30T11:52:33.000Z"><meta property="article:modified_time" content="2022-01-14T13:29:55.461Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="javascript"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://thoughtspile.github.io/images/lazy-useref-sofa.jpg"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>Make useRef lazy — 4 ways</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://thoughtspile.github.io/2021/11/30/lazy-useref/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Make useRef lazy — 4 ways</h1></header><div class="content" itemprop="articleBody"><p>I love <code>useRef</code>, but it lacks the lazy initializer functionality found in other hooks (<code>useState</code> / <code>useReducer</code> / <code>useMemo</code>). <code>useRef(&#123; x: 0, y: 0 &#125;)</code> creates an object <code>&#123; x: 0, y: 0 &#125;</code> on every render, but only uses it when mounting — it subsequent renders it’s thrown away. With <code>useState</code>, we can replace the initial <em>value</em> with an <em>initializer</em> that’s only called on first render — <code>useState(() =&gt; (&#123; x: 0, y: 0 &#125;))</code> (I’ve explored this and other <code>useState</code> features in my <a href="/2021/09/27/usestate-tricks/">older post</a>). Creating functions is very cheap in modern JS runtimes, so we skip allocating memory and building the object for a slight performance boost (see <a target="_blank" rel="noopener" href="https://jsbench.me/p3kwj6ojfs">benchmark</a>).</p><p>I’m not super excited about doing useless work, and <code>useRef</code> is your primary tool for <a href="/2021/10/18/non-react-state/">avoiding useless re-renders.</a> In this post, I’ll show you four ways to support lazy initializer in <code>useRef</code>:</p><ol><li>Move initialization to <code>useEffect</code></li><li>Sync lazy <code>useRef</code> initializer that works like <code>useState</code> initializer.</li><li>Lazy <code>useRef</code> on top of <code>useState</code> (almost zero code!)</li><li>A <code>useRef</code> that only computes the value when you read <code>.current</code></li></ol><p><img src="/images/lazy-useref-sofa-7ed6546159410f83bc96cb28b084cf9e.jpg"></p><h2 id="Use-cases"><a href="#Use-cases" class="headerlink" title="Use cases"></a>Use cases</h2><p>Any ref that involves an object can benefit from lazy initialization. I use such refs a lot for <a href="/2021/10/18/non-react-state/">tracking gestures:</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touch = useRef(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> onTouchMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  touch.current = &#123;</span><br><span class="line">    <span class="attr">x</span>: e.touches[<span class="number">0</span>].clientX, </span><br><span class="line">    <span class="attr">y</span>: e.touches[<span class="number">0</span>].clientY,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A lazy initializer is useless for atomic values like <code>useRef(9)</code>, since those are cheap to create, too.</p><p>For a slightly different use case, sometimes we want a stateful object (often a Resize/IntersectionObserver) with a stable identity — <code>useMemo</code> <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#usememo">does not guarantee it.</a> We don’t really want to reassign <code>current</code>, so a <code>RefObject</code> API is not needed:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Would be nice</span></span><br><span class="line"><span class="keyword">const</span> observer = useStableMemo(<span class="function">() =&gt;</span> <span class="keyword">new</span> IntersectionObserver(cb), []);</span><br><span class="line"><span class="comment">// Why write observer.current if you never swap an observer?</span></span><br><span class="line"><span class="keyword">const</span> rootRef = useRef(<span class="function"><span class="params">e</span> =&gt;</span> observer.observe(e)).current;</span><br></pre></td></tr></table></figure><p>For each technique, we’ll see how good it is at supporting both use cases.</p><h2 id="The-async-way"><a href="#The-async-way" class="headerlink" title="The async way"></a>The async way</h2><p>The most intuitive way to lazy-initialize a ref is combining a value-less <code>useRef()</code> with a mount effect:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = useRef();</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ref.current = initialValue;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>Nicely, init inside an effect does not (<a href="/2021/11/15/unintentional-layout-effect/">normally</a>) block the paint, allowing you to paint a touch faster. However, this implementation is not always convenient, because the <code>.current</code> value is not accessible before the effect — in the first render phase, in DOM refs, <code>useLayoutEffect</code>, and even in some other <code>useEffect</code>s (inside child components and ones scheduled before the <em>init</em> effect) — try it yourself in a <a target="_blank" rel="noopener" href="https://codepen.io/thoughtspile/pen/wvrvQjN?editors=0011">codepen</a>. If the whole <code>useRef</code> + <code>useEffect</code> construction is written inline in a component, you at least see that the initialization is delayed. Wrapping it into a custom hook increases the chances of a misuse:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = useLazyRef(<span class="function">() =&gt;</span> <span class="keyword">new</span> IntersectionObserver(...));</span><br><span class="line"><span class="comment">// spot the bug</span></span><br><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  observer.current.observe(node);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>The logic relying on <code>.current</code> is awkwardly pushed into effects, complicating your code:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [width, setWidth] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> node = useRef();</span><br><span class="line"><span class="keyword">const</span> observer = useLazyRef(<span class="function">() =&gt;</span> </span><br><span class="line">  <span class="keyword">new</span> ResizeObserver(<span class="function">(<span class="params">[e]</span>) =&gt;</span> setWidth(e.borderBoxSize.width)));</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  observer.current.observe(node.current)</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;node&#125;</span> <span class="attr">data-width</span>=<span class="string">&#123;width&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p>Replacing <code>useEffect</code> with <code>useLayoutEffect</code> does not help much — a bunch of places that can’t access the <code>current</code> still exists (first render, DOM refs, child <code>useLayoutEffect</code>s), <em>and</em> now the initialization blocks the paint. As we’ll see now, better ways to initialize early exist.</p><p>The <code>useEffect</code> approach works OK if you only need <code>.current</code> <em>later</em> — in other effects, timeouts or event handlers (and you’re 100% sure those won’t fire during the first paint). It’s my least favorite approach, because the other ones work better and avoid the “pre-initialization gap”.</p><h2 id="The-DIY-way"><a href="#The-DIY-way" class="headerlink" title="The DIY way"></a>The DIY way</h2><p>If we want the <code>.current</code> value to be available at all times, but without re-creation on every render (a lot like <code>useState</code> / <code>useMemo</code>), we can just build a custom hook over bare <code>useRef</code> ourselves (see <a target="_blank" rel="noopener" href="https://codepen.io/thoughtspile/pen/MWEWzMe?editors=0011">codepen</a>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// none is a special value used to detect an uninitialized ref</span></span><br><span class="line"><span class="keyword">const</span> none = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useLazyRef</span>(<span class="params">init</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// not initialized yet</span></span><br><span class="line">  <span class="keyword">const</span> ref = useRef(none);</span><br><span class="line">  <span class="comment">// if it&#x27;s not initialized (1st render)</span></span><br><span class="line">  <span class="keyword">if</span> (ref.current === none) &#123;</span><br><span class="line">    <span class="comment">// we initialize it</span></span><br><span class="line">    ref.current = init();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// new we return the initialized ref</span></span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This implementation is a good default for custom <code>useLazyRef</code> hooks: it works <em>anywhere</em> — inside render, in effects and layout effects, in listeners, with no chance of misuse, and is similar to the built-in <code>useState</code> and <code>useMemo</code>. To turn it into a readonly ref / stable memo, just return <code>ref.current</code> — it’s already initialized before <code>useLazyRef</code> returns.</p><blockquote><p>Note that using <code>null</code> as the un-initialized value breaks if <code>init()</code> returns <code>null</code>, and setting <code>ref.current = null</code> triggers an accidental re-initialization on next render. <code>Symbol</code> works well and might be more convenient for debugging.</p></blockquote><p>This is the most convenient approach for storing <code>observers</code>, because they’re safe to use from DOM refs:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [width, setWidth] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> observer = useLazyRef(<span class="function">() =&gt;</span> </span><br><span class="line">  <span class="keyword">new</span> ResizeObserver(<span class="function">(<span class="params">[e]</span>) =&gt;</span> setWidth(e.borderBoxSize.width))).current;</span><br><span class="line"><span class="keyword">const</span> nodeRef = useRef(<span class="function">(<span class="params">e</span>) =&gt;</span> observer.observe(e)).current;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;nodeRef&#125;</span> <span class="attr">data-width</span>=<span class="string">&#123;width&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p>The only downside is that the initializer runs even if we never read the value. I’ll show you how to avoid this, but first let’s see how we can (and can’t) build <em>this</em> flavor of lazy <code>useRef</code> over other hooks.</p><h2 id="The-resourceful-way"><a href="#The-resourceful-way" class="headerlink" title="The resourceful way"></a>The resourceful way</h2><p>If <code>useState</code> has the lazy initializer feature we want, why not just use it instead of writing custom code (<a target="_blank" rel="noopener" href="https://codepen.io/thoughtspile/pen/eYGYbYg?editors=0011">codepen</a>)?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = useState(<span class="function">() =&gt;</span> (&#123; <span class="attr">current</span>: init() &#125;))[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>We <code>useState</code> with a lazy initializer that mimics the shape of a RefObject, and throw away the update handle because we’ll never use it — ref identity must be stable. For readonly ref / stable-memo we can skip the <code>&#123; current &#125;</code> trick and just <code>useState(init)[0]</code>. Storing a mutable object in <code>useState</code> is not the most orthodox thing to do, but it works pretty well here. I imagine that at some point future react <em>might</em> choose to rebuild the current <code>useState</code> by re-initializing and re-applying all the updates (e.g. for HMR), but I haven’t heard of such plans, and this will break a lot of stuff.</p><p>As usual, anything doable with <code>useState</code> can also be done with <code>useReducer</code>, but it’s slightly more complicated:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useReducer(</span><br><span class="line">  <span class="comment">// any reducer works, it never runs anyways</span></span><br><span class="line">  <span class="function"><span class="params">v</span> =&gt;</span> v, </span><br><span class="line">  <span class="comment">// () =&gt; &#123;&#125; and () =&gt; 9 work just as well</span></span><br><span class="line">  <span class="function">() =&gt;</span> (&#123; <span class="attr">current</span>: init() &#125;))[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// And here&#x27;s the stable memo:</span></span><br><span class="line">useReducer(<span class="function"><span class="params">v</span> =&gt;</span> v, init)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>The most obvious base hook, <code>useMemo</code>, doesn’t work well. <code>useMemo(() =&gt; (&#123; current: init() &#125;), [])</code> currently returns a stable object, but React docs <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#usememo">warn against relying</a> on this, since a future React version might re-initialize the value when it feels like it. If you’re OK with that, you didn’t need <code>ref</code> in the first place.</p><p><code>useImperativeHandle</code> is not recommended, too — it <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle">has something to do with refs,</a> but its <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/82c8fa90be86fc0afcbff2dc39486579cff1ac9a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1777">implemented</a> to set the value in a layout effect, similar to the worst one of our <code>async</code> options. Also, it</p><p>So, <code>useState</code> allows you to build a <em>lazy ref</em> with almost zero code, at a minor risk of breaking in a future react version. Choosing between this and a DIY lazy ref is up to you, they work the same.</p><h2 id="The-really-lazy-way"><a href="#The-really-lazy-way" class="headerlink" title="The really lazy way"></a>The really lazy way</h2><p>I’d argue that what we’ve discussed so far isn’t really <em>lazy</em> — sure, you avoid useless job on re-render, but you still eagerly compute the initial value on first render. What if we only computed the value on demand, when someone reads <code>.current</code>?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> none = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useJitRef</span>(<span class="params">init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useRef(none);</span><br><span class="line">  <span class="keyword">const</span> ref = useLazyRef(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">current</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (value.current === none) &#123;</span><br><span class="line">        value.current = init();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value.current;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">current</span>(<span class="params">v</span>) &#123;</span><br><span class="line">      value.current = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tricky! See <a target="_blank" rel="noopener" href="https://codepen.io/thoughtspile/pen/YzrzdyJ?editors=0011">codepen</a>, and let me break it down for you:</p><ul><li>Wrap the bare ref with a get / set interceptor</li><li>Reading <code>current</code> goes through the <code>get()</code>, computing the value on first read and returning the cached value later.</li><li>Assigning <code>current</code> updates the value instantly and removes the need to initialize.</li><li>The wrapper object is a <code>useLazyRef</code> itself to preserve the builtin <code>useRef</code> guarantee of stable identity and avoid extra object creation.</li></ul><p>For readonly ref / stable memo, try the simpler <em>getter function</em> approach <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily">suggested in react docs:</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> none = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMemoGet</span>(<span class="params">init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useRef(none);</span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.current === none) &#123;</span><br><span class="line">      value.current = init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value.current;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Is it worth the trouble? Maybe, maybe not. The code is more complicated than the eager <code>useLazyRef</code>. If the initializer is <em>really</em> heavy, and you use the value conditionally, and you often end up not needing it, sure, it’s a good fit. Honestly, I have yet to see a use case that fits these conditions.</p><p>This is a very interesting and flexible technique that supports many variations:</p><ul><li>Pre-compute the value, e.g. in <code>requestIdleCallback(() =&gt; ref.current)</code></li><li>Allow for lazy updates — don’t set the explicit value, but provide a new way to compute it: <code>ref.current = () =&gt; el.clientWidth</code></li><li>Replace <em>updating</em> with <em>invalidation</em> — say, with <code>getWidth = useMemoGet(() =&gt; el.clientWidth)</code> you can mark the cached value as stale with <code>getWidth.invalidate()</code> on content change.</li></ul><hr><p>We’ve covered 4 good base techniques (<code>useState</code> is an alternative implementation of ) for creating lazy useRef. They all have different characteristics that make them useful for different problems:</p><ul><li>Initialize in <code>useEffect</code> — not recommended because it’s easy to hit un-initialized <code>.current</code>.</li><li>Sync custom-built <code>useRef</code> works well, but blocks first render. Good enough for most cases.</li><li>Putting the value into <code>useState</code>‘s initializer, but hiding the update handle. Least code, but a chance of breaking in future react versions.</li><li>On-demand <code>useRef</code> that only computes the value when you read <code>.current</code> — complicated, but flexible and never computes values you don’t use.</li></ul><p>Hope you find this useful! If you want to learn more about react, check out my <a href="/">other posts.</a></p></div><span class="share"><div><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://thoughtspile.github.io/2021/11/30/lazy-useref/&text=Make useRef lazy — 4 ways by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://thoughtspile.github.io/2021/11/30/lazy-useref/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/javascript/" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2021-11-30T11:52:33.000Z" itemprop="datePublished">2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/11/20/open-source-starter/"><div class="post-siblings__direction">Older</div><span class="link__text">Open source starter pack for JS devs</span> </a><a class="link--bare" href="/2022/01/17/jsx-conditionals/"><div class="post-siblings__direction">Newer</div><span class="link__text">Good advice on JSX conditionals</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-7bc8702b14501402f6b7d1cf149776a9.js"></script>