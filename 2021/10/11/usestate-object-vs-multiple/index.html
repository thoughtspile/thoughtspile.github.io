<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2021/10/11/usestate-object-vs-multiple/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="Lately I’ve converted a lot of class components to functional. One question left me curious every time — why do I feel like splitting the old class state into so many useState(atom) — one for each sta"><meta property="og:type" content="article"><meta property="og:title" content="Are many useStates better than useState(object)?"><meta property="og:url" content="https://thoughtspile.github.io/2021/10/11/usestate-object-vs-multiple/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="Lately I’ve converted a lot of class components to functional. One question left me curious every time — why do I feel like splitting the old class state into so many useState(atom) — one for each sta"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/usestate-perf.png"><meta property="article:published_time" content="2021-10-11T16:52:18.000Z"><meta property="article:modified_time" content="2022-01-14T13:29:55.467Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="javascript"><meta property="article:tag" content="frontend"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://thoughtspile.github.io/images/usestate-perf.png"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>Are many useStates better than useState(object)?</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://thoughtspile.github.io/2021/10/11/usestate-object-vs-multiple/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Are many useStates better than useState(object)?</h1></header><div class="content" itemprop="articleBody"><p>Lately I’ve converted <em>a lot of</em> class components to functional. One question left me curious every time — why do I feel like splitting the old class <code>state</code> into so many <code>useState(atom)</code> — one for each state key? Is there any real benefit in it? Should I just leave a single <code>useState(whatever this.state was)</code> to touch as little code as possible during refactoring? Today, we’ll discuss if having many <code>useState(atom)</code> is better than one single <code>useState(object)</code> — and, exactly, why. (Spoiler: it depends).</p><h2 id="Collection-gt-object-state"><a href="#Collection-gt-object-state" class="headerlink" title="Collection =&gt; object state"></a>Collection =&gt; object state</h2><p>To get the obvious out of the way: if your state is a collection — multiple similar values, probably dynamic quantity, normally in an array or a key:value object — you have to use object state. Someone with a dirty mind could work around that with serialization or recursive components, but let’s not go there.</p><h2 id="State-decomposition"><a href="#State-decomposition" class="headerlink" title="State decomposition"></a>State decomposition</h2><p>Common architectural sense tells us to split totally unrelated pieces of state into multiple <code>useStates</code>. The ability of separating state like that is one of the better features hooks offer. If you have a component that tracks input value, but <em>also</em> happens to track wheter the input has focus, go ahead and separate focus-state and value-state:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// no</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> isFocused <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  isFocused<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token operator">&lt;</span>input
  value<span class="token operator">=</span><span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>value<span class="token punctuation">&#125;</span>
  data<span class="token operator">-</span>focus<span class="token operator">=</span><span class="token punctuation">&#123;</span>isFocused<span class="token punctuation">&#125;</span>
  onChange<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> value<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span> isFocused <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
  onFocus<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> isFocused<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
  onBlur<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> value<span class="token punctuation">,</span> isFocused<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
<span class="token operator">/</span><span class="token operator">></span>

<span class="token comment">// yes</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>isFocused<span class="token punctuation">,</span> setFocused<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token operator">&lt;</span>input
  value<span class="token operator">=</span><span class="token punctuation">&#123;</span>value<span class="token punctuation">&#125;</span>
  data<span class="token operator">-</span>focus<span class="token operator">=</span><span class="token punctuation">&#123;</span>isFocused<span class="token punctuation">&#125;</span>
  onChange<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setValue</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
  onFocus<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setFocused</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
  onBlur<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setFocused</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
<span class="token operator">/</span><span class="token operator">></span></code></pre><p>I’m getting a bit ahead of myself, but the second variant is shorter and looks clearer to me. You also get to use the extra convenience useState provides for atomic values (more on that in a moment). Also, if at some point you decide to extract focus-management into a custom hook, you’re well prepared.</p><p>— But wait, Vladimir, didn’t you just tell us to <a href="/2021/10/04/react-context-dangers">wrap context value in an object,</a> even if it has a single item?</p><p>— Yes, but this time it’s different! To change context value from atom to an object, you must edit all the places where you read the context — that’s your whole codebase. Component state is local, so it takes a single destructuring — <code>[value, setValue] = useState(0) -&gt; [&#123; value &#125;, setValue] = useState(&#123; value: 0 &#125;)</code>. Besides, unlike context, state shape is not likely to be your public API.</p><h2 id="useState-atom-benefits"><a href="#useState-atom-benefits" class="headerlink" title="useState(atom) benefits"></a>useState(atom) benefits</h2><p>Now let’s see, exactly, why useState works better with atomic values.</p><h3 id="Convention"><a href="#Convention" class="headerlink" title="Convention"></a>Convention</h3><p>The feeling that <code>useState</code> should be used with atoms is there for a reason — the API is designed to push you towards this idea.</p><p>First, <code>setState(&#123; value: 0 &#125;)</code> sets the state to that exact object — <code>&#123; &#39;value&#39;: 0 &#125;</code>. Class component’s <code>this.setState(&#123; value: 0 &#125;)</code> will merge the update with the current state. You can <a target="_blank" rel="noopener" href="https://ru.react.js.org/docs/hooks-reference.html#usestate">mimic this behavior</a> with a spread: <code>setState(&#123; ...state, value: 0 &#125;)</code>, but note how you’re fighting react. Manually constructing the next state object without spreads: <code>setState(&#123; focus, value: 0 &#125;)</code> is explosive — it’s easy to miss an update site if you’re adding a new key to your state and erase a part of the state.</p><p>Next, as explained in my post on <a href="/2021/09/27/usestate-tricks">useState tricks</a>, <code>setState(value)</code> does nothing when value is equal to the current state. Working with atomic values makes it trivial to use this feature, because atoms are compared by value. By contrast, <code>this.setState(&#123; value &#125;)</code> in a <code>PureComponent</code> is followed by a shallow object equality check.</p><p>So, while class components were designed to work best with objects (indeed, component state is always an object), <code>useState</code> has a speacial optimization for atomic values, and does includes no conveniences for working with objects. You can work around both issues with a custom hook, but why fight React if it politely asks you to prefer atomic state?</p><h3 id="Bundle-size"><a href="#Bundle-size" class="headerlink" title="Bundle size"></a>Bundle size</h3><p>One possible advantage of not using objects is the reduced bundle size — the <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">original hooks announcement</a> by React team specifiaclly mentioned that <em>classes don’t minify very well.</em> Let’s pass our sample component that tracks focus and value through the normal build toolchain — babel + terser + gzip, and see if that’s true.</p><p>Looking at the minified object-state variant, we can see that the minifier can’t do anything about the keys of our object. Terser is very smart, but it has no idea if <code>isFocused</code> and <code>value</code> keys mean anything to that <code>useState</code> function we’re passing our object through, so it can’t mangle the keys. Note, however, that this has nothing to do with <em>classes</em> — any object has the same problem. Here’s the component — It’s 338 bytes raw, and 128 bytes under gzip:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>isFocused<span class="token operator">:</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">,</span>value<span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token operator">=</span>n<span class="token punctuation">.</span>value<span class="token punctuation">,</span>o<span class="token operator">=</span>n<span class="token punctuation">.</span>isFocused<span class="token punctuation">,</span>u<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>value<span class="token operator">:</span>state<span class="token punctuation">.</span>value<span class="token punctuation">,</span><span class="token string">"data-focus"</span><span class="token operator">:</span>o<span class="token punctuation">,</span><span class="token function-variable function">onChange</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>value<span class="token operator">:</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span>isFocused<span class="token operator">:</span>o<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">onFocus</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>value<span class="token operator">:</span>r<span class="token punctuation">,</span>isFocused<span class="token operator">:</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">onBlur</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>value<span class="token operator">:</span>r<span class="token punctuation">,</span>isFocused<span class="token operator">:</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>Now let’s try the object-free version. It doesn’t pass the state object anywhere, and symbolic variable names are successfully mangled:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>o<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>u<span class="token operator">=</span>o<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">=</span>o<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>value<span class="token operator">:</span>u<span class="token punctuation">,</span><span class="token string">"data-focus"</span><span class="token operator">:</span>n<span class="token punctuation">,</span><span class="token function-variable function">onChange</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">i</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">onFocus</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">onBlur</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>This minified component is 273 bytes. So, case solved — at 65 bytes, or 20% off, atoms win, objects suck, right? Not so fast: the gzip size is 112 bytes, only 16 bytes / 12.5% smaller, and that’s an abyssmal difference, especially in absolute terms.</p><p>In case you’re curious, I included React in both bundles to gize gzip some warm-up data. I also transpiled down to IE11. Have fun with your own measurements if you feel I missed something!</p><p>So, you’d have to try very hard, with hundreds of components, to get any meaningful post-gzip bundle size reduction from using atomic state over objects. Still, the difference exists, so that’s half a point to atoms.</p><h2 id="Should-you-ever-useState-object"><a href="#Should-you-ever-useState-object" class="headerlink" title="Should you ever useState(object)?"></a>Should you ever useState(object)?</h2><p>So far, we’ve seen that multiple <code>useState(atom)</code> work well for breaking state into independent fragments. Atomic state is often more convenient, more conventional and gives you a slightly smaller bundle. So, are there any reasons to use object state in hooks, other than managing collections? There is a couple.</p><h3 id="Update-batching"><a href="#Update-batching" class="headerlink" title="Update batching"></a>Update batching</h3><p>As we’ve discussed <a href="/2021/09/27/usestate-tricks">before</a>, React &lt;18 will not batch state updates from outside event handlers. Let’s look at a familiar data-fetch example:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Hints</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isLoading<span class="token punctuation">,</span> setLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>hints<span class="token punctuation">,</span> setHints<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/hints'</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        <span class="token function">setHints</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setLoading</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span>isLoading
      <span class="token operator">?</span> <span class="token string">'loading...'</span> <span class="token operator">:</span>
      hints<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">h</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>h<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>The component mounts with a loading indicator, calls an API endpoint, then disables the loader and shows some data once loaded. The only problem here is that since <code>loading</code> and <code>hints</code> are set via 2 different state updates from a promise (that’s not an event handler), you end up rendering and modifying the DOM twice after load.</p><p>Grouping the loading flag and data into an object allows us to update the state in one call, eliminating the extra render:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> isLoading<span class="token punctuation">,</span> hints <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> setSuggest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  isLoading<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  hints<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/hints'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token function">setSuggest</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        hints<span class="token operator">:</span> data<span class="token punctuation">,</span>
        isLoading<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Granted, you can also work around this issue while keeping your state split with a scary-sounding <code>unstable_batchedUpdates</code> from <code>react-dom</code>:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>isLoading<span class="token punctuation">,</span> setLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>hints<span class="token punctuation">,</span> setHints<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/hints'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// triggers just one render</span>
      <span class="token function">unstable_batchedUpdates</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        <span class="token function">setHints</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setLoading</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Still, I’d prefer grouping state in an object over using <code>unstable_</code> things and trying not to forget it every time I update the state. That’s one use case where wrapping related state in an object makes sense — until react 18, it produces fewer renders when updating these related values.</p><h3 id="Arrow-updates"><a href="#Arrow-updates" class="headerlink" title="Arrow updates"></a>Arrow updates</h3><p><a href="/2021/09/27/usestate-tricks">If you recall,</a> <code>useState</code> allows you to update state using a callback AKA <em>mini-reducer.</em> The callback gets the current value as an agrument. We can use it to avoid data fetch race condition in a typeahead:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Hints</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>search<span class="token punctuation">,</span> setSearch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    query<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
    hints<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/hints/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>search<span class="token punctuation">.</span>query<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">hints</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        <span class="token function">setSearch</span><span class="token punctuation">(</span><span class="token parameter">s</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>query <span class="token operator">!==</span> search<span class="token punctuation">.</span>query<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// skip the update if query has changed</span>
            <span class="token keyword">return</span> s<span class="token punctuation">;</span>
          <span class="token punctuation">&#125;</span>
          <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span>search<span class="token punctuation">,</span> hints <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>search<span class="token punctuation">.</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
      <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>query<span class="token punctuation">&#125;</span></span>
      <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setSearch</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token operator">...</span>search<span class="token punctuation">,</span> query<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span>
    <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span>state<span class="token punctuation">.</span>hints<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">h</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>h<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>Here, we look at the <em>current</em> query after loading the hints, and only show the hints we loaded if the query has not changed since. Not the most elegant solution, but it works, and so it’s a valid state model. If you were to split query and hints into separate states, you’d lose the ability to read current query when setting hints, and have to solve this problem some other way.</p><p>More generally (maybe too generally), if updates to state B depend on state A, states A and B should probably we wrapped in an object.</p><h2 id="Appendix-A-useObjectState"><a href="#Appendix-A-useObjectState" class="headerlink" title="Appendix A: useObjectState"></a>Appendix A: useObjectState</h2><p>I promised you can have all the convenience of class <code>setState</code> in a custom hook. Here we go:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useObjectState</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> patch</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> changed <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>patch<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!==</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> changed <span class="token operator">?</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span>s<span class="token punctuation">,</span> <span class="token operator">...</span>patch <span class="token punctuation">&#125;</span> <span class="token operator">:</span> s<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre><p>Here, we merge old and new state, and also preserve the old state object reference if the patch contains no changes. Easy breezy.</p><h2 id="Appendix-B-Runtime-performance"><a href="#Appendix-B-Runtime-performance" class="headerlink" title="Appendix B: Runtime performance"></a>Appendix B: Runtime performance</h2><p>For a tie-breaker, let’s see if the amount of <code>useState</code> calls impacts your application performance.</p><p>I expect the runtime performance difference between single object state and multiple atomic states to be even more negligible than that of bundle size. Still, the fact that it could go both ways is made me curious: object state allocates an extra object (or function, with a lazy initializer) on every render, but atoms call more react internals. Is there a winner?</p><p>I’ve made a tiny <a target="_blank" rel="noopener" href="https://jsbench.me/qvkumpoejp/1">benchmark</a> comparing several useState calls, single <code>useState(object)</code> call and single <code>useState(() =&gt; lazy object)</code>. The results are available in a <a target="_blank" rel="noopener" href="https://docs.google.com/spreadsheets/d/1IpPuc77S9UODSpLELqGSy-_06xYo11BIEcHVadId1H0/edit?usp=sharing">google sheet</a>. I’ve also made a nice chart that shows percent increase in mount time over baseline — no hooks, just a stateless render:</p><p><img src="/images/usestate-perf-64be2ee75368d1b48f27094e99f35ebb.png"></p><p>I wouldn’t dare interpret these results given how cool optimizing compilers are, but the general as I see it pattern makes sense:</p><ul><li>1 <code>useState</code> with atom is slightly better than with object because we skip object allocation.</li><li><code>useState</code> calls are more expensive than object allocations, so for 3+ items <code>useState(object)</code> wins.</li><li>Lazy initializer beats object creation — not sure why, if the initializer is always called on mount.</li></ul><p>Note that the difference here is in sub-microsecond range (yes, MICROsecond, 1/1000th of a millisecond, or 1/16000th of a 60FPS frame), so any practical implications are laughable. Still, good to know that using hooks is almost free.</p><hr><p>So, useState is probably better suited for storing atomic values, but object state still has its uses. Here’s what we learnt:</p><ul><li><code>useState</code> update handle skips re-render by checking for <code>===</code> equality, and that’s easier to achieve with atomic values.</li><li><code>useState</code> has no built-in object merging mechanism.</li><li>Atomic state makes your bundle a <em>little bit</em> smaller, because object keys are hard to mangle.</li><li>Collection state only works as an object.</li><li>Until React 18, async updates to several <code>useStates</code> result in useless renders. Use object state or <code>unstable_batchedUpdates</code> to render once.</li><li>You can’t access the current state of another <code>useState</code> in a state update callback (ouch, that’s a complex statement with many states involved) — use object state for values that depend on each other during update.</li><li>Any performace difference between <code>useState</code> variants is negligible.</li></ul><p>I feel the deciding factor here is state modelling — grouping several state items in an object signals that they are closely related, while splitting them apart shows they are orthogonal. Please model your state based on common sense, not some prejudices agains objects. Ah, and also — everything we just discussed also applies to <code>useReducer</code>, because <code>useState</code> is <code>useReducer</code>. Good luck and see you next time!</p></div><span class="share"><div><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://thoughtspile.github.io/2021/10/11/usestate-object-vs-multiple/&text=Are many useStates better than useState(object)? by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://thoughtspile.github.io/2021/10/11/usestate-object-vs-multiple/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/frontend/" rel="tag">frontend</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/javascript/" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2021-10-11T16:52:18.000Z" itemprop="datePublished">2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/10/06/babel-runtime-version/"><div class="post-siblings__direction">Older</div><span class="link__text">Is your babel's transform-runtime getting lazy? You better check.</span> </a><a class="link--bare" href="/2021/10/13/really-declarative/"><div class="post-siblings__direction">Newer</div><span class="link__text">Thanks React, I'm fine with an imperative setInterval</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-7bc8702b14501402f6b7d1cf149776a9.js"></script>