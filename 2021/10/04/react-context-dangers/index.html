<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2021/10/04/react-context-dangers/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="useContext hook has made React Context API so pleasant to work with that many people are even suggesting that we drop external state management solutions and rely on the built-in alternative instead."><meta property="og:type" content="article"><meta property="og:title" content="How to destroy your app performance using React contexts"><meta property="og:url" content="https://thoughtspile.github.io/2021/10/04/react-context-dangers/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="useContext hook has made React Context API so pleasant to work with that many people are even suggesting that we drop external state management solutions and rely on the built-in alternative instead."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/die-redux.png"><meta property="article:published_time" content="2021-10-04T11:20:49.000Z"><meta property="article:modified_time" content="2022-01-14T13:29:55.463Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="programming"><meta property="article:tag" content="frontend"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://thoughtspile.github.io/images/die-redux.png"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>How to destroy your app performance using React contexts</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://thoughtspile.github.io/2021/10/04/react-context-dangers/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">How to destroy your app performance using React contexts</h1></header><div class="content" itemprop="articleBody"><p><code>useContext</code> hook has made React Context API so pleasant to work with that many people are even <a target="_blank" rel="noopener" href="https://www.sitepoint.com/replace-redux-react-hooks-context-api/">suggesting</a> that we drop external state management solutions and rely on the built-in <em>alternative</em> instead. This is dangerous thinking that can easily push your app’s performance down the drain if you’re not careful. In this article, I explore the perils of using contexts, and provide several tips to help you optimize context usage. Let’s go!</p><p><img src="/images/die-redux-fa82d421d28c38e3ca2f3a98189b89d0.png"></p><h2 id="Context-change-re-renders-every-consumer"><a href="#Context-change-re-renders-every-consumer" class="headerlink" title="Context change re-renders every consumer"></a>Context change re-renders every consumer</h2><p>We’re building a library of react components, and sometimes the design depends on viewport size. Most of the time breakpoint status (mobile / desktop) is enough, but in some cases we need the exact pixel size. We store that data in a context:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AdaptivityContext = useContext(&#123;&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AdaptivityProvider = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [width, setWidth] = useState(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">    useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> onResize = <span class="function">() =&gt;</span> setWidth(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, onResize);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;resize&#x27;</span>, onResize);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">const</span> adaptivity = &#123;</span><br><span class="line">        width,</span><br><span class="line">        <span class="attr">isMobile</span>: width &lt;= <span class="number">680</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AdaptivityContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;adaptivity&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">AdaptivityContext.Provider</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Life’s good: instead of wrangling with <code>window.innerWidth</code> and global event listeners in every component, we can just read the context and get automatic updates. Here’s for a single-breakpoint design:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> InfoBar = <span class="function">(<span class="params">&#123; text, info &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isMobile &#125; = useContext(AdaptivityContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;text&#125;</span></span><br><span class="line"><span class="xml">        &#123;isMobile ? <span class="tag">&lt;<span class="name">i</span> <span class="attr">title</span>=<span class="string">&#123;info&#125;</span> /&gt;</span> : <span class="tag">&lt;<span class="name">small</span>&gt;</span>&#123;info&#125;<span class="tag">&lt;/<span class="name">small</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>And here’s for pixel-width:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FullWidth = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; width &#125; = useContext(AdaptivityContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">position:</span> &#x27;<span class="attr">fixed</span>&#x27;, <span class="attr">left:</span> <span class="attr">0</span>, <span class="attr">width</span> &#125;&#125; &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>But there’s a catch. If we resize the window a little bit without crossing the 620px breakpoint, both components will re-render, since <code>useContext</code> subscribes to context value changes, and doesn’t care that you use only a part of that value that didn’t change (<code>isMobile</code>). Of course, <code>InfoBar</code> does not actually depend on <code>width</code>, and React will not touch the DOM, but I’d still much prefer not trying to re-render it at all.</p><h3 id="Rule-1-make-smaller-contexts"><a href="#Rule-1-make-smaller-contexts" class="headerlink" title="Rule 1: make smaller contexts"></a>Rule 1: make smaller contexts</h3><p>In this case, the fix is fairly easy. We can split the original <code>AdaptivityContext</code> into two parts, so that every component can explicitly state if it depends on <code>width</code> or the breakpoint:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SizeContext = useContext(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> MobileContext = useContext(&#123;&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AdaptivityProvider = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [width, setWidth] = useState(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">    useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> onResize = <span class="function">() =&gt;</span> setWidth(<span class="built_in">window</span>.innerWidth);</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, onResize);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;resize&#x27;</span>, onResize);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">const</span> isMobile = width &lt;= <span class="number">680</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">SizeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">width</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MobileContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">isMobile</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;props.children&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">MobileContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">SizeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now we can <code>&#123; width &#125; = useContext(SizeContext)</code>, <code>&#123; isMobile &#125; = useContext(MobileContext)</code>, or even both. The code is a little more verbose, but the change is worth it: if a component relies on <code>MobileContext</code>, it does not re-render on <code>width</code> change. Or does it? My bad:</p><ul><li>We create a new context-value object on every render</li><li><code>setWidth</code> triggers a re-render</li><li>Therefore, <code>setWidth</code> creates new MobileContext value</li><li>Since <code>MobileContext</code> value changed by reference, every <code>MobileContext</code> consumer re-renders.</li></ul><p>We need a fix.</p><h3 id="Rule-2-stabilize-context-values"><a href="#Rule-2-stabilize-context-values" class="headerlink" title="Rule 2: stabilize context values"></a>Rule 2: stabilize context values</h3><p>Context tracks value, object or not, using simple equality. This means that we have to stabilize object reference ourselves:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sizeContext = useMemo(<span class="function">() =&gt;</span> (&#123; width &#125;), [width]);</span><br><span class="line"><span class="keyword">const</span> mobileContext = useMemo(<span class="function">() =&gt;</span> (&#123; isMobile &#125;), [isMobile]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">SizeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;sizeContext&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">MobileContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;mobileContext&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;props.children&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">MobileContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">SizeContext.Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>If listing dependencies feels boring, try <code>useObjectMemo</code> hook I proposed in an <a href="https://thoughtspile.github.io/2021/04/05/useref-usememo/">earlier post</a>. Now, finally, the components that depend on <code>isMobile</code> only will not re-render on every width change.</p><h3 id="Rule-2-option-b-Maybe-use-atomic-context-values"><a href="#Rule-2-option-b-Maybe-use-atomic-context-values" class="headerlink" title="Rule 2, option b: Maybe use atomic context values"></a>Rule 2, option b: Maybe use atomic context values</h3><p>Making context value an atomic type, not an object, may seem smart:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ha, atomic types are compared by value</span></span><br><span class="line">&lt;SizeContext.Provider value=&#123;width&#125;&gt;</span><br></pre></td></tr></table></figure><p>But what happens if we want to pass height? Changing SizeContext type to an object requires you to rewrite every <code>width = useContext(SizeContext)</code> to accept objects instead. Unpleasant, and impossible if <code>SizeContext</code> is your public API.</p><p>We can create a new <code>HeightContext</code>, but this quickly escalates into <strong>context hell</strong> with very little reward, since width and height tend to change together and you won’t avoid many re-renders by observing only one of them.</p><p>I’d only use atomic types for context values if I’m absolutely sure there are no values with similar change patterns and use cases that I might want to pass along later.</p><h2 id="Rule-3-Make-smaller-context-consumers"><a href="#Rule-3-Make-smaller-context-consumers" class="headerlink" title="Rule 3: Make smaller context consumers"></a>Rule 3: Make smaller context consumers</h2><p>On a side note, you can have a huge component that only has a few parts that depend on context. Re-rendering this component is hard even though the DOM change itself is small. Maybe something like a modal that only closes via gestures on mobile, but has a special close button on desktop:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Modal = <span class="function">(<span class="params">&#123; children, onClose &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isMobile &#125; = useContext(MobileContext);</span><br><span class="line">    <span class="comment">// a lot of modal logic with timeouts, effects and stuff</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Modal&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* a lot of modal layout */&#125;</span></span><br><span class="line"><span class="xml">        &#123;!isMobile &amp;&amp; <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Modal__close&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onClose&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, you could move the context usage to a separate component and re-render just the close icon on resize:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModalClose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isMobile &#125; = useContext(MobileContext);</span><br><span class="line">    <span class="keyword">return</span> isMobile ? <span class="literal">null</span> : <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Modal__close&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onClose&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Modal = <span class="function">(<span class="params">&#123; children, onClose &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// a lot of modal logic with timeouts, effects and stuff</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Modal&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* a lot of modal layout */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ModalClose</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Or you can use <code>Context.Consumer</code> without creating an extra component:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Modal = <span class="function">(<span class="params">&#123; children, onClose &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// a lot of modal logic with timeouts, effects and stuff</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Modal&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* a lot of modal layout */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">MobileContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;(&#123; isMobile &#125;) =&gt;</span></span><br><span class="line"><span class="xml">                isMobile ? null : <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Modal__close&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onClose&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">MobileContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection-context"><a href="#Collection-context" class="headerlink" title="Collection context"></a>Collection context</h2><p>A single-object context with pre-defined keys can be easily split into several parts. Sadly, this does not work for a <em>collection context</em> — when you have many dynamic items, and the consumer only depends on one of them. Let’s kick off our second example with a smart form controller:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FormState = createContext(&#123; <span class="attr">value</span>: &#123;&#125;, <span class="attr">setValue</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;);</span><br><span class="line"><span class="keyword">const</span> Form = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// collection of form item values</span></span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = useState(&#123;&#125;);</span><br><span class="line">    <span class="comment">// basic submit handler</span></span><br><span class="line">    <span class="keyword">const</span> handleSubmit = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        props.onSubmit(value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// stabilize the context object</span></span><br><span class="line">    <span class="keyword">const</span> contextValue = useMemo(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        value,</span><br><span class="line">        setValue</span><br><span class="line">    &#125;), [value]);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">FormState.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">form</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">FormState.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// only exposes a single item by name</span></span><br><span class="line"><span class="keyword">const</span> useFormState = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, setValue &#125; = useContext(FormState);</span><br><span class="line">    <span class="keyword">const</span> onChange = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setValue(<span class="function"><span class="params">v</span> =&gt;</span> (&#123; ...v, [props.name]: e.target.value &#125;));</span><br><span class="line">    &#125;, [props.name]);</span><br><span class="line">    <span class="keyword">return</span> [value[name], onChange];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> FormInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [value, onChange] = useFormState(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Looks neat! We can now put any markup in <code>&lt;Form&gt;</code>, and then bind to the form value using <code>&lt;FormItem&gt;</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Form&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">FormInput</span> <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">FormInput</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">FormInput</span> <span class="attr">name</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">FormInput</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">FormInput</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">FormInput</span>&gt;</span></span></span><br><span class="line">&lt;/Form&gt;</span><br></pre></td></tr></table></figure><p>Watch closely! <code>FormState</code> context changes on every form item change. <code>FormInput</code> uses the full <code>FormState</code> context. This means that every <code>FormItem</code> re-renders on every form item change, even though it only depends on <code>value[name]</code>. This time we can’t give every form item an individual context, since the items can be highly dynamic. There’s no easy fix this time, but let’s see what we can do.</p><blockquote><p>Disclaimer: our incredible form has seven HTML elements, and updating the is a breeze for react. Please play along and pretend that <code>FormInput</code> is an incredibly tweakable synthetic field with icons and dropdowns, and we have 100 items in a form.</p></blockquote><h3 id="Tip-consider-a-HOC"><a href="#Tip-consider-a-HOC" class="headerlink" title="Tip: consider a HOC"></a>Tip: consider a HOC</h3><p>We can’t prevent <code>useContext</code> from running the whole render function on every context change. What we can do instead is make the render function lighter and leverage <code>memo</code> to tell React not to re-render. It’s similar to what we did the modal example, but the context-dependent part is the wrapper now, not the child. If you still remember, this pattern is called container / presentation (aka smart / dumb) components:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FormItemDumb = memo(<span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>);</span><br><span class="line"><span class="keyword">const</span> FormItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [value, onChange] = useFormState(props.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">FormItemDumb</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>We still run the whole <code>FormItem</code> render on every context change, but now the <em>render</em> is just the <code>useContext</code> call. From there, <code>FormItemDumb</code> will see if the change was relevant, and skip re-rendering if it wasn’t. Much better! Just for kicks, let’s try again, with a higher-order component:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FormItemDumb = <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> withFormState = <span class="function"><span class="params">Wrapped</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> PureWrapped = memo(Wrapped);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [value, onChange] = useFormState(props.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">PureWrapped</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> FormItem = withFormState(FormItemDumb);</span><br></pre></td></tr></table></figure><p><code>withFormState</code> can wrap any component, not only <code>input</code>, and gives us the same flexibility as <code>useFormState</code> hook, but without the extra re-renders.</p><h2 id="How-the-big-guys-do-it"><a href="#How-the-big-guys-do-it" class="headerlink" title="How the big guys do it"></a>How the big guys do it</h2><p>People who write state management libraries, could benefit from context the most, and know the inner workings of react much better than you or me. Let’s see how they approach these problems.</p><p><code>mobx</code> API for binding components is <code>observer(Component)</code>, which might lead you to believe it uses our HOC method, but it <a target="_blank" rel="noopener" href="https://github.com/mobxjs/mobx/blob/main/packages/mobx-react-lite/src/observer.ts">actually doesn’t</a>. Instead, it calls your component as a function, and then uses mobx dependency detection. No contexts involved at all — makes sense, since we didn’t have a provider in the first place. But, fine, mobx is an oddball.</p><p>Redux seems to do things the react way, and <code>react-redux</code> <a target="_blank" rel="noopener" href="https://react-redux.js.org/introduction/getting-started">does use</a> a <code>Provider</code> — maybe it knows a way to optimize context usage? Nope, <code>useSelector</code> subscribes to the store <a target="_blank" rel="noopener" href="https://github.com/reduxjs/react-redux/blob/master/src/hooks/useSelector.ts">via a custom subscription</a> runs custom shallow comparison and only triggers a render if the selected fragment has changed. The context just injects the store instance.</p><p>OK, redux and mobx are mature libraries that don’t pretend to be super tiny. Maybe newer state managers have fresh ideas. Zustand? <a target="_blank" rel="noopener" href="https://github.com/pmndrs/zustand/blob/main/src/index.ts">Custom subscription.</a> Unistore? <a target="_blank" rel="noopener" href="https://github.com/developit/unistore/blob/master/src/integrations/react.js">Custom subscription.</a> Unstated? <a target="_blank" rel="noopener" href="https://github.com/jamiebuilds/unstated-next/blob/master/src/unstated-next.tsx">Raw context for hooks version,</a> but it’s 200 bytes and it works.</p><p>So, none of the major state managers rely on the context API — not even those that could. They avoid the performance problems by using custom subscriptions and only updating if the <em>relevant</em> state has changed.</p><h2 id="The-react-future"><a href="#The-react-future" class="headerlink" title="The react future"></a>The react future</h2><p>React core team is, of course, aware of this shortcoming — <a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/14110">this issue</a> is an interesting read. Context API even had a weird <a target="_blank" rel="noopener" href="https://hph.is/coding/bitmasks-react-context">observedBits feature,</a> but it’s <a target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/20953">gone now.</a></p><p>The way forward appears to be <em>context selectors</em> — used like <code>useContext(Context, c =&gt; c[props.id])</code>. An <a target="_blank" rel="noopener" href="https://github.com/reactjs/rfcs/pull/119">RFC</a> has been open since 2019, and an <a target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/20646">experimental PR implementing it</a> is in the works. Still, this feature is not coming in <a target="_blank" rel="noopener" href="https://github.com/reactwg/react-18/discussions/73">react 18</a>. In the meantime, Daishi Kato has made two cool libraries: <a target="_blank" rel="noopener" href="https://github.com/dai-shi/use-context-selector">use-context-selector</a>, that implements the RFC, and a proxy-based <a target="_blank" rel="noopener" href="https://github.com/dai-shi/react-tracked">react-tracked</a>, to eliminate the wasted renders.</p><hr><p><code>Context</code> API is a nice feature, but, since <em>every</em> context update always re-renders <em>every</em> consumer of this context, may cause performance problems if not used carefully. To mitigate this:</p><ul><li>Move context values with different change patterns into separate contexts.</li><li>Always stabilize context value object reference or use atomic types.</li><li>Make components that use context as small as possible, so that their re-renders are fast.</li><li>Split a component into a HOC-like wrapper with <code>useContext</code>, and a simple renderer wrapped in <code>memo()</code></li><li>Look into <a target="_blank" rel="noopener" href="https://github.com/dai-shi">dai-shi’s amazing useContext wrappers.</a></li><li>Context is not suitable for complex state management. Try using a real state manager.</li></ul><p>As usual, have fun, make good apps, don’t ride the hype train. If you like what I have to say about React, see if <a href="https://thoughtspile.github.io/2021/09/27/usestate-tricks/">setState has some features you don’t know</a> (a big hit!) or <a href="https://thoughtspile.github.io/2021/09/21/useeffect-derived-state/">why you shouldn’t setState in useLayoutEffect</a>.</p></div><span class="share"><div><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://thoughtspile.github.io/2021/10/04/react-context-dangers/&text=How to destroy your app performance using React contexts by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://thoughtspile.github.io/2021/10/04/react-context-dangers/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/frontend/" rel="tag">frontend</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/programming/" rel="tag">programming</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2021-10-04T11:20:49.000Z" itemprop="datePublished">2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/09/27/usestate-tricks/"><div class="post-siblings__direction">Older</div><span class="link__text">7 things you may not know about useState</span> </a><a class="link--bare" href="/2021/10/06/babel-runtime-version/"><div class="post-siblings__direction">Newer</div><span class="link__text">Is your babel's transform-runtime getting lazy? You better check.</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-7bc8702b14501402f6b7d1cf149776a9.js"></script>