<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2021/10/13/really-declarative/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="Like many of you, I’ve read Dan Abramov’s excellent article, making setInterval declarative with React hooks. It’s a great introduction to hook thinking and gotchas, highly recommended to any react de"><meta property="og:type" content="article"><meta property="og:title" content="Thanks React, I&#39;m fine with an imperative setInterval"><meta property="og:url" content="https://thoughtspile.github.io/2021/10/13/really-declarative/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="Like many of you, I’ve read Dan Abramov’s excellent article, making setInterval declarative with React hooks. It’s a great introduction to hook thinking and gotchas, highly recommended to any react de"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/set-timeout.jpg"><meta property="article:published_time" content="2021-10-13T17:55:24.000Z"><meta property="article:modified_time" content="2022-01-14T13:29:55.464Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="javascript"><meta property="article:tag" content="frontend"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://thoughtspile.github.io/images/set-timeout.jpg"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>Thanks React, I&#39;m fine with an imperative setInterval</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://thoughtspile.github.io/2021/10/13/really-declarative/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Thanks React, I&#39;m fine with an imperative setInterval</h1></header><div class="content" itemprop="articleBody"><p>Like many of you, I’ve read Dan Abramov’s excellent article, <a target="_blank" rel="noopener" href="https://overreacted.io/making-setinterval-declarative-with-react-hooks">making setInterval declarative with React hooks.</a> It’s a great introduction to hook thinking and gotchas, highly recommended to any react dev. But by now the insistence on being declarative in every hook ever has gone too far, and it’s starting to annoy me. Hook libraries that don’t expose imperative handles at all are less useful, and using them comes with a real performance cost. How so? Let me show.</p><p><img src="/images/set-timeout-c7591d6eeb1a34c3af7cc6bac2fe5871.jpg"></p><h2 id="The-example"><a href="#The-example" class="headerlink" title="The example"></a>The example</h2><p>Let’s jump straight into the code. I’m building a synthetic input with a nice “info” icon that explains what this input is for when the user hovers it. To prevent any jumpiness when the user just moves the mouse around, I open the tooltip after 100ms of hovering:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">&#123; details &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showDetails, setShowDetails] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [isHovered, setHovered] = useState(<span class="literal">false</span>);</span><br><span class="line">  useTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setShowDetails(<span class="literal">true</span>);</span><br><span class="line">  &#125;, isHovered ? <span class="number">100</span> : <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onEnter = <span class="function">() =&gt;</span> setHovered(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> onLeave = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setHovered(<span class="literal">false</span>);</span><br><span class="line">    setShowDeatils(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onMouseEnter</span>=<span class="string">&#123;onEnter&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onMouseLeave</span>=<span class="string">&#123;onLeave&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &gt;</span>i<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>And here’s the <code>useTimeout</code> hook — I’ll skip the part where Dan explains why this code looks what it looks like, please check out his <a target="_blank" rel="noopener" href="https://overreacted.io/making-setinterval-declarative-with-react-hooks">original post</a> if you have any questions. I only replaced the interval with a timeout, because, to tell you the truth, I have used intervals exactly zero times in the past 5 years, but I use timeouts every week.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useTimeout</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> savedCallback = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the latest callback.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.current = callback;</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the interval.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        savedCallback.current();</span><br><span class="line">      &#125;, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s a nice, consistent hook that does many things right — in fact, it’s similar to my idea of <a href="/2021/04/07/better-usecallback/">the perfect useCallback.</a> Let’s first admire the things it does right:</p><ul><li>You can’t forget to clear the timeout on unmount.</li><li>You never call a stale callback.</li><li>You don’t even have to specify callback “dependencies”</li></ul><p>But then there’s something I don’t like that much. To set a callback, we switch the <code>hovered</code> state. This state change triggers the effect in <code>useTimeout</code> that actually sets the timeout. <em>But,</em> like every state change, it also happens to re-render a component. So, while we’re calling our <code>setTimeout</code>, we also get to:</p><ol><li>Call setState</li><li>Schedule a re-render</li><li>Call the render function</li><li>Produce a bunch of objects and functions for our hooks</li><li>Compare some dependency arrays</li><li>Note that <code>hovered</code> has changed, and schedule that effect from <code>useTimeout</code></li><li>Generate a bunch of vDOM</li><li>Diff the old and new vDOMs to see that almost nothing happened</li><li>Bind new DOM event handlers, because their reference has changed, who knows</li><li>Finally, <code>setTimeout</code>!</li></ol><p>I mean, it will all probably happen pretty fast, but come on, is calling a <code>setTimeout</code> <em>really</em> worth all that fuss? Me, I don’t think so. The idea of making my user’s CPU go through all that hoops to call a function makes me very sad. Luckily, I know how to fix it.</p><h2 id="Give-me-back-my-imperative"><a href="#Give-me-back-my-imperative" class="headerlink" title="Give me back my imperative"></a>Give me back my imperative</h2><p>What if we were to skip the <em>declarative</em> part, and just tried to build a consistent hook wrapper around <code>setTimeout</code>? Here’s my take (we use a <a target="_blank" rel="noopener" href="https://github.com/VKCOM/VKUI/blob/288114403c892ae11e60fe65525cdef89a272c53/src/hooks/useTimeout.ts">very similar hook</a> in our production code):</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useImperativeTimeout</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeoutId = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> savedCallback = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the latest callback.</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.current = callback;</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this handle clears the timeout</span></span><br><span class="line">  <span class="keyword">const</span> clear = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId.current);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">// this handle sets our timeout</span></span><br><span class="line">  <span class="keyword">const</span> set = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// but clears the old one first</span></span><br><span class="line">    clear();</span><br><span class="line">    timeoutId.current = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      savedCallback.current();</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// also, clear the timeout on unmount</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> clear, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; set, clear &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can finally call <code>timeout.set()</code> and just have it <code>setTimeout</code> for us and do nothing else. I’ve left the original <code>savedCallback</code> logic intact, nothing wrong with it.</p><blockquote><p>The hook behavior in some corner cases has changed. If I set the timeout to 300ms, and then 200ms later change the delay to 50ms, should it fire in 300 – 200 = 100ms, as originally intended (my behavior)? 50ms from now (Dan’s behavior)? 50 – 200 = 150ms ago (haha, that’s very correct but you can’t do that)? RIGHT NOW if we’re already past deadline? Who knows. All options are fine for such a weird case as long as it doesn’t explode.</p></blockquote><p>But now our <code>Input</code> has to wrangle with the nasty <em>imperatives,</em> and it probably looks awful. Not at all:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">&#123; details &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showDetails, setShowDetails] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> showTimeout = useImperativeTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setShowDetails(<span class="literal">true</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> onEnter = showTimeout.set;</span><br><span class="line">  <span class="keyword">const</span> onLeave = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    showTimeout.clear();</span><br><span class="line">    setShowDeatils(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onMouseEnter</span>=<span class="string">&#123;onEnter&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onMouseLeave</span>=<span class="string">&#123;onLeave&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &gt;</span>i<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In fact, we’ve not only eliminated the extra render, but also removed the <code>hovered</code> state whose only job was to toggle the timeout. I’d say good old imperatives just scored a goal.</p><h2 id="Were-we-imperative-all-along"><a href="#Were-we-imperative-all-along" class="headerlink" title="Were we imperative all along?"></a>Were we imperative all along?</h2><p>Upon closer inspection, our initial <em>“declarative”</em> <code>useTimeout</code> is not that declarative. Take note:</p><ul><li><code>onMouseOver</code> event handler is imperative,</li><li><code>setHovered</code> is imperative — even grammatically, I sometimes say “come on React, <em>set hovered</em> to true”,</li><li><code>setTimeout</code> is imperative, too.</li></ul><p>We’re basically converting these imperative things into the declarative world, then back again.</p><p>Moreover, the mental model is slightly broken — while <code>hovered</code> flag supposedly means “timeout is running”, it may not be the case. The timeout is either running or has already fired. But maybe that’s just me being tedious.</p><h2 id="What-declarative-can’t-do"><a href="#What-declarative-can’t-do" class="headerlink" title="What declarative can’t do"></a>What declarative can’t do</h2><p>Now suppose I want to implement a debounce with the <em>declarative useTimeout.</em> I want to track my user’s mouse motion, and show a popup once he stops moving. For that, I normally set a small timeout to show the popup — 30ms will do — on <code>mousemove</code>. If the user moves the mouse again within the next 30ms, well, I set another timeout and try again. If the mouse stops, the timeout successfully fires, and the popup appears. Really simple (no React yet):</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> popupTimeout = <span class="literal">null</span>;</span><br><span class="line">img.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(popupTimeout);</span><br><span class="line">  popupTimeout = <span class="built_in">setTimeout</span>(showPopup, <span class="number">30</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>But the only way to set our <em>decalrative useTimeout</em> is passing a non-null delay. How would you do this with our declarative timeout?</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Img</span>(<span class="params">&#123; title, ...props &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [hasPopup, setPopup] = useState(<span class="literal">false</span>);</span><br><span class="line">  useTimeout(<span class="function">() =&gt;</span> setPopup(<span class="literal">true</span>), ??);</span><br><span class="line">  <span class="keyword">const</span> onMove = ??</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">onMouseMove</span>=<span class="string">&#123;onMove&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;hasPopup &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You could move the delay a little bit, like 30 -&gt; 31 -&gt; 30, or dance around with 30 -&gt; null -&gt; 30, but that’s just dirty. In any case, <code>mousemove</code> is absolutely not the event you’d want to re-render on.</p><p>Imperative timeout to the rescue:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Img</span>(<span class="params">&#123; title, ...props &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [hasPopup, setPopup] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> popupTimeout = useImperativeTimeout(</span><br><span class="line">    <span class="function">() =&gt;</span> setPopup(<span class="literal">true</span>),</span><br><span class="line">    <span class="number">30</span>);</span><br><span class="line">  <span class="keyword">const</span> onMove = popupTimeout.set;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">onMouseMove</span>=<span class="string">&#123;onMove&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;hasPopup &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It works, it’s fast, it’s simple. 2:0 in favor of old school!</p><h2 id="How-we-can-have-it-all"><a href="#How-we-can-have-it-all" class="headerlink" title="How we can have it all"></a>How we can have it all</h2><p>Before you point this out to me, I’d love to quote the original article’s disclaimer myself: <em>This post focuses on a pathological case. Even if an API simplifies a hundred use cases, the discussion will always focus on the one that got harder.</em> I’ll be the first to admit I’m now exploring a pathological case of a pathological case. Know why? Because that’s the kind of stuff I enjoy.</p><p>Problem is, the fully declarative API most hooks offer is on a higher level of abstraction than imperative handles. JS culture of making lower-lever building blocks inaccessible to the library users has bothered me for a long time (ouch, I still remember that time I copy-pasted react-router source to modify link actions for an electron app). But I think this culture has probably peaked in hooks.</p><p>Declarative timeout is very convenient in many cases:</p><ul><li>If many different things can set a timeout — like maybe a <code>mousedown</code>, but also a <code>keydown</code> — separating cause and effect with an intermediate state works great.</li><li>If you’re going to use the state for other things, you still need to re-render, so there’s no <em>wasted</em> render.</li></ul><p>But, as we’ve seen, it makes some other cases impossibly difficult, and can introduce wasted renders.</p><p>What if we could have the best of both worlds — provide a nice declarative API for 90% use cases, and also an imperative one to please old grumpy people like me? Yes we can:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWrapTimeout</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handle = useImperativeTimeout(callback, delay);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="literal">null</span>) &#123;</span><br><span class="line">      handle.set();</span><br><span class="line">      <span class="keyword">return</span> handle.clear;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is what you think it is — the declarative timeout, built on top of our imperative timeout. Works absolutely the same. We could even expose <em>both</em> APIs from a single hook (just <code>return handle</code>), but the interaction between the declarative state and imperative overrides is not pleasant. On the other hand, declarative timeout can’t be used to build an imperative timeout, period.</p><hr><p>A traditional recap:</p><ul><li>Hooks without an imperative API make re-rendering the only way to communicate with the hook, which is wasteful.</li><li>Re-rendering a component and checking if some variable has changed since last render <em>is</em> a convoluted way to call a function.</li><li>Communicating between imperative actions (event -&gt; setTimeout call) through a declarative value is not always possible.</li><li>Imperative APIs can be harder to work with, but are also more flexible.</li><li>You can build declarative APIs on top of imperative ones, but not the other way around.</li></ul><p>Dear library authors, please do expose lower-level APIs. Don’t make me copy-paste your code to do things a little differently from the 95% use case.</p><p>Want to learn more about pathological cases in React hooks? <a href="/tags/hooks/">I have a lot of that.</a> See you around!</p></div><span class="share"><div><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://thoughtspile.github.io/2021/10/13/really-declarative/&text=Thanks React, I&#39;m fine with an imperative setInterval by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://thoughtspile.github.io/2021/10/13/really-declarative/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/frontend/" rel="tag">frontend</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/javascript/" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2021-10-13T17:55:24.000Z" itemprop="datePublished">2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/10/11/usestate-object-vs-multiple/"><div class="post-siblings__direction">Older</div><span class="link__text">Are many useStates better than useState(object)?</span> </a><a class="link--bare" href="/2021/10/18/non-react-state/"><div class="post-siblings__direction">Newer</div><span class="link__text">How to replace useState with useRef and be a winner</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-7bc8702b14501402f6b7d1cf149776a9.js"></script>