<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2021/05/17/everything-about-react-refs/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="React refs appear to be a very simple feature. You pass a special prop to a DOM component, and you can access the current DOM node for that component in your JS. This is one of those great APIs that w"><meta property="og:type" content="article"><meta property="og:title" content="So you think you know everything about React refs"><meta property="og:url" content="https://thoughtspile.github.io/2021/05/17/everything-about-react-refs/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="React refs appear to be a very simple feature. You pass a special prop to a DOM component, and you can access the current DOM node for that component in your JS. This is one of those great APIs that w"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/react-ref-order.png"><meta property="article:published_time" content="2021-05-17T18:10:17.000Z"><meta property="article:modified_time" content="2022-01-14T13:29:55.460Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="programming"><meta property="article:tag" content="frontend"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://thoughtspile.github.io/images/react-ref-order.png"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>So you think you know everything about React refs</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://thoughtspile.github.io/2021/05/17/everything-about-react-refs/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">So you think you know everything about React refs</h1></header><div class="content" itemprop="articleBody"><p>React <a target="_blank" rel="noopener" href="https://reactjs.org/docs/refs-and-the-dom.html">refs</a> appear to be a very simple feature. You pass a special prop to a DOM component, and you can access <em>the current DOM node</em> for that component in your JS. This is one of those great APIs that work just the way you’d expect, so you don’t even think about how, exactly, it happens. Along my descent into React internals I started noticing that there was more to the ref API than I always thought. I dug deeper, and in this post I’ll share my findings with you and provide a few neat ref tricks to help you write better code.</p><h2 id="How-react-refs-are-set"><a href="#How-react-refs-are-set" class="headerlink" title="How react refs are set"></a>How react refs are set</h2><p>To get the basics out of the way, <code>ref</code> is set to the DOM node when it’s mounted, and set to null when the DOM node is removed. No surprises this far.</p><p>One thing to note here is that a ref is, strictly speaking, never <em>updated.</em> If a DOM node is replaced by some other node (say, its DOM tag or <code>key</code> changes), the ref is <em>unset,</em> and then set to a new node. (You may think I’m being picky here, but it’s goint to prove useful in a minute.) The following code would log <code>null -&gt; &lt;div&gt;</code> on rerender (also see <a target="_blank" href="https://codesandbox.io/s/stoic-tereshkova-h51o2?file=/src/App.js">sandbox</a>):</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = useCallback(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;ref&quot;</span>, e), []);</span><br><span class="line"><span class="keyword">const</span> [iter, rerender] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">key</span>=<span class="string">&#123;iter&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> rerender(iter + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">    click to remount</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>The part I was not aware of is that the identity of <code>ref</code> prop also forces it to update. When a <code>ref</code> prop is added, it’s set to DOM node. When a <code>ref</code> prop is removed, the old ref is set to null. Here, again, the ref is unset, than set again. This means that if you pass an inline arrow as a <code>ref</code>, it’ll go through <em>unset / set</em> cycle on every render (<a target="_blank" rel="noopener" href="https://codesandbox.io/s/reverent-stallman-swv7q?file=/src/App.js">sandbox</a>):</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rerender = useState()[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(e)</span> =&gt;</span> console.log(&quot;ref&quot;, e)&#125; onClick=&#123;() =&gt; rerender(&#123;&#125;)&#125;&gt;</span></span><br><span class="line"><span class="xml">    click to remount</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>So, why does it work that way? In short, it allows you to attach <code>refs</code> conditionally and even swap them between components, as in</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123;items.map(<span class="function">(<span class="params">e, i</span>) =&gt;</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;i</span> === <span class="string">items.length</span> <span class="attr">-</span> <span class="attr">1</span> ? <span class="attr">lastRef</span> <span class="attr">:</span> <span class="attr">null</span>&#125;&gt;</span>&#123;e.text&#125;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  ))&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>So far we’ve leant that refs are <em>set</em> node when the DOM mounts <em>or</em> when the ref prop is added, and <em>unset</em> when the DOM unmounts <em>or</em> the ref prop is removed. As far as I’m concerned, nothing else causes a ref to update. A changing ref always goes through <code>null</code>. If you’re fluent in hooks, it works as if the code for DOM components had:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.current = domNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> ref.current = <span class="literal">null</span>;</span><br><span class="line">&#125;, [ref]);</span><br></pre></td></tr></table></figure><h2 id="Ref-update-ordering"><a href="#Ref-update-ordering" class="headerlink" title="Ref update ordering"></a>Ref update ordering</h2><p>Another important principle specifies the order in which refs are set and unset. The part we rely on the most is that the ref is always set <em>before</em> <code>useLayoutEffect / componentDidMount / Update</code> for the corresponing DOM update is called. This, in turn, means that <code>useEffect</code> and parent <code>useLayoutEffect</code> are also called after the ref is set.</p><p>In a single render, all the ref <em>unsets</em> happen before any <em>set</em> — otherwise, you’d get a chance to unset a ref that’s already been set during this render.</p><p>Next, <code>useLayoutEffect</code> cleanup during re-rendering runs right between ref unset and set, meaning that <code>ref.current</code> is always <code>null</code> there. To be honest, I’m not sure why it works this way, as it’s a prime way to shoot yourself in the foot, but this seems to be the case for all react versions with hooks. <a target="_blank" rel="noopener" href="https://codesandbox.io/s/polished-sunset-fbs6q?file=/src/App.js">See for yourself</a>.</p><p>In contrast, <code>componentWillUnmount</code> and unmount <code>useLayoutEffect()</code> cleanup are called <em>before</em> the ref is unset, so that you get a chance to cleanup anything you’ve attached to the DOM node, as you can see in a <a target="_blank" rel="noopener" href="https://codesandbox.io/s/determined-hamilton-05t27?file=/src/App.js">sandbox</a>.</p><p>Here’s a chart that summarizes all this timing:</p><p><img src="/images/react-ref-order-f455246e4b65dcd8bad4434384f2460e.png"></p><p>Now I feel like we’re getting somewhere in our understanding of <code>refs</code> — but does it have any practical value? Read on!</p><h2 id="Don’t-use-ref-current-in-useLayoutEffect-cleanup"><a href="#Don’t-use-ref-current-in-useLayoutEffect-cleanup" class="headerlink" title="Don’t use ref.current in useLayoutEffect cleanup"></a>Don’t use ref.current in useLayoutEffect cleanup</h2><p>First off — using dynamic refs in <code>useLayoutEffect</code> cleanup callback is unsafe since you can get an unexpected <code>null</code>. Store <code>ref.current</code> in a closure variable and use that instead:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ref.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> ref.current.removeEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span><br><span class="line">&#125;. [onClick]);</span><br><span class="line"><span class="comment">// becomes...</span></span><br><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = ref.current</span><br><span class="line">  node.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> node.removeEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span><br><span class="line">&#125;. [onClick]);</span><br></pre></td></tr></table></figure><p>Granted, this only works for arrow refs or when you attach a ref conditionaly, but better safe than sorry, right? At least it’s good to know exactly why this breaks and not wrap everything in <code>if (ref.current)</code> just in case.</p><h2 id="You-can-side-effect-in-ref-callback"><a href="#You-can-side-effect-in-ref-callback" class="headerlink" title="You can side effect in ref callback"></a>You can side effect in ref callback</h2><p>A cool and useful implication of this is that you can safely put expensive side effects in a callback ref (or a <code>set current()</code> of a ref object) as long as ref identity does not change. For example, a typical DOM measuring logic:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = useRef();</span><br><span class="line"><span class="keyword">const</span> [size, setSize] = useState();</span><br><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setSize(el.current.getBoundingClientRect());</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;el&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>Becomes…</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [size, setSize] = useState();</span><br><span class="line"><span class="keyword">const</span> measureRef = useCallback(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    setSize(node.getBoundingClientRect())</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;measureRef&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>Which is slightly cleaner and has one variable less.</p><h2 id="Ref-arrows"><a href="#Ref-arrows" class="headerlink" title="Ref arrows"></a>Ref arrows</h2><p>There’s a subtle difference between having an arrow as your <code>ref</code> prop and a ref object or a stable callback — the arrow has a new identity on every render, forcing the ref to go through an update cycle <code>null</code>. This is normally not too bad, but good to know.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this does node -&gt; null -&gt; node on every render</span></span><br><span class="line">&lt;div ref=&#123;<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.node = e&#125; /&gt;</span><br><span class="line"><span class="comment">// this doesn&#x27;t</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;useCallback(e</span> =&gt;</span> this.node = e, [])&#125; /&gt;</span></span><br><span class="line"><span class="comment">// neither does this</span></span><br><span class="line">setRef = <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.node = e;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.setRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// this is fine, too</span></span><br><span class="line"><span class="keyword">const</span> ref = useRef();</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="setState-can-be-a-callback-ref"><a href="#setState-can-be-a-callback-ref" class="headerlink" title="setState can be a callback ref"></a>setState can be a callback ref</h2><p>If you want setting ref to trigger a rerender, you can just pass <code>setState</code> updater as a ref prop. This code will give <code>children</code> access to root DOM node, and will not fall into infinite re-rendering or anything:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [root, setRoot] = useState();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;setRoot&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">RootContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;useMemo(()</span> =&gt;</span> root, [root]))&#125;&gt;</span></span><br><span class="line"><span class="xml">            &#123;root ? children : null&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RootContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Merging-refs-is-hard"><a href="#Merging-refs-is-hard" class="headerlink" title="Merging refs is hard"></a>Merging refs is hard</h2><p>Finally, if you implement some kind of ref merging (when you have a <code>forwardRef</code> / <code>innerRef</code>, but also need te DOM node for yourself), you should take care to preserve the guarantees native ref provides, because they are there for a reason. Almost all ref merging mechanisms I’ve seen in the wild miss some points we’ve discussed today. The web is full of tutorials that offer you subtly broken solutions. A library with 22K stars <a target="_blank" rel="noopener" href="https://github.com/streamich/react-use/blob/master/src/useEnsuredForwardedRef.ts">fails to do it right.</a> Here’s <a target="_blank" rel="noopener" href="https://github.com/VKCOM/VKUI/blob/master/src/hooks/useExternRef.ts">my best shot</a> at this problem, and I’m still not sure it ticks all the boxes:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useExternRef</span>(<span class="params">externRef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stableRef = useRef();</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">current</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> stableRef.current;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">current</span>(<span class="params">el</span>) &#123;</span><br><span class="line">      stableRef.current = el;</span><br><span class="line">      setRef(el, externRef);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;), [externRef]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Knowing this, I wouldn’t be comfortable with any advanced ref patterns (conditional refs / side effects) on non-DOM components.</p><hr><p>Now on to a brief recap:</p><ul><li>Refs are set when the DOM is mounted or a <code>ref</code> prop is added.</li><li>Refs are unset when the DOM is removed or a <code>ref</code> prop is removed.</li><li>Refs are always unset, then set, and never switch between two nodes directly.</li><li>It’s safe to use <code>refs</code> conditionaly and even move them between nodes.</li><li>The order in which refs are set and unset relative to <code>useLayoutEffect</code> and lifecycle hooks is well defined.</li><li>Callback ref can be a side effect or a <code>useState</code> setter</li><li>Useing <code>ref.current</code> in <code>useLayoutEffect</code> cleanup is unsafe.</li><li>Merging refs is hard, so take care yourself and don’t trust the <code>ref</code> prop in components you didn’t write.</li></ul><p>Phew. Now I think we really know everything about react refs.</p></div><span class="share"><div><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://thoughtspile.github.io/2021/05/17/everything-about-react-refs/&text=So you think you know everything about React refs by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://thoughtspile.github.io/2021/05/17/everything-about-react-refs/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/frontend/" rel="tag">frontend</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/programming/" rel="tag">programming</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2021-05-17T18:10:17.000Z" itemprop="datePublished">2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/04/07/better-usecallback/"><div class="post-siblings__direction">Older</div><span class="link__text">Did I just build a better useCallback?</span> </a><a class="link--bare" href="/2021/05/31/moar-coverage/"><div class="post-siblings__direction">Newer</div><span class="link__text">How to increase test coverage FAST</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-7bc8702b14501402f6b7d1cf149776a9.js"></script>