<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta property="og:type" content="article"><meta property="og:title" content="The complete guide to safe type narrowing in TypeScript"><meta property="og:url" content="https://blog.thoughtspile.tech/2023/01/31/typescript-safe-narrow/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-narrowing.png"><meta property="article:published_time" content="2023-01-31T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="typescript"><meta property="article:tag" content="javascript"><meta property="article:tag" content="programming"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/ts-narrowing.png"><title>The complete guide to safe type narrowing in TypeScript</title><link rel="stylesheet" href="/css/style.css"><link rel="canonical" href="https://blog.thoughtspile.tech/2023/01/31/typescript-safe-narrow/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">The complete guide to safe type narrowing in TypeScript</h1></header><div class="content" itemprop="articleBody"><p>Say I'm building a TODO app with two tabs: done and pending tasks. To make the app routable, I put the active tab into the <code>?tab</code> query parameter, so that <code>mytodo.io?tab=done</code> takes me directly to the done tasks. I implement routing like this (pardon my hand-coded querystring parser):</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> tasks <span class="token operator">=</span> <span class="token punctuation">{</span><br>  done<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  pending<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> tab <span class="token operator">=</span> location<span class="token punctuation">.</span>search<br>  <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f <span class="token operator">=></span> f<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>p <span class="token operator">=></span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'tab'</span><span class="token punctuation">)</span><span class="token operator">?.</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> items <span class="token operator">=</span> tasks<span class="token punctuation">[</span>tab<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>And stupid TS complains: <code>type X can't be used to index type { done: ...; pending: ...; }</code>. I put the active tab into the URL myself, what do you want from me? Time to meet my little friend, <code>tasks[tab as keyof typeof tasks]</code>.</p><p>But wait, TS has a point. No matter what you <em>expect</em> the URL to be, the user might manually put anything into the <code>?tab</code> parameter, or remove it altogether, purposefully or by accident. The TS-detected type <code>string | undefined</code> is 100% correct, and bypassing TS checks with <code>as</code> opens my app to a variety of bugs caused by missing <code>items</code>.</p><p>Since the bug happens in the &quot;real world&quot; of JS, as opposed to the &quot;type-only world&quot; of TS, we need some real-life checks to make the code safe:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> items <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">===</span> <span class="token string">'done'</span> <span class="token operator">||</span> tab <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <br>  <span class="token operator">?</span> tasks<span class="token punctuation">[</span>tab<span class="token punctuation">]</span> <br>  <span class="token operator">:</span> tasks<span class="token punctuation">.</span>pending<span class="token punctuation">;</span></code></pre><p>From TS point of view our condition is a &quot;type narrowing&quot; expression: in general, <code>tab</code> is of type <code>string | undefined</code>, but the condition only evaluates to true for <code>tab</code> of type <code>'done' | 'pending'</code>, and <em>that</em> can be safely used to index <code>tasks</code> object.</p><p>Type narrowing is useful when your program gets values from the outer world: reading <code>localStorage</code>, (or, in general, JSON-parsing strings), parsing URLs, or reading raw user input. You can also accept wider types as an API design choice to let users call <code>mount('#mount')</code> in addition to <code>mount(document.querySelector('#mount'))</code>.</p><p>In this article, we cover several techniques to safely narrow variable types in TS:</p><ul><li>Using native JS operators, such as <code>typeof</code>, <code>===</code> and more.</li><li>Detecting types inside custom functions, known as type guards. These are useful, but, surprisingly, <em>not typesafe.</em></li><li>Writing &quot;downcast functions&quot; that accept a wide-typed argument, but only return a narrow type, as in <code>(x: unknown) =&gt; number</code>. We discuss four ways to make that happen.</li></ul><p>Let's get started!</p><h2>Type guards and control-flow analysis</h2><p>JS has many tools to check the runtime type of a variable. TS is smart enough to see that some areas of code are only reachable for certain values of the variable, and narrow types there accordingly â€” this is known as control-flow analysis, or CFA. Here's a non-exhaustive list of things that natively narrow types in a JS / TS program:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> Date<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// typeof is an old favorite</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> res<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// equality operator is useful for casting to union / literal types</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token string">'de'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> country<span class="token operator">:</span> <span class="token string">'de'</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// Date object can't be falsy</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> res<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// instanceof, typeof's object-oriented brother</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> day <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// finally, 'in' can be used as a duck-type detector:</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token string">'getDate'</span> <span class="token keyword">in</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> day <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Some narrowing operators (<code>typeof</code>, <code>instanceof</code>) actually access variable types, while the <code>in</code> operator implements a <a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">duck-typing</a> check â€” we assume the type of a variable by looking at its property (<em>if it has a peak, it's a duck</em>). Similarly, we can narrow types of tagged unions based on the <em>tag.</em> For example, <code>Transaction</code> type contains amount in either <code>debit</code> or <code>credit</code> field, but we can alway tell wich one it is by lookig at <code>direction</code>:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name">Transaction</span> <span class="token operator">=</span> <br>  <span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token string">'incoming'</span><span class="token punctuation">,</span> debit<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span> <span class="token operator">|</span><br>  <span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token string">'outgoing'</span><span class="token punctuation">,</span> credit<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">amount</span><span class="token punctuation">(</span>t<span class="token operator">:</span> Transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> t<span class="token punctuation">.</span>direction <span class="token operator">===</span> <span class="token string">'incoming'</span> <span class="token operator">?</span> t<span class="token punctuation">.</span>debit <span class="token operator">:</span> t<span class="token punctuation">.</span>credit<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This function can also be implemented using an <code>in</code> operator, because the mere <em>presence</em> of debit / credit field tells us which kind of transaction we're looking at: <code>'debit' in t ? t.debit : t.credit</code>;</p><p>CFA is not limited to <code>if</code> blocks â€” it also works for early return / throw, ternaries, <code>&amp;&amp;</code> chains, and so on:</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// these all work</span><br><span class="token keyword">function</span> <span class="token function">getString</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">?</span> arg <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> arg <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">;</span><br>  <br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">!==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> arg<span class="token punctuation">;</span><br><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">!==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'arg is not string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> arg<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>TS tries its best to narrow types in more complex situations than just a direct condition. For example, since TS 4.4 you can <a href="https://www.typescriptlang.org/play?ts=4.4.2&amp;ssl=4&amp;ssc=1&amp;pln=5&amp;pc=1#code/PTAEGEHsDsBcCdIBtQDEmQO6gILQIZICeAzgJYmgWiwAWApqAQLaMBmk8NDoJps9ZqEy0yAY1oBYAFAgm+eIkyU6jAA6QBcMoRpE19SvmhUAJvW1sy9LmOOgARowf4S9UzLkxujMZHO8kKwwjLSuwogCADSgRJAArqB2JgDm9LCg9pAAbjbZ1pieYGQm9AAe+MxqSPQAXLD69AC0mGTm0CUpTcamTQSKWJ0yRaAASgkptMQxUHCIKOhYuATE5JQ1sJRxiZjwZAJJ-oxIZADW9COqoBxIGK3QKbXD0uZiSAq+MCQZ8W7wAJLQNTxWC1XgITqgAA+THizCc8AA3DIyGxQAAKBoGSBo342QHAjIAXhJoAARN89g8yQBKUAAbxkoFAeIBQJBiNAckpQ2kAF9QPQkG4GUyWX8CRyuWBoHCETI+c85IDuNQ7G4Ymo9pwaJBQAAVRoAZTEezUGQALAA6C0xPwBNh3TIrUgUEaYBJIUygGDERyMfBqarWb2wPVXe2MErkAJXVHg-ACVhwK0jfWiSisYwZOiJzKgXLwIi8MhVGqgeD0Nj4MRhrgnc4+a7IO6dJ7SGR+aDfKgkI0Qh6gIl6bG4iXs4mkikDlJk5Ed2RgADqnu9YVyoAA+tBNJvQGFvV2EMhrk7jIRXUYgyd3O2UWj0RR+1SUnTGdJmazJbBOdyZ9DYXhGwqBMa0AGYFUFYVGHfT9x0JX8wB5QcYVlICuBKUBwIVJUwBVQ0DBNM1LRtUAmibQtyG8bYAHJKySeJFAsWA-RgGIIxgY8UEdLARnPVY1XsMJoFMcs6GoEhOAyHFDnMK0DQzYROFOSgRAsA1jVNMhzRGZJQGYfBG0rVwYHwBxy1cEg4XNMgvm4PMrmyBQdHM0JXGgGiMgkYw0m9choDEC5FyoDJMHCU16ETdx5NQHVykqap6BifBQAAAw2VKlPiL0mE0f1Mlc3V8rxDxgsw-jLzvaQNl7Z9OgAJiHEd6Bkr8JyHKdkNned40fPsZ3qt8xTahDpXBF8ALQhEQKwm1IKFEVYPFfEJ0Q8bIVQuVgMw60LRwhc5Firg2GylBzFgfAyGFXh6DqEZaFgWA1BIWoQBSfZaHiBwrT8ZhgGYcREEkthYGAAj6CI7TQeBW5gAtC0AHYwIABiAA" target="_blank" rel="noopener">put the narrowing condition into a variable:</a></p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> isNumber <span class="token operator">=</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> isNumber <span class="token operator">?</span> x <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>However, a bunch of operations that should, in theory, narrow the types, have no effect on TS:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> mixed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> nums<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> mixed<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> countries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'de'</span><span class="token punctuation">,</span> <span class="token string">'us'</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">'de'</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> country<span class="token operator">:</span> <span class="token string">'de'</span> <span class="token operator">|</span> <span class="token string">'us'</span> <span class="token operator">=</span> countries<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">?</span> str <span class="token operator">:</span> <span class="token string">'de'</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> nums2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> mixed<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token operator">?</span> mixed <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Which brings us to user-defined type guards.</p><h3>Type guard functions</h3><p>TS lets you mark a function as a type narrowing condition by making it a <em>user-defined type guard</em> â€” just put <code>arg is SomeType</code> into the return type:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isDate</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> arg <span class="token keyword">is</span> Date <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> arg <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>However, as of TS 4.9, a function is never <em>inferred</em> to be a type guard based on its contents â€” you just get a normal <code>(arg: Something) =&gt; boolean</code> type. This lack of automatic guard inference is exactly why <code>filter</code> and <code>every</code> failed to narrow the array types. Adding an explicit type guard signature fixes it:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> mixed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> isNumber <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token operator">=></span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">;</span><br><br><span class="token keyword">const</span> nums<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> mixed<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isNumber<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> nums2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> mixed<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>isNumber<span class="token punctuation">)</span> <span class="token operator">?</span> mixed <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Another weak point of TS guard functions is that they are <em>not typesafe.</em> The guard function might contain most absurd and outrageous checks, and TS will be OK with that:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> object <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0.5</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h3>Switching over variable type</h3><p>Regardless of the flavor, type guards let us safely do different things based on a runtime variable type â€” ideally, covering all the possible cases. For example, let's extract a DOM node from a parameter that can be either a selector or a DOM node:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span>where<span class="token operator">:</span> Element <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Element<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> where <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token keyword">instanceof</span> <span class="token class-name">Element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">render</span><span class="token punctuation">(</span>where<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token comment">// by exclusion, "where" is a string selector here</span><br>    document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>where<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>render<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>This is very handy!</p><h2>Downcast functions</h2><p>Wouldn't it be nice if, instead of writing typechecks over and over, you just had a function that takes a wide-typed variable and <em>magically</em> returns a narrow type? Let's call these nice things &quot;downcast functions&quot; (<a href="https://twitter.com/lexi_lambda" target="_blank" rel="noopener">Alexis King</a> calls them &quot;parsers&quot; in the article I got the idea from â€” <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" target="_blank" rel="noopener">&quot;Parse, don't validate&quot;</a>, but <em>parsing</em> feels too strongly associated with de-serializing in JS, hence the name change). An example would be:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">toNumber</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><span class="token operator">??</span><span class="token operator">?</span><span class="token punctuation">}</span></code></pre><p>Unlike user-defined type guards, this function is fully type-checked by TS. Using it is a pleasure:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> threads<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">number</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">THREADS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">number</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The only remaining question is how to actually implement downcast functions. When the input type matches the output type, this is trivial:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">toNumber</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arg<span class="token punctuation">;</span><br>  <span class="token comment">// ???</span><br><span class="token punctuation">}</span></code></pre><p>However, when the input doesn't cleanly fit the output type, we must do something else. There are four viable options (and an extra funny one).</p><h3>Convert</h3><p>Certain input values can be converted to the output type in a logical way. For example, let's convert numeric strings to <code>number</code>:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">toNumber</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> fallback<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arg<span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>If you manage to convert all the possible input values to output type â€” good for you! In most cases, though, some values don't have a sensible conversion â€” what's the <code>number</code> for an arbitrary object? So, we're back to the initial question of what to do with the remaining values.</p><h3>Fallback</h3><p>The simple way out is returning some &quot;fallback&quot; value. For <code>number</code>, a natural choice is <code>NaN</code>:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">toNumber</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arg<span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token number">NaN</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>In some cases, a more useful default exists. When reading the &quot;number of times the user viewed a banner&quot; from <code>localStorage</code>, you might default to <code>0</code> for missing or invalid values. You can even accept a default in the argument:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">toNumber</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">,</span> fallback<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> arg <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arg<span class="token punctuation">;</span><br>  <span class="token keyword">return</span> fallback<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Alternatively, you can fall back to <code>null</code>, letting the caller pass the default in <code>??</code> operator:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> offerViewed <span class="token operator">=</span> <span class="token function">toNumber</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><h3>throw</h3><p>Sometimes, there's no sane value to fall back to. True story: we have a REST to GraphQL proxy. GraphQL requests might return <code>null</code> or <code>undefined</code> for missing values, but, since our REST endpoint is obliged to send some value in a 200 response, we used to manually return <code>404 / 5xx</code> responses for nullish values:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">GET</span> <span class="token operator">=</span> <span class="token function">apiHandler</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token punctuation">{</span> user <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"><br>    query UserId {<br>      user {<br>        id<br>      }<br>    }<br>  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> status<span class="token operator">:</span> <span class="token number">404</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> user<span class="token punctuation">.</span>id <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>It was quite inconvenient, since <em>every</em> call site has to worry about the case of missing values. Trust me, this gets out of hand real quick. It's much better to <code>throw</code> on unexpected values, let the caller ignore the case of invalid values altogether, and handle all the errors in one location (here, <code>apiHandler</code>). We greatly simplified our code with this simple non-null downcast:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">exists</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">T</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'MISSING'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token constant">T</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> <span class="token punctuation">{</span> user <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"><br>  query UserId {<br>    user {<br>      id<br>    }<br>  }<br></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token function">exists</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span>id <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>So, if <em>unexpected</em> values are an unrecoverable problem, and you have a single place to safely handle the errors, throwing is a perfectly good idea. Again, check out <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" target="_blank" rel="noopener">&quot;Parse, don't validate&quot;</a> for a more in-depth explanation.</p><h3>exit</h3><p>As an alternative to throwing you can just stop the program with <code>process.exit</code> in node, or terminate browser tab with <code>location.assign</code>. Sounds pretty destructive, but sometimes it's a good way to proceed.</p><p>For CLI programs, it's convenient to <code>exit</code> when a required environment variable is missing. <code>process.exit()</code> returns <code>never</code>, which makes writing this helper a breeze:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">extractEnv</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> value <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span><br>  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">process.env.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is required</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> process<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><h3>loop forever =)</h3><p>As the ultimate way to avoid responsibility, you can spin off a <code>while (true)</code> loop on invalid value and call it a day. After this, the function will never return, so the question &quot;what to return&quot; makes no sense. You probably don't want this in real life, but theoretically this produces a correct program.</p><hr><p>Wrapping up, there's a variety of cases where you need to do different things with a TS value depending on its type. Two main real-life scenarios where this happens:</p><ul><li>Reading data from untrusted external source: user input, localStorage, JSON strings, <code>process.env</code></li><li>Accepting various input types for API convenience: <code>mount('#app')</code> or <code>mount(mountNode)</code></li></ul><p><code>as</code> operator can push values into stricter types, but this causes bugs when your assumptions are broken. Instead, you need runtime checks on the variable to see if it fits your expectations.</p><p>TypeScript uses control-flow analysis to give extra guarantees about a variable (<em>narrow its type</em>) in code areas only accessible behind a runtime check:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">logDay</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Date <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>You can wrap the code to check if the variable is of type <code>T</code> into a <em>user-defined type guard:</em></p><pre class="language-ts"><code class="language-ts"><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Unfortunately, TS will never infer a function as a type guard, and the code that checks the type is not validated.</p><p>A very neat (and type-safe!) alternative to type guards is a <em>downcast function</em> that takes a wide-typed argument and returns a narrow type, e.g. <code>(x: unknown) =&gt; number</code>. When the input doesn't match the output, you have four options:</p><ul><li>Convert the type, e.g. <code>if (typeof x === 'string') return Number(x)</code>. Not all types can be realistically converted to other types.</li><li>Use a fallback value â€” e.g. a <code>0</code>. In particular, <code>null</code> fallback leaves it up to the caller to decide how to proceed.</li><li><code>throw</code>, letting the caller choose between handling the error itself <em>or</em> ignoring it and leaving the handling to some higher-level wrapper.</li><li>stop the program with <code>process.exit()</code> or <code>location.assign</code></li></ul><p>Here are all the options we discussed today, in a cute diagram:</p><p><img src="/images/ts-narrowing.png" alt=""></p></div><span class="share"><div><a href="https://twitter.com/share?url=&text= by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2023/01/31/typescript-safe-narrow/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/typescript" rel="tag">typescript</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a></div><div class="post-actions">Written in <time>2023</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank" rel="noopener">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" href="https://buymeacoffee.com/thoughtspile" target="_blank" rel="noopener">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2023/01/23/typescript-sets/"><div class="post-siblings__direction">Older</div><span class="link__text">Making sense of TypeScript using set theory</span></a></div></article><script async src="/js/share.js"></script></div></body></html><script type="text/javascript">(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-121445688-1', 'auto');
    ga('send', 'pageview');</script>