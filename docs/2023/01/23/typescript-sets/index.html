<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta property="og:type" content="article"><meta property="og:title" content="Making sense of TypeScript using set theory"><meta property="og:url" content="https://blog.thoughtspile.tech/2023/01/23/typescript-sets/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/everything.png"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/apples.png"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/bool.png"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/finites.png"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/primitives.png"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/everything.png"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/all.png"><meta property="article:published_time" content="2023-01-23T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="typescript"><meta property="article:tag" content="javascript"><meta property="article:tag" content="programming"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/ts-sets/everything.png"><title>Making sense of TypeScript using set theory</title><link rel="stylesheet" href="/css/style.css"><link rel="canonical" href="https://blog.thoughtspile.tech/2023/01/23/typescript-sets/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Making sense of TypeScript using set theory</h1></header><div class="content" itemprop="articleBody"><p>I've been working with TypeScript for a long long time. I think I'm not too bad at it. However, to my despair, some low-level behaviors still confuse me:</p><ul><li>Why does <code>0 | 1 extends 0 ? true : false</code> evaluate to <code>false</code>?</li><li>I'm very ashamed, but I sometimes confuse &quot;subtype&quot; and &quot;supertype&quot;. Which is which?</li><li>While we're at it, what are type &quot;narrowing&quot; and &quot;widening&quot;, and how do they relate to sub/supertypes?</li><li>If you want an object that satisfies both <code>{ name: string }</code> and <code>{ age: number }</code>, do you <code>&amp;</code> or <code>|</code>? Both make some sense, since I want a <em>union</em> of the functionality in both interfaces, but I also want the object to satisfy left &amp; (and) right interfaces.</li><li>How is <code>any</code> different from <code>unknown</code>? All I get is imprecise mnemonics like &quot;Avoid Any, Use Unknown&quot;. Why?</li><li>What, exactly, is <code>never</code>? &quot;A value that <em>never</em> happens&quot; is very dramatic, but not too precise.</li><li>Why <code>whatever | never === whatever</code> and <code>whatever &amp; never === never</code>?</li><li>Why on earth is <code>const x: {} = true;</code> valid TS code? <code>true</code> is clearly not an empty object.</li></ul><p>I was doing some research on <code>never</code>, and stumbled upon Zhenghao He's <a href="https://www.zhenghao.io/posts/ts-never" target="_blank" rel="noopener">Complete Guide To TypeScript’s Never Type</a> (check out his blog, it's super cool!). It mentions that a type is just a set of values, and — boom — it clicked. I went back to the basics, re-formulating everything I know about TS into set-theoretic terms. Follow me as I:</p><ul><li>Refresh my knowledge of set theory,</li><li>Map TS concepts to their set counterparts,</li><li>Start simple with booelan, null and undefined types,</li><li>Extend to strings and numbers, finding some types that TS can not express,</li><li>Jump into objects, proving my assumptions about them wrong,</li><li>Finally gain confidence writing <code>extends</code> caluses,</li><li>And put <code>unknown</code> and <code>any</code> where they belong.</li></ul><p>In the end, I solve most of my questions, grow much cozier with TS, and come up with this brilliant map of TS types:</p><p><img src="/images/ts-sets/everything.png" alt=""></p><h2>Set theory</h2><p>First up, a refresher on set theory. Feel free to skip if you're a pro, but my algebra skills are a bit rusty, so I could use a reminder of how it works.</p><p>Sets are unordered collections of objects. In kindergarten terms: say we have two apples aka <em>objects</em> (let's call them ivan and bob, shall we?), and some bags aka <em>sets</em> where we can put the apples. We can make, in total, 4 apple sets:</p><ol><li>A bag with apple ivan, <code>{ ivan }</code> — sets are written as curly brackets with the set items inside.</li><li>Similarly, you can have a bag with apple bob, <code>{ bob }</code>.</li><li>A bag with both apples, <code>{ ivan, bob }</code>. Hold onto your hats, this is called a <em>universe</em> because at the moment there's nothing in our world except these two apples.</li><li>An empty bag aka empty set, <code>{}</code>. This one gets a special symbol, ∅</li></ol><p>Sets are often drawn as &quot;venn diagrams&quot;, with each set represented as a circle:</p><p><img src="/images/ts-sets/apples.png" alt=""></p><p>Apart from listing all the items, we can also build sets by <em>condition.</em> I can say &quot;R is a set of red apples&quot; to mean <code>{ ivan }</code>, considernig ivan is red and bob is green. So far, so good.</p><p>Set A is a <em>subset</em> of set B if every element from A is also in B. In our apple world, <code>{ ivan }</code> is a subset of <code>{ ivan, bob }</code>, but <code>{ bob }</code> is not a subset of <code>{ ivan }</code>. Obviously, any set is a subset of itself, and <code>{}</code> is a subset of any other set S, because not a single item from <code>{}</code> is missing from S.</p><p>There are a few useful operators defined on sets:</p><ul><li>Union <em>C = A ∪ B</em> contains all the elements that are in A or in B. Note that <em>A ∪ ∅ = A</em></li><li>Intersection <em>C = A ∩ B</em> contains all the elements that are in A <em>and</em> B. Note that <em>A ∩ ∅ = ∅</em></li><li>Difference <em>C = A \ B</em> contains all the elements that are in A, but not in B. Note that <em>A \ ∅ = A</em></li></ul><p>This should be enough! Let's see how it all maps to types.</p><h2>What does it have to do with types</h2><p>So, the big reveal: you can think of &quot;types&quot; as sets of JavaScript values. Then:</p><ol><li>Our <em>universe</em> is all the values a JS program can produce.</li><li>A type (not even a typescript type, just a type in general) is some set of JS values.</li><li>Some types can be represented in TS, while other can not — for example, &quot;non-zero numbers&quot;.</li><li><code>A extends B</code> as seen in <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" target="_blank" rel="noopener">conditional types</a> and <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints" target="_blank" rel="noopener">generic constraints</a> can be read as &quot;A is subset of B&quot;.</li><li>Type union, <code>|</code>, and intersection, <code>&amp;</code>, operators are just the union and intersection of two sets.</li><li><code>Exclude&lt;A, B&gt;</code> is as close as TS gets to a difference operator, except it <em>only</em> works when both <code>A</code> and <code>B</code> are union types.</li><li><code>never</code> is an empty set. Proof: <code>A &amp; never = never</code> and <code>A | never = A</code> for any type <code>A</code>, and <code>Exclude&lt;0, 0&gt; = never</code>.</li></ol><p>This change of view already yields some useful insights:</p><ul><li>Subtype of type A is a <em>subset</em> of type A. Supertype is a superset. Easy.</li><li><em>Widening</em> makes a type-set wider by allowing some extra values. <em>Narrowing</em> removes certain values. Makes geometrical sense.</li></ul><p>I know this all sounds like a lot, so let's proceed by example, starting with a simple case of boolean values.</p><h2>Boolean types</h2><p>For now, pretend JS only has boolean values. There are exaclty <em>two</em> — <code>true</code> and <code>false</code>. Recalling the apples, we can make a total of 4 types:</p><ul><li>Literal types <code>true</code> and <code>false</code>, each made up of a single value;</li><li><code>boolean</code>, which is <em>any</em> boolean value;</li><li>The empty set, <code>never</code>.</li></ul><p>The diagram of the &quot;boolean types&quot; is basically the one that we had for apples, just the names swapped:</p><p><img src="/images/ts-sets/bool.png" alt=""></p><p>Let's try moving between type world and set world:</p><ul><li><code>boolean</code> can be written as <code>true | false</code> (in fact, that's exactly how TS impements it).</li><li><code>true</code> is a subset (aka sub-type) of <code>boolean</code></li><li><code>never</code> is an empty set, so <code>never</code> is a sub-set/type of <code>true</code>, <code>false</code>, and <code>boolean</code></li><li><code>&amp;</code> is an <em>intersection,</em> so <code>false &amp; true = never</code>, and <code>boolean &amp; true = (true | false) &amp; true = true</code> (the universe, <code>boolean</code>, doesn't affect intersections), and <code>true &amp; never = never</code>, etc.</li><li><code>|</code> is a <em>union,</em> so <code>true | never = true</code>, and <code>boolean | true = boolean</code> (the universe, <code>boolean</code>, &quot;swallows&quot; other intersection items because they're all subsets of universe).</li><li><code>Exclude</code> correctly computes set difference: <code>Exclude&lt;boolean, true&gt; -&gt; false</code></li></ul><p>Now, a little self-assessment of the tricky <code>extends</code> cases:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">boolean</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">false</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>If you recall that &quot;extends&quot; can be read as &quot;is subset of&quot;, the answer should be clear — A0,B1,C1,C1. We're making progress!</p><p><code>null</code> and <code>undefined</code> are just like <code>boolean</code>, except they only contain <em>one</em> value each. <code>never extends null</code> still holds, <code>null &amp; boolean</code> is <code>never</code> since no JS value can simultaneously be of 2 different JS types, and so on. Let's add these to our &quot;trivial types map&quot;:</p><p><img src="/images/ts-sets/finites.png" alt=""></p><h2>Strings and other primitives</h2><p>With the simple ones out of the way, let's move on to string types. At first, it seems that nothing's changed — <code>string</code> is a type for &quot;all JS strings&quot;, and every string has a corresponding literal type: <code>const str: 'hi' = 'hi';</code> However, there's one key difference — there are <em>infinitely many</em> possible string values.</p><blockquote><p>It might be a lie, because you can only represent so many strings in finite computer memory, but a) it's enough strings to make enumerating them all unpractical, and b) type systems <em>can</em> operate on pure abstrations without worrying about dirty real-life limitations.</p></blockquote><p>Just like sets, string types can be constructed in a few different ways:</p><ul><li><code>|</code> union lets you constuct any <em>finite</em> string set — e.g. <code>type Country = 'de' | 'us';</code>. This won't work for <em>infinite</em> sets — say, all strings with length &gt; 2 — since you can't write an infinite list of value.</li><li>Funky <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" target="_blank" rel="noopener">template literal types</a> let you construct <em>some</em> infinite sets — e.g. <code>type V = `v${string}`;</code> is a set of all strings that start with <code>v</code>.</li></ul><p>We can go a bit further by making unions and intersections of literal and template types. Fun time: when combining a <em>union</em> with a <em>template,</em> TS is smart enough to just filter the literals againts the template, so that <code>'a' | 'b' &amp; `a${string}` = 'a'</code>. Yet, TS is not <em>smart enough</em> to merge templates, so you get really fancy ways of saying <code>never</code>, such as <code>`a${string}` &amp; `b${string}`</code> (obviously, a string can't start with &quot;a&quot; and &quot;b&quot; at the same time).</p><p>However, some string types are <em>not</em> representable in TS at all. Try &quot;every string except 'a'&quot;. You could <code>Exclude&lt;string, 'a'&gt;</code>, but since TS doesn't <em>actually</em> model <code>string</code> as <em>union of all possible string literals,</em> this in fact evaluates back to <code>string</code>. The template grammar can not express this negative condition either. Bad luck!</p><p>The types for numbers, symbols and bigints work the same way, except they don't even get a &quot;template&quot; type, and are limited to finite sets. It's a pity, as I could really use some number subtypes — <em>integer, number between 0 and 1,</em> or <em>positive number.</em> Anyways, all together:</p><p><img src="/images/ts-sets/primitives.png" alt=""></p><p>Phew, we've covered all primitive, <em>non-intersecting</em> JS / TS types. We've gotten comfortable moving between sets and types, and discovered that some types can't be defined in TS. Here comes the tricky part.</p><h2>Interfaces &amp; object types</h2><p>If you think <code>const x: {} = 9;</code> makes no sense, this section is for you. As it appears, our mental model of what TS object types / records / interfaces was built on the wrong assumptions.</p><p>First, you'd probably expect types like <code>type Sum9 = { sum: 9 }</code> to act like &quot;literal types&quot; for objects — matching a single object value <code>{ sum: 9 }</code>, adjusted for referential equality. This is absolutely <em>not</em> how it works. Instead, <code>Sum9</code> is a &quot;<em>thing</em> on which you can access propery <code>sum</code> to get <code>9</code>&quot; — more like a condition / constraint. This lets us call <code>(data: Sum9) =&gt; number</code> with an object <code>obj = { sum: 9, date: '2022-09-13' }</code> without TS complaining about unknown <code>date</code> property. See, handy!</p><p>Then, <code>{}</code> type is not an &quot;empty object&quot; type corresponding to a <code>{}</code> JS literal, but a &quot;thing where I can access properties, but I don't care about any particular properties&quot;. Aha, now we can see what's going on in our initial mind-bender: if <code>x = 9</code>, you can safely <code>x['whatever']</code>, so it satisfies the unconstrained <code>{}</code> interface. In fact, we can even make bolder claims like <code>const x: { toString(): string } = 9;</code>, since we can <code>x.toString()</code> and actuallty get a string. More yet, <code>keyof number</code> gives us <code>&quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; | &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</code>, meaning that TS secretly sees our primitive type as an object, which it is (thanks to <a href="https://javascript.plainenglish.io/javascript-boxing-wrappers-5b5ff9e5f6ab" target="_blank" rel="noopener">autoboxing</a>). <code>null</code> and <code>undefined</code> do not satisfy <code>{}</code>, because they throw if you try to read a property. Not super intuitive, but makes sense now.</p><p>Coming back to my little &quot;<code>|</code> or <code>&amp;</code>&quot; problem, <code>&amp;</code> and <code>|</code> operate on &quot;value sets&quot;, not on &quot;object shapes&quot;, so you need <code>{ name: string } &amp; { age: number }</code> to get objects with <em>both</em> <code>name</code> and (extra hint: and = <code>&amp;</code>) <code>age</code>.</p><p>Oh, and what about that odd <code>object</code> type? Since every property on an interface just adds a constraint to the &quot;thing&quot; we're typing, there's no way to declare an interface that filters out primitive values. It's why TS has a built-in <code>object</code> type that means specifically &quot;JS object, not a primitive&quot;. Yes, you can intersect with <code>object</code> to get only <em>non-primitive</em> values satisfying an interface: <code>const x: object &amp; { toString(): string } = 9</code> fails.</p><p>Let's add all of these to our type map:</p><p><img src="/images/ts-sets/everything.png" alt=""></p><h2>extends</h2><p><code>extends</code> keyword in TS can be confusing. It comes from the object-oriented world where you <em>extend</em> a class in the sense of <em>adding functionality</em> to it, <em>but,</em> since TS uses <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">structural typing</a>, <code>extends</code> as used in <code>type Extends&lt;A, B&gt; = A extends B ? true : false</code> is <em>not</em> the same <code>extends</code> from <code>class X extends Y {}</code>.</p><p>Instead, <code>A extends B</code> can be read as <em>A is a sub-type of B</em> or, in set terms, <em>A is a subset of B.</em> If B is a union, every member of A must also be in B. If B is a &quot;constrained&quot; interface, A must not violate any of B's constraints. Good news: a usual OOP <code>class A extends B {}</code> fits <code>A extends B ? 1 : 0</code>. So does <code>'a' extends string</code>, meaning that (excuse the pun) TS <code>extends</code> extends <code>extends</code>.</p><p>This &quot;subset&quot; view is the best way to never mix up the order of <code>extends</code> operands:</p><ul><li><code>0 | 1 extends 0</code> is false, since a 2-element set <code>{0, 1}</code> is not a subset of the 1-element <code>{0}</code> (even though <code>{0,1}</code> does extend <code>{1}</code> in a geometrical sense).</li><li><code>never extends T</code> is always true, because <code>never</code>, the empty set, is a subset of any set.</li><li><code>T extends never</code> is only true if T is <code>never</code>, because an empty set has no subsets except itself.</li><li><code>T extends string</code> allows T to be a string, a literal, or a literal union, or a template, because all of these are subsets of <code>string</code>.</li><li><code>T extends string ? string extends T</code> makes sure that T is <em>exactly</em> <code>string</code>, because that's the only way it can be both a subset <em>and</em> a superset of string.</li></ul><h2>unknown and any</h2><p>Typescript has two types that can represent an arbitrary JS value — <code>unknown</code> and <code>any</code>. The normal one is <code>unknown</code> — the universe of JS values:</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// It's a 1</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> object <span class="token operator">|</span> bigint <span class="token operator">|</span> <span class="token builtin">symbol</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// a shorter one, given the {} oddity</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">Y2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// For other types, this is 0:</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">N</span></span> <span class="token operator">=</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>On a puzzling side, though:</p><ol><li><code>unknown</code> is <em>not</em> a union of all other base types, so you can't <code>Exclude&lt;unknown, string&gt;</code></li><li><code>unknown extends string | number | boolean | object | bigint | symbol | null | undefined</code> is false, meaning that some TS types are not listed. I suspect <code>enum</code>s.</li></ol><p>All in all, it's safe to think of <code>unknown</code> as &quot;the set of all possible JS values&quot;.</p><p><code>any</code> is the weird one:</p><ul><li><code>any extends string ? 1 : 0</code> evaluates to <code>0 | 1</code> which is basically a &quot;dunno&quot;.</li><li>Even <code>any extends never ? 1 : 0</code> evaluates to <code>0 | 1</code>, meaning that <code>any</code> <em>might</em> be empty.</li></ul><p>We should conclude that <code>any</code> is &quot;some set, but we're not sure which one&quot; — like a type <code>NaN</code>. However, upon further inspection, <code>string extends any</code>, <code>unknown extends any</code> and even <code>any extends any</code> are all true, none of which holds for &quot;some set&quot;. So, <code>any</code> is a <em>paradox</em> — every set is a subset of <code>any</code>, but <code>any</code> <em>might</em> be empty. The only good news I have is that <code>any extends unknown</code>, so <code>unknown</code> is still the universe, and <code>any</code> does not allow &quot;alien&quot; values.</p><p>So, to finish mapping our types, we wrap our entire diagram into <code>unknown</code> bubble:</p><p><img src="/images/ts-sets/all.png" alt=""></p><hr><p>Today, we've learnt to that TS <em>types</em> are basically <em>sets</em> of JS values. Here's a little dictionary to go from type-world to set-world, and back:</p><ul><li>Our universe = all JS values = the type <code>unknown</code></li><li><code>never</code> is an empty set.</li><li>Subtype = narrowed type = subset, supertype = widened type = superset.</li><li><code>A extends B</code> can be read as &quot;A is subset of B&quot;.</li><li>Union and intersection types are, really, just set union and intersection.</li><li><code>Exclude</code> is an <em>approximation</em> of set difference that only works on union types.</li></ul><p>Going back my our initial questions:</p><ul><li><code>0 | 1 extends 0</code> is false because <em>{0,1}</em> is <em>not</em> a subset of <em>{0}</em></li><li><code>&amp;</code> and <code>|</code> work on sets, not on object shapes. <code>A &amp; B</code> is a set of things that satisfy both <code>A</code> and <code>B</code>.</li><li><code>unknown</code> is the set of all JS values. <code>any</code> is a paradoxical set that includes everything, but <em>might</em> also be empty.</li><li>Intersecting with <code>never</code> gives you <code>never</code> because it's an empty set. <code>never</code> has no effect in a union.</li><li><code>const x: {} = true;</code> works because TS interfaces work by <em>constraining</em> the property values, and we haven't constrained anything here, so <code>true</code> fits.</li></ul><p>We still have a lot of TS mysteries to solve, so stay tuned!</p></div><span class="share"><div><a href="https://twitter.com/share?url=&text= by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2023/01/23/typescript-sets/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/typescript" rel="tag">typescript</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a></div><div class="post-actions">Written in <time>2023</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank" rel="noopener">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" href="https://buymeacoffee.com/thoughtspile" target="_blank" rel="noopener">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2022/03/28/interview-bad-habits/"><div class="post-siblings__direction">Older</div><span class="link__text">Seven habits of bad interviewers</span> </a><a class="link--bare" href="/2023/01/31/typescript-safe-narrow/"><div class="post-siblings__direction">Newer</div><span class="link__text">The complete guide to safe type narrowing in TypeScript</span></a></div></article><script async src="/js/share.js"></script></div></body></html>