<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta name="color-scheme" content="dark light"><meta property="og:type" content="article"><meta property="og:title" content="Making sense of TypeScript using set theory"><meta property="og:url" content="https://blog.thoughtspile.tech/2023/01/23/typescript-sets/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/everything.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/apples.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/bool.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/finites.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/primitives.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/everything.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/ts-sets/all.png?invert"><meta property="og:image" content="https://blog.thoughtspile.tech/images/bmc.png"><meta property="article:published_time" content="2023-01-23T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="typescript"><meta property="article:tag" content="javascript"><meta property="article:tag" content="programming"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/ts-sets/everything.png?invert"><title>Making sense of TypeScript using set theory</title><link rel="stylesheet" href="/css/style.css?ts=1675547910317"><link rel="canonical" href="https://blog.thoughtspile.tech/2023/01/23/typescript-sets/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Making sense of TypeScript using set theory</h1><div class="post__date">Written in <time>2023</time></div></header><div class="content" itemprop="articleBody"><p>I've been working with TypeScript for a long long time. I think I'm not too bad at it. However, to my despair, some low-level behaviors still confuse me:</p><ul><li>Why does <code>0 | 1 extends 0 ? true : false</code> evaluate to <code>false</code>?</li><li>I'm very ashamed, but I sometimes confuse &quot;subtype&quot; and &quot;supertype&quot;. Which is which?</li><li>While we're at it, what are type &quot;narrowing&quot; and &quot;widening&quot;, and how do they relate to sub/supertypes?</li><li>If you want an object that satisfies both <code>{ name: string }</code> and <code>{ age: number }</code>, do you <code>&amp;</code> or <code>|</code>? Both make some sense, since I want a <em>union</em> of the functionality in both interfaces, but I also want the object to satisfy left &amp; (and) right interfaces.</li><li>How is <code>any</code> different from <code>unknown</code>? All I get is imprecise mnemonics like &quot;Avoid Any, Use Unknown&quot;. Why?</li><li>What, exactly, is <code>never</code>? &quot;A value that <em>never</em> happens&quot; is very dramatic, but not too precise.</li><li>Why <code>whatever | never === whatever</code> and <code>whatever &amp; never === never</code>?</li><li>Why on earth is <code>const x: {} = true;</code> valid TS code? <code>true</code> is clearly not an empty object.</li></ul><p>I was doing some research on <code>never</code>, and stumbled upon Zhenghao He's <a href="https://www.zhenghao.io/posts/ts-never" target="_blank" rel="noopener">Complete Guide To TypeScript’s Never Type</a> (check out his blog, it's super cool!). It mentions that a type is just a set of values, and — boom — it clicked. I went back to the basics, re-formulating everything I know about TS into set-theoretic terms. Follow me as I:</p><ul><li>Refresh my knowledge of set theory,</li><li>Map TS concepts to their set counterparts,</li><li>Start simple with booelan, null and undefined types,</li><li>Extend to strings and numbers, finding some types that TS can not express,</li><li>Jump into objects, proving my assumptions about them wrong,</li><li>Finally gain confidence writing <code>extends</code> caluses,</li><li>And put <code>unknown</code> and <code>any</code> where they belong.</li></ul><p>In the end, I solve most of my questions, grow much cozier with TS, and come up with this brilliant map of TS types:</p><p><img src="/images/ts-sets/everything.png?invert" alt=""></p><h2>Set theory</h2><p>First up, a refresher on set theory. Feel free to skip if you're a pro, but my algebra skills are a bit rusty, so I could use a reminder of how it works.</p><p>Sets are unordered collections of objects. In kindergarten terms: say we have two apples aka <em>objects</em> (let's call them ivan and bob, shall we?), and some bags aka <em>sets</em> where we can put the apples. We can make, in total, 4 apple sets:</p><ol><li>A bag with apple ivan, <code>{ ivan }</code> — sets are written as curly brackets with the set items inside.</li><li>Similarly, you can have a bag with apple bob, <code>{ bob }</code>.</li><li>A bag with both apples, <code>{ ivan, bob }</code>. Hold onto your hats, this is called a <em>universe</em> because at the moment there's nothing in our world except these two apples.</li><li>An empty bag aka empty set, <code>{}</code>. This one gets a special symbol, ∅</li></ol><p>Sets are often drawn as &quot;venn diagrams&quot;, with each set represented as a circle:</p><p><img src="/images/ts-sets/apples.png?invert" alt=""></p><p>Apart from listing all the items, we can also build sets by <em>condition.</em> I can say &quot;R is a set of red apples&quot; to mean <code>{ ivan }</code>, considernig ivan is red and bob is green. So far, so good.</p><p>Set A is a <em>subset</em> of set B if every element from A is also in B. In our apple world, <code>{ ivan }</code> is a subset of <code>{ ivan, bob }</code>, but <code>{ bob }</code> is not a subset of <code>{ ivan }</code>. Obviously, any set is a subset of itself, and <code>{}</code> is a subset of any other set S, because not a single item from <code>{}</code> is missing from S.</p><p>There are a few useful operators defined on sets:</p><ul><li>Union <em>C = A ∪ B</em> contains all the elements that are in A or in B. Note that <em>A ∪ ∅ = A</em></li><li>Intersection <em>C = A ∩ B</em> contains all the elements that are in A <em>and</em> B. Note that <em>A ∩ ∅ = ∅</em></li><li>Difference <em>C = A \ B</em> contains all the elements that are in A, but not in B. Note that <em>A \ ∅ = A</em></li></ul><p>This should be enough! Let's see how it all maps to types.</p><h2>What does it have to do with types</h2><p>So, the big reveal: you can think of &quot;types&quot; as sets of JavaScript values. Then:</p><ol><li>Our <em>universe</em> is all the values a JS program can produce.</li><li>A type (not even a typescript type, just a type in general) is some set of JS values.</li><li>Some types can be represented in TS, while other can not — for example, &quot;non-zero numbers&quot;.</li><li><code>A extends B</code> as seen in <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" target="_blank" rel="noopener">conditional types</a> and <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints" target="_blank" rel="noopener">generic constraints</a> can be read as &quot;A is subset of B&quot;.</li><li>Type union, <code>|</code>, and intersection, <code>&amp;</code>, operators are just the union and intersection of two sets.</li><li><code>Exclude&lt;A, B&gt;</code> is as close as TS gets to a difference operator, except it <em>only</em> works when both <code>A</code> and <code>B</code> are union types.</li><li><code>never</code> is an empty set. Proof: <code>A &amp; never = never</code> and <code>A | never = A</code> for any type <code>A</code>, and <code>Exclude&lt;0, 0&gt; = never</code>.</li></ol><p>This change of view already yields some useful insights:</p><ul><li>Subtype of type A is a <em>subset</em> of type A. Supertype is a superset. Easy.</li><li><em>Widening</em> makes a type-set wider by allowing some extra values. <em>Narrowing</em> removes certain values. Makes geometrical sense.</li></ul><p>I know this all sounds like a lot, so let's proceed by example, starting with a simple case of boolean values.</p><h2>Boolean types</h2><p>For now, pretend JS only has boolean values. There are exaclty <em>two</em> — <code>true</code> and <code>false</code>. Recalling the apples, we can make a total of 4 types:</p><ul><li>Literal types <code>true</code> and <code>false</code>, each made up of a single value;</li><li><code>boolean</code>, which is <em>any</em> boolean value;</li><li>The empty set, <code>never</code>.</li></ul><p>The diagram of the &quot;boolean types&quot; is basically the one that we had for apples, just the names swapped:</p><p><img src="/images/ts-sets/bool.png?invert" alt=""></p><p>Let's try moving between type world and set world:</p><ul><li><code>boolean</code> can be written as <code>true | false</code> (in fact, that's exactly how TS impements it).</li><li><code>true</code> is a subset (aka sub-type) of <code>boolean</code></li><li><code>never</code> is an empty set, so <code>never</code> is a sub-set/type of <code>true</code>, <code>false</code>, and <code>boolean</code></li><li><code>&amp;</code> is an <em>intersection,</em> so <code>false &amp; true = never</code>, and <code>boolean &amp; true = (true | false) &amp; true = true</code> (the universe, <code>boolean</code>, doesn't affect intersections), and <code>true &amp; never = never</code>, etc.</li><li><code>|</code> is a <em>union,</em> so <code>true | never = true</code>, and <code>boolean | true = boolean</code> (the universe, <code>boolean</code>, &quot;swallows&quot; other intersection items because they're all subsets of universe).</li><li><code>Exclude</code> correctly computes set difference: <code>Exclude&lt;boolean, true&gt; -&gt; false</code></li></ul><p>Now, a little self-assessment of the tricky <code>extends</code> cases:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">boolean</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">false</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>If you recall that &quot;extends&quot; can be read as &quot;is subset of&quot;, the answer should be clear — A0,B1,C1,C1. We're making progress!</p><p><code>null</code> and <code>undefined</code> are just like <code>boolean</code>, except they only contain <em>one</em> value each. <code>never extends null</code> still holds, <code>null &amp; boolean</code> is <code>never</code> since no JS value can simultaneously be of 2 different JS types, and so on. Let's add these to our &quot;trivial types map&quot;:</p><p><img src="/images/ts-sets/finites.png?invert" alt=""></p><h2>Strings and other primitives</h2><p>With the simple ones out of the way, let's move on to string types. At first, it seems that nothing's changed — <code>string</code> is a type for &quot;all JS strings&quot;, and every string has a corresponding literal type: <code>const str: 'hi' = 'hi';</code> However, there's one key difference — there are <em>infinitely many</em> possible string values.</p><blockquote><p>It might be a lie, because you can only represent so many strings in finite computer memory, but a) it's enough strings to make enumerating them all unpractical, and b) type systems <em>can</em> operate on pure abstrations without worrying about dirty real-life limitations.</p></blockquote><p>Just like sets, string types can be constructed in a few different ways:</p><ul><li><code>|</code> union lets you constuct any <em>finite</em> string set — e.g. <code>type Country = 'de' | 'us';</code>. This won't work for <em>infinite</em> sets — say, all strings with length &gt; 2 — since you can't write an infinite list of value.</li><li>Funky <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" target="_blank" rel="noopener">template literal types</a> let you construct <em>some</em> infinite sets — e.g. <code>type V = `v${string}`;</code> is a set of all strings that start with <code>v</code>.</li></ul><p>We can go a bit further by making unions and intersections of literal and template types. Fun time: when combining a <em>union</em> with a <em>template,</em> TS is smart enough to just filter the literals againts the template, so that <code>'a' | 'b' &amp; `a${string}` = 'a'</code>. Yet, TS is not <em>smart enough</em> to merge templates, so you get really fancy ways of saying <code>never</code>, such as <code>`a${string}` &amp; `b${string}`</code> (obviously, a string can't start with &quot;a&quot; and &quot;b&quot; at the same time).</p><p>However, some string types are <em>not</em> representable in TS at all. Try &quot;every string except 'a'&quot;. You could <code>Exclude&lt;string, 'a'&gt;</code>, but since TS doesn't <em>actually</em> model <code>string</code> as <em>union of all possible string literals,</em> this in fact evaluates back to <code>string</code>. The template grammar can not express this negative condition either. Bad luck!</p><p>The types for numbers, symbols and bigints work the same way, except they don't even get a &quot;template&quot; type, and are limited to finite sets. It's a pity, as I could really use some number subtypes — <em>integer, number between 0 and 1,</em> or <em>positive number.</em> Anyways, all together:</p><p><img src="/images/ts-sets/primitives.png?invert" alt=""></p><p>Phew, we've covered all primitive, <em>non-intersecting</em> JS / TS types. We've gotten comfortable moving between sets and types, and discovered that some types can't be defined in TS. Here comes the tricky part.</p><h2>Interfaces &amp; object types</h2><p>If you think <code>const x: {} = 9;</code> makes no sense, this section is for you. As it appears, our mental model of what TS object types / records / interfaces was built on the wrong assumptions.</p><p>First, you'd probably expect types like <code>type Sum9 = { sum: 9 }</code> to act like &quot;literal types&quot; for objects — matching a single object value <code>{ sum: 9 }</code>, adjusted for referential equality. This is absolutely <em>not</em> how it works. Instead, <code>Sum9</code> is a &quot;<em>thing</em> on which you can access propery <code>sum</code> to get <code>9</code>&quot; — more like a condition / constraint. This lets us call <code>(data: Sum9) =&gt; number</code> with an object <code>obj = { sum: 9, date: '2022-09-13' }</code> without TS complaining about unknown <code>date</code> property. See, handy!</p><p>Then, <code>{}</code> type is not an &quot;empty object&quot; type corresponding to a <code>{}</code> JS literal, but a &quot;thing where I can access properties, but I don't care about any particular properties&quot;. Aha, now we can see what's going on in our initial mind-bender: if <code>x = 9</code>, you can safely <code>x['whatever']</code>, so it satisfies the unconstrained <code>{}</code> interface. In fact, we can even make bolder claims like <code>const x: { toString(): string } = 9;</code>, since we can <code>x.toString()</code> and actuallty get a string. More yet, <code>keyof number</code> gives us <code>&quot;toString&quot; | &quot;toFixed&quot; | &quot;toExponential&quot; | &quot;toPrecision&quot; | &quot;valueOf&quot; | &quot;toLocaleString&quot;</code>, meaning that TS secretly sees our primitive type as an object, which it is (thanks to <a href="https://javascript.plainenglish.io/javascript-boxing-wrappers-5b5ff9e5f6ab" target="_blank" rel="noopener">autoboxing</a>). <code>null</code> and <code>undefined</code> do not satisfy <code>{}</code>, because they throw if you try to read a property. Not super intuitive, but makes sense now.</p><p>Coming back to my little &quot;<code>|</code> or <code>&amp;</code>&quot; problem, <code>&amp;</code> and <code>|</code> operate on &quot;value sets&quot;, not on &quot;object shapes&quot;, so you need <code>{ name: string } &amp; { age: number }</code> to get objects with <em>both</em> <code>name</code> and (extra hint: and = <code>&amp;</code>) <code>age</code>.</p><p>Oh, and what about that odd <code>object</code> type? Since every property on an interface just adds a constraint to the &quot;thing&quot; we're typing, there's no way to declare an interface that filters out primitive values. It's why TS has a built-in <code>object</code> type that means specifically &quot;JS object, not a primitive&quot;. Yes, you can intersect with <code>object</code> to get only <em>non-primitive</em> values satisfying an interface: <code>const x: object &amp; { toString(): string } = 9</code> fails.</p><p>Let's add all of these to our type map:</p><p><img src="/images/ts-sets/everything.png?invert" alt=""></p><h2>extends</h2><p><code>extends</code> keyword in TS can be confusing. It comes from the object-oriented world where you <em>extend</em> a class in the sense of <em>adding functionality</em> to it, <em>but,</em> since TS uses <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">structural typing</a>, <code>extends</code> as used in <code>type Extends&lt;A, B&gt; = A extends B ? true : false</code> is <em>not</em> the same <code>extends</code> from <code>class X extends Y {}</code>.</p><p>Instead, <code>A extends B</code> can be read as <em>A is a sub-type of B</em> or, in set terms, <em>A is a subset of B.</em> If B is a union, every member of A must also be in B. If B is a &quot;constrained&quot; interface, A must not violate any of B's constraints. Good news: a usual OOP <code>class A extends B {}</code> fits <code>A extends B ? 1 : 0</code>. So does <code>'a' extends string</code>, meaning that (excuse the pun) TS <code>extends</code> extends <code>extends</code>.</p><p>This &quot;subset&quot; view is the best way to never mix up the order of <code>extends</code> operands:</p><ul><li><code>0 | 1 extends 0</code> is false, since a 2-element set <code>{0, 1}</code> is not a subset of the 1-element <code>{0}</code> (even though <code>{0,1}</code> does extend <code>{1}</code> in a geometrical sense).</li><li><code>never extends T</code> is always true, because <code>never</code>, the empty set, is a subset of any set.</li><li><code>T extends never</code> is only true if T is <code>never</code>, because an empty set has no subsets except itself.</li><li><code>T extends string</code> allows T to be a string, a literal, or a literal union, or a template, because all of these are subsets of <code>string</code>.</li><li><code>T extends string ? string extends T</code> makes sure that T is <em>exactly</em> <code>string</code>, because that's the only way it can be both a subset <em>and</em> a superset of string.</li></ul><h2>unknown and any</h2><p>Typescript has two types that can represent an arbitrary JS value — <code>unknown</code> and <code>any</code>. The normal one is <code>unknown</code> — the universe of JS values:</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// It's a 1</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> object <span class="token operator">|</span> bigint <span class="token operator">|</span> <span class="token builtin">symbol</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// a shorter one, given the {} oddity</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">Y2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// For other types, this is 0:</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">N</span></span> <span class="token operator">=</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>On a puzzling side, though:</p><ol><li><code>unknown</code> is <em>not</em> a union of all other base types, so you can't <code>Exclude&lt;unknown, string&gt;</code></li><li><code>unknown extends string | number | boolean | object | bigint | symbol | null | undefined</code> is false, meaning that some TS types are not listed. I suspect <code>enum</code>s.</li></ol><p>All in all, it's safe to think of <code>unknown</code> as &quot;the set of all possible JS values&quot;.</p><p><code>any</code> is the weird one:</p><ul><li><code>any extends string ? 1 : 0</code> evaluates to <code>0 | 1</code> which is basically a &quot;dunno&quot;.</li><li>Even <code>any extends never ? 1 : 0</code> evaluates to <code>0 | 1</code>, meaning that <code>any</code> <em>might</em> be empty.</li></ul><p>We should conclude that <code>any</code> is &quot;some set, but we're not sure which one&quot; — like a type <code>NaN</code>. However, upon further inspection, <code>string extends any</code>, <code>unknown extends any</code> and even <code>any extends any</code> are all true, none of which holds for &quot;some set&quot;. So, <code>any</code> is a <em>paradox</em> — every set is a subset of <code>any</code>, but <code>any</code> <em>might</em> be empty. The only good news I have is that <code>any extends unknown</code>, so <code>unknown</code> is still the universe, and <code>any</code> does not allow &quot;alien&quot; values.</p><p>So, to finish mapping our types, we wrap our entire diagram into <code>unknown</code> bubble:</p><p><img src="/images/ts-sets/all.png?invert" alt=""></p><hr><p>Today, we've learnt to that TS <em>types</em> are basically <em>sets</em> of JS values. Here's a little dictionary to go from type-world to set-world, and back:</p><ul><li>Our universe = all JS values = the type <code>unknown</code></li><li><code>never</code> is an empty set.</li><li>Subtype = narrowed type = subset, supertype = widened type = superset.</li><li><code>A extends B</code> can be read as &quot;A is subset of B&quot;.</li><li>Union and intersection types are, really, just set union and intersection.</li><li><code>Exclude</code> is an <em>approximation</em> of set difference that only works on union types.</li></ul><p>Going back my our initial questions:</p><ul><li><code>0 | 1 extends 0</code> is false because <em>{0,1}</em> is <em>not</em> a subset of <em>{0}</em></li><li><code>&amp;</code> and <code>|</code> work on sets, not on object shapes. <code>A &amp; B</code> is a set of things that satisfy both <code>A</code> and <code>B</code>.</li><li><code>unknown</code> is the set of all JS values. <code>any</code> is a paradoxical set that includes everything, but <em>might</em> also be empty.</li><li>Intersecting with <code>never</code> gives you <code>never</code> because it's an empty set. <code>never</code> has no effect in a union.</li><li><code>const x: {} = true;</code> works because TS interfaces work by <em>constraining</em> the property values, and we haven't constrained anything here, so <code>true</code> fits.</li></ul><p>We still have a lot of TS mysteries to solve, so stay tuned!</p></div><span class="share"><div><a href="https://twitter.com/share?url=https://blog.thoughtspile.tech/2023/01/23/typescript-sets/&text=Making sense of TypeScript using set theory by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2023/01/23/typescript-sets/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="social-links"><a href="https://twitter.com/thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="https://mastodon.online/@thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a><a href="https://www.linkedin.com/in/vklepov/" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="/atom.xml" class="link--bare" target="_blank"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="rss" class="svg-inline--fa fa-rss fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM128 416c0 35.3-28.7 64-64 64s-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a></div><a href="https://buymeacoffee.com/thoughtspile" class="link--bare bmc-card" target="_blank" rel="noopener"><div><b>Hello, friend!</b> My name is Vladimir, and I love writing about web development. If you got down here, you probably enjoyed this article. My goal is to become an independent content creator, and you'll help me get there by <span class="bmc">buying me a coffee!</span></div><img src="/images/bmc.png" class="bmc-image"></a><div class="post-related"><div class="post-sibling"><span class="post-siblings__direction">More?</span> <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/typescript" rel="tag">typescript</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a></div><a class="link--bare post-sibling" href="/2022/03/28/interview-bad-habits/"><span class="post-siblings__direction">Older?</span> <span class="link__text">Seven habits of bad interviewers</span> </a><a class="link--bare post-sibling" href="/2023/01/31/typescript-safe-narrow/"><span class="post-siblings__direction">Newer?</span> <span class="link__text">The complete guide to safe type narrowing in TypeScript</span></a></div></article><script async src="/js/share.js"></script></div></body></html>