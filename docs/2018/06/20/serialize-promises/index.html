<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="color-scheme" content="dark light"><meta property="og:type" content="article"><meta property="og:title" content="Advanced Promises Coordination: Serialization and Concurrency Limiting"><meta property="og:url" content="https://thoughtspile.github.io/2018/06/20/serialize-promises/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/main-promo.png"><meta property="article:published_time" content="2018-06-20T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="promises"><meta property="article:tag" content="javascript"><meta property="article:tag" content="programming"><meta property="article:tag" content="concurrency"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://thoughtspile.github.io/images/main-promo.png"><title>Advanced Promises Coordination: Serialization and Concurrency Limiting</title><link rel="stylesheet" href="/css/style.css?ts=1715245757432"><link rel="canonical" href="https://thoughtspile.github.io/2018/06/20/serialize-promises/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="thoughtspile.github.io" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Advanced Promises Coordination: Serialization and Concurrency Limiting</h1><div class="post__date">Written in <time>2018</time></div></header><div class="content" itemprop="articleBody"><p>I'm sure you can chain promises with <code>doBefore().then(() =&gt; doAfter())</code> and even run multiple promises in parallel using <code>Promise.any</code>. However, chaining an unknown count of homogenous promises is trickier. Let me teach you to serialze promises like a pro!</p><p>Suppose we want a list of all the cafes in a mid-sized european country.However, the API only lets you query the cafes by city. No problem — we have a list of all the cities, and will send a request for each one, then assemble the results.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> cities <span class="token operator">=</span> <span class="token punctuation">[</span><br>  <span class="token string">"Abertamy"</span><span class="token punctuation">,</span><br>  <span class="token string">"Adamov (Blansko District)"</span><span class="token punctuation">,</span><br>  <span class="token string">"Aš"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bakov nad Jizerou"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bavorov"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bechyně"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bečov nad Teplou"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bělá nad Radbuzou"</span><span class="token punctuation">,</span><br>  <span class="token string">"Bělá pod Bezdězem"</span><span class="token punctuation">,</span><br>  <span class="token comment">// ... and 200 more</span><br><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token function-variable function">loadCafes</span> <span class="token operator">=</span> <span class="token parameter">city</span> <span class="token operator">=></span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">api.fivecircle.com/city/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>city<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2>How Not to Chain Promises</h2><p>The first naive attempts are no good:</p><pre class="language-js"><code class="language-js"><span class="token comment">// All gone in a glimpse of eye:</span><br>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>areas<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>loadCafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cafes</span> <span class="token operator">=></span> db<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">flatten</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Still not good</span><br>areas<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">area</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>storeData<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// More of the same</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> area <span class="token keyword">in</span> areas<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>storeData<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Since promises start executing once created, each of these options fires all the requests at once. With sane rate limiting restrictions, it will fail. A less elaborate server could even crash.</p><p>We could, of course, use <code>await</code>:</p><pre class="language-js"><code class="language-js"><span class="token keyword">let</span> cafes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> area <span class="token keyword">of</span> areas<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  cafes <span class="token operator">=</span> cafes<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token function">storeData</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>But I'm not a fan of this syntax — the code is now arguably C-like. I also find error handling in promises cleaner. And now we have more preprocessing to do for the code to work, which is nothing to be proud of. So let's go on and write this in pure promises instead.</p><h2>Explicit Serialization</h2><p>The best-known trick from this bunch is explicitly chaining an array of promises with <code>&lt;Array&gt;.reduce</code>. It works best for fire-and-forget promises, like redux actions:</p><pre class="language-js"><code class="language-js"><span class="token keyword">return</span> actions<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><br>  <span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> before<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>However, assembling return values is a bit awkward:</p><pre class="language-js"><code class="language-js">areas<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">before<span class="token punctuation">,</span> area</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> before<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">acc</span> <span class="token operator">=></span> <span class="token function">loadCafes</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cafes</span> <span class="token operator">=></span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cafes</span> <span class="token operator">=></span> db<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>cafes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Overall, this is good enough when you have an array of data you want to run the actions on beforehand. But what if you don't?</p><h2>Implicit Serialization</h2><p>We can actually write a wrapper for arbitrary promise-returning functions that makes any call wait for the previous ones to finish. This wrapper is completely transparent, leaving the function's interface intact — good for composability. Here it is:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token parameter">immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// This works as our promise queue</span><br>  <span class="token keyword">let</span> last <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Catch is necessary here — otherwise a rejection in a promise will</span><br>    <span class="token comment">// break the serializer forever</span><br>    last <span class="token operator">=</span> last<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">immediate</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> last<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Now we can just wrap our function and never have to worry about flooding the API again:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> loadCafesSafe <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span>loadCafes<span class="token punctuation">)</span><span class="token punctuation">;</span><br>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>areas<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">a</span> <span class="token operator">=></span> <span class="token function">loadCafesSafe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>It's so easy it doesn't warrant a library — just five lines of code. And we can take this idea further with...</p><h2>Concurrency Limiting</h2><p>Serialization effectively forces our promises to run in one thread. To make them go faster, we can generalize the serializer to allow not one, but at most N promises to run simultaneously:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">limitConcurrency</span><span class="token punctuation">(</span><span class="token parameter">immediate<span class="token punctuation">,</span> maxConcurrent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// Each element holds its index, or a promise resolving with the index</span><br>  <span class="token keyword">const</span> workers <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>maxConcurrent<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// Without this serialization, Promise.race would resolve with the same</span><br>  <span class="token comment">// worker whenever a concurrency-limited function was synchronously called</span><br>  <span class="token comment">// multiple times.</span><br>  <span class="token keyword">const</span> findWorker <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>workers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// race resolves with the first free worker</span><br>    <span class="token keyword">return</span> <span class="token function">findWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token comment">// and here we start the action and update the worker correspondingly:</span><br>      <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token function">immediate</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      workers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">return</span> promise<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>The idea is the same, but we replaced the single <code>last</code> promise with an array of N workers and added some bookkeeping. This code packs promises into threads as tightly as possible, with no idle time.</p><p>Also note that <code>serializePromises</code> is the same as <code>a =&gt; limitConcurrency(a, 1)</code>.</p><p>If you want to impose joint limiting on several arbitrary functions, you can tweak the code — I leave this to you as an exercise ;-)</p><h2>Propagating Rate Errors</h2><p>Now that our code manages a promise queue, we can see a potential problem in it. The system can smooth activity spikes without propagating these upstream. However, if the request rate is higher than what the upstream can handle for an extended period of time, our queue can overfill and blow up the memory limit.</p><p>The problem still existed before we added the limiter, but would occurred upstream instead. No wrapper can magically improve service throughput.</p><p>To handle these errors without crashing our process, we can put a hard limit on queue size. Here's how it can be done for the generic <code>limitConcurrency</code>:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">limitConcurrency</span><span class="token punctuation">(</span><span class="token parameter">immediate<span class="token punctuation">,</span> maxConcurrent<span class="token punctuation">,</span> maxQueue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// this is our queue counter</span><br>  <span class="token keyword">let</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> workers <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>maxConcurrent<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> findWorker <span class="token operator">=</span> <span class="token function">serializePromises</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>workers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queued <span class="token operator">>=</span> maxQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Max queue size reached'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    queued <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token function">findWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      queued <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span><br>      <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token function">immediate</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      workers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token keyword">return</span> promise<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Now, instead of uncontrollably enqueueing, the coordinator rejects when there's already too much work ahead. The consumers can handle these errors and retry later.</p><h2>Use Cases</h2><p>So far we've been discussing an example with API requests, and you might argue that concurrency limiting functionality should be provided bt the HTTP client library. That's true, but the power of our promise-based strategy is its generality. Here are some unorthodox use cases:</p><h3>&quot;Sloppy Transactions&quot; with Serialization</h3><p>Suppose an action involves reading an external data source, computing on the response and issuing an update. If the source changes between the read and the update, you've corrupted your data beyond repair. You can instead wrap the action with our &quot;promise serializer&quot;. Of course, this assumes that the relevant data is only accessed by your wrapper, and only by a single process. You can even build a simple file-based database.</p><h3>Prevent Notification Flood with Concurrency Limiting</h3><p>A front-end idea. You probably have a notification area somewhere on the screen. However, if a large batch of notifications just arrived, the users are likely to miss some of those. But now you can treat the currently visible notifications as the running threads and apply <code>limitConcurrecny</code>!</p><p>A similar use case for modal windows uses serialized promises — you can't show multiple modals at the same time, but now you can enqueue the next one instead.</p><h3>Web Worker Thread Pool</h3><p>Finally, time for some cutting-edge tech. If your web app heavily uses web workers for background processing, you can wrap web worker access with a promise-based API, then use our wrapper to limit the number of simultaneously active workers. With several kinds of specialized workers, you might choose to use a multi-factory flavour of our <code>limitConcurrecny</code> instead. I'll delve deeper into this this case with an upcoming article on load balancing.</p><h2>Summary</h2><p>We've learnt how to force promises to run consecutively and even to limit the number of pending promises to a specified number. This technique can be used for safer back-end access, and its generality allows to use it for any promise-based API.</p><p>I'm not too good at writing: the topics kept expanding in my head, and I have had a hard time finishing this article. I have two other interesting promise coordination patterns to handle in future articles of this series:</p><ul><li>Rate Limiting</li><li>Load Balancing</li></ul><p>Wish me luck writing these! If you have some tips or want to argue, drop me an e-mail.</p><p><strong>Advanced Promise Coordination Series</strong></p><ul><li><a href="/2018/06/20/serialize-promises/">Serialization and Concurrency Limiting</a></li><li><a href="/2018/07/07/rate-limit-promises/">Rate Limiting</a></li></ul></div><span class="share"><div><a href="https://twitter.com/share?url=https://thoughtspile.github.io/2018/06/20/serialize-promises/&text=Advanced Promises Coordination: Serialization and Concurrency Limiting by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div></span><div class="social-links"><a href="https://www.linkedin.com/in/vklepov/" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="https://github.com/thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href="/atom.xml" class="link--bare" target="_blank"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="rss" class="svg-inline--fa fa-rss fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM128 416c0 35.3-28.7 64-64 64s-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a></div><a href="https://buymeacoffee.com/thoughtspile" class="link--bare bmc-card" target="_blank" rel="noopener"><div><b>Hello, friend!</b> My name is Vladimir, and I love writing about web development. If you got down here, you probably enjoyed this article. My goal is to become an independent content creator, and you'll help me get there by <span class="bmc">buying me a coffee!</span></div><img src="/images/bmc.png" data-no-preview class="bmc-image"></a><div class="post-related"><div class="post-sibling"><span class="post-siblings__direction">More?</span> <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/promises" rel="tag">promises</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a> <a class="tag-link-link" href="/tags/concurrency" rel="tag">concurrency</a></div><a class="link--bare post-sibling" href="/2018/07/07/rate-limit-promises/"><span class="post-siblings__direction">Newer?</span> <span class="link__text">Advanced Promise Coordination: Rate Limiting</span></a></div></article><script async src="/js/share.js"></script></div></body></html>