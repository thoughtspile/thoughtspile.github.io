<p>Reading comments to my article on <a href="">making sense of TypeScipt using set theory</a> has been a lot of fun. &quot;covariant types&quot;. I had no idea what this meant, but it sounded cool so I went to do some research. Just to spice things up, I present my findings as a very long list of facts (I do love lists).</p><p>Before we get to the actual list of facts, let me present you with a <em>disclaimer list:</em></p><ul><li>The title is a clickbait, in reality only M facts on the list are fun.</li><li>Some facts are quite useful, some are quite amusing, but I'm not sure if some are both useful and amusing.</li><li>The favts are not ordered by fun-ness.</li><li>We will be talking about TypeScipt tuples, <em>not</em> tuples the JS proposal. TS <a href="https://github.com/microsoft/TypeScript/issues/49243" target="_blank" rel="noopener">does not support</a> JS tuples yet.</li></ul><p>So, N facts await, let's go:</p><ol><li><p><code>T[]</code> is the TS type for a JS array of values of type <code>T</code>. E.g. <code>number[]</code> is an array of numbers, like <code>[1, 2, 3]</code>. You probably knew that.</p></li><li><p>Built-in generic type <code>Array&lt;T&gt;</code> is not a direct alias for <code>T[]</code>. I suppose it is, in fact, the other way around, but I'm not 100% sure.</p></li><li><p>Since ES specifications love adding new array methods, the TS declaration of the <code>Array</code> interface is split out across multiple <code>lib.es20xx.part.d.ts</code> files.</p></li><li><p>A built-in type called <code>ArrayLike</code> exists. It only guarantees number indexing and a numeric <code>length</code> property.</p></li><li><p><code>Array&lt;T&gt; extends ArrayLike&lt;T&gt;</code></p></li><li><p><code>string extends ArrayLike&lt;string&gt;</code>, because strings are number-indexable and have a numeric <code>length</code> property.</p></li><li><p>Every type <code>T</code> has a corresponding array type <code>T[]</code>.</p></li><li><p>You can build interfaces with varying degrees of array-likedness yourself, starting with <code>{ [i: number]: T }</code></p></li><li><p>Another array-related type is called <code>ConcatArray</code>.</p></li><li><p>Speaaking of, <code>concat</code> method on <code>Array&lt;T&gt;</code> is typed so that it only accepts arrays (or should I say <code>ConcatArrays</code>?) of type <code>T[]</code></p></li><li><p>Luckily, array spread syntax <code>[...a, ...b]</code> allows you to concatenate arrays of different types.</p></li><li><p>Given <code>a: A[]</code> and <code>b: B[]</code>, the type of <code>[...a, ...b]</code> is correctly inferred as <code>(A | B)[]</code>.</p></li><li><p>If <code>T extends P</code>, then <code>T[] extends P[]</code>. In nerd-speak it's called &quot;covariance&quot;.</p></li><li><p>Every JS array literal satisfies <em>infinitely many</em> <code>Array</code> types. For <code>[1]</code> the narrowest type is <code>1[]</code>, then you can <code>(1 | 2)[]</code>, then <code>(1 | 2 | 'a')[]</code>, and so on.</p></li><li><p>Remarkably, the empty array, <code>[]</code>, satisfies <em>every</em> TS array type, because it contains no elements to prove this claim wrong.</p></li><li><p>Every <code>Array&lt;T&gt;</code> type contains infinitely many possible values, except <em>maybe</em> one very special <code>T</code> (see next below)</p></li><li><p><code>never[]</code> is a very funny type that only contains empty arrays. Proof: if <code>x</code> satisifes <code>never[]</code> and <code>x</code> contains at least one element, <code>x_0</code>, then <code>x_0</code> must belong to type <code>never</code>. <code>never</code> is an empty set and contains no values, contradictin. Hence, <code>x</code> can not contain elements, and x is empty.</p></li><li><p>Wheteher <code>never[]</code> contains a single value or infinitely many depends on wheteher you're willing to make a &quot;referential-equality adjustment&quot; and pretend that all empty arrays are one. This is more of a philosophical question, let's move on.</p></li><li><p><code>never[] extends T[]</code> for any T, because every <code>T[]</code> contains an empty array. (Also, because <code>never extends T</code>, and array types are covariant).</p></li><li><p>Concatenating <code>T[]</code> and <code>never[]</code> gives you <code>T[]</code> because <code>never | T = T</code>, or, in common sense, because concatenating with an empty array gives you the criginal array back.</p></li><li><p><code>(T &amp; P)[] = T[] &amp; P[]</code> (in nerd-speak, arrays distribute over intersection). Proof:</p></li><li><p><code>(T | P)[] != T[] | P[]</code>. Proof: <code>[1, 'a']</code> belongs to <code>(number | string)[]</code>, but not to <code>number[] | string[]</code>. <code>T[] | P[]</code> is a proper subtype of <code>(T | P)[]</code>.</p></li><li><p>JS arrays are mutable, which makes typing (in the sense of assigning types, not slapping keyboard with your fingers) them harder. If you have an array <code>[1,2,3]</code>, its type <em>could</em> be <code>(1 | 2 | 3)[]</code>, but then you wouldn't be able to <code>push</code> any other value into it, so TS benevolently infers the type of <code>const x = [1, 2, 3]</code> as <code>number[]</code></p></li><li><p><code>ReadonlyArray&lt;T&gt;</code> type exists.</p></li><li><p><code>Array&lt;T&gt; extends ReadonlyArray&lt;T&gt;</code></p></li><li><p><code>readonly T[]</code> is sugar for <code>ReadonlyArray&lt;T&gt;</code>. We could all benefit from declaring pure function parameters as <code>readonly</code> arrays, but it's too much typing, so we don't do it</p></li><li><p>Typed arrays (<code>Uint8Array</code>, <code>Float32Array</code> and friends) are <em>not</em> <code>Array&lt;Unit8&gt;</code>, which is fair enough because a) <code>Uint8</code> type does not exist and b) <code>Uint8Array</code> does not actually inherit from <code>Array</code> and has different methods</p></li><li><p>The declarations for typed arrays are totally unrelated to each other and take up about 2/3 of ES5 typings. I wonder why, because in JS they all inherit from <code>TypedArray</code> class.</p></li><li><p>TS tuples are arrays</p></li><li><p><code>length</code> property of a tuple is a number literal type</p></li><li><p><code>[]</code> could be a much better &quot;empty array&quot;</p></li><li><p>A single-type tuple of any length (<code>[], [T], [T, T]</code>) is a subtupe of <code>T[]</code>. So is a union of any quantity of tuple types. In theory, <code>T[]</code> could be defined as an infinite union <code>[] | [T] | [T, T] | etc</code></p></li><li><p>A mixed-type tuple <code>[T, P], [T, P, Q]</code> is a subtype of a &quot;union array&quot; <code>(T | P)[]</code>, <code>(T | P | Q)[]</code></p></li><li><p>A tuple containing <code>never</code>, like <code>[never]</code> is an empty type. Proof: it <em>must</em> have an element at index 0, but the element <em>must</em> come from an empty set, which is not doable.</p></li><li><p><code>[never]</code> does not <code>extends never</code> even though both are empty types.</p></li><li><p>Of course, readonly tuples exist</p></li><li><p>One way to write a conditional generic that checks for <code>never</code> type is wrapping type parameter into a tuple: <code>type IsNever&lt;T&gt; = [T] extends [never] ? true : false</code>.</p></li><li><p>Const assertion on an array literal, <code>[1, 2, 3] as const</code>, produces a readonly tuple type. It's neat because you know exactly the type of</p></li></ol>