<p>Front-end development in 2023 is off to a great with people unveiling the truth of how <a href="https://infrequently.org/2023/02/the-market-for-lemons/" target="_blank" rel="noopener">SPAs suck,</a> and oh wait <a href="https://seldo.com/posts/the_case_for_frameworks" target="_blank" rel="noopener">they actually don't</a> and oh you're so wrong <a href="https://www.spicyweb.dev/the-great-gaslighting-of-the-js-age/" target="_blank" rel="noopener">they actually do suck,</a> and so on.</p><p>Now, who am I to attack SSR that is clearly the future? Well, I'm just old enough to have worked on a few large jQuery apps, and it still hurts.</p><p>The initial title of this post was &quot;SPAs: the good parts&quot;, but with all the strong language used</p><h2>10 reasons SSR is stupid</h2><h3>SSR feels slow</h3><p>Let's recap the loading process of a traditional SPA:</p><ol><li>Send a request for the URL</li><li>Server quickly responds with a minimal static HTML</li><li>Load static JS referenced in the HTML</li><li>Execute JS, maybe draw some loaders or skeletons</li><li>Load the data from an API</li><li>Updates the screen based on the data you just loaded.</li><li>Et voila you have a fully functional page.</li></ol><p>Sounds convoluted? It is, but wait till you hear the joke that is traditional SSR loading:</p><ol><li>Send a request for the URL</li><li>Server goes to get the data needed to draw the page</li><li>Server gets the data and renders the HTML based on it for you.</li><li>Load the HTML</li><li>Et voila, finally you see <em>some</em> content!</li><li>Load static JS (granted, there's probably less of it)</li><li>You have a fully functional page</li></ol><p>This looks like the same stuff, just slightly reordered, but there is one crucial difference: what the user sees while the data is loading. In an SPA, it's an interactive page generated by your JS. In SSR, it's a blank screen.</p><p>The critical path of an SPA (before the content) is quite easy to optimize. Serving static files is simple, reliable and very fast. JS is cached, so you get it almost for free on subsequent visits. Optimizing the bundle is an understandable process of chunk splitting. You can <em>preload</em> the data <em>before</em> the main JS loads. And best of all, this is all fully in control of a front-end team.</p><p>But loading data is a whole different story.</p><p>If you believe that loading</p><h3>SSR fault tolerance is a joke</h3><p>Now let's take our thought experiment with a slow microservice a step further and bring the service down completely. This happens, because back-end is not created by some programming gods, but by monkeys with keyboards, just like ourselves.</p><p>SPA with granular data loading will successfully show the majority of the page, rendering a</p><p>Even with the back-end fully down, an SPA</p><h3>Combining SSR with CSR is not a magic wand</h3><p>No problem, you say, I render high-priority data on the server, and the rest via a traditional</p><h3>SSR is harder to scale</h3><h3>Enhancement is hard</h3><h3>Pure SSR is horrible UX</h3><h3>Granular invalidation is duplication</h3><h3>Imperative DOM manipulation is hard</h3><h3>HTML does not have good DX</h3><h3>Web standards are lagging behind</h3><h2>Where do we go from here?</h2><h3>Prerendering</h3><h3>More incremental frameworks</h3><h3>Mora vanilla state management</h3><h3>SSR Streaming &amp; Caching</h3><h3>Better HTML tooling</h3><h3>Better browser standards</h3><hr>