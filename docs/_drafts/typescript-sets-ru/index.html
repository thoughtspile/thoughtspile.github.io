<p>Я пишу на тайпскрипте уже довольно давно. Получается, вроде бы, не так уж и плохо. Но некоторые вопросы все еще сбивают меня с толку:</p><ul><li>Если мне нужен объект, который реализует и <code>{ name: string }</code>, и <code>{ age: number }</code>, нужно эти типы <code>&amp;</code> (пересечь) или <code>|</code> (объединить)? В каждом вариатне можно найти логику, потому что я хочу левое <em>и</em> правое, но, с другой стороны, мне нужно <em>объединение</em> интерфейсов.</li><li>Сработает ли <code>type &lt;T&gt; = T extends string ? ...</code>, если <code>T</code> — юнион строк, вроде <code>'ru' | 'de'</code>?</li><li>В чем разница межу <code>any</code> и <code>unknown</code>? Лучшее предложение интернета — дурацкие мнемоники типа &quot;Avoid Any, Use Unknown&quot;. Братан, а что не так с <code>any</code>?</li><li>А <code>never</code> — что за тип? &quot;never по-английски значит НИКОГДА, и это значение НИКОГДА не должно появляться в вашей программе&quot; звучит очень драматично, но не помогает проникнуть в сусть вещей.</li><li>Если <code>never</code> это какой-то взрыв, то почему я могу <code>const x: number = y as never</code>? И почему <code>never extends X</code> всегда выполняется?</li><li>К слову, почему <code>whatever | never === whatever</code>, а <code>whatever &amp; never === never</code>?</li><li><code>const x: {} = true;</code> — правильно типизиорованный код. Ну как это вообще, а? <code>true</code> точно не пустой объект.</li><li><code>object</code> — это для лентяев, которые не могут перечислить свойства, или что-то вроде <code>any</code>?</li></ul><p>Если вам легко ответить на все эти вопросы — вы молодец. Правда. Здорово, что в мире есть такие умные люди. Я вот не могу. Я стал разбираться с <code>never</code> и нашел <a href="https://www.zhenghao.io/posts/ts-never" target="_blank" rel="noopener">отличную статью</a> про <code>never</code> (кстати, Жэньхао — тот самый азиат, который делает все лучше меня, обязательно почитайте его блог). Я увидел там интересную мысль — <em>на самом деле</em> <code>never</code> — пустое множество значений.</p><p>И оказывается, если впустить в свою душу идею, что тип — это просто множество значений, все встает на свои места. Я ушел в пещеру, разобрал все свои знания о тайпскрипте, а потом собрал их на место по чертежу из теории множеств, и получилось логично. Давайте сделаем это вместе:</p><ul><li>Освежим наши знания о теории множеств.</li><li>Посмотрим, как понятия тайпскрипта соотносятся с множествами и операциями на них.</li><li>Для разминки переведем на язык множеств булевы типы (а заодно — <code>null</code> и <code>undefined</code>).</li><li>Обобщим это на числа (и походу выясним, какие типы TS вообще не может выразить).</li><li>Перейдем к интерфейсам — оказывается, они работают совсем не так, как я думал!</li><li>И на десерт — разложим по полочкам <code>any</code> и <code>undefined</code>.</li></ul><p>В конце я нахожу ответы на все свои вопросы, выстраиваю TS в стройную теорию, и рисую эту <em>великолепную</em> диаграмму:</p><p><img src="/images/ts-sets/everything.png" alt=""></p><h2>Теория множеств</h2><p>Но для начала освежим в памяти теорию множеств. Если вы и так все знаете, листайте дальше, но я кончал университеты давно и хотя бы для себя распишу, что к чему.</p><p>Множество — неупорядоченная коллекция элементов. На детсадовском примере: у нас есть два яблока — это наши <em>элементы.</em> Чтобы не путаться, назовсем их яблоко вася и яблоко петя. Еще у нас есть пакетики, в которые яблоки можно класть — это <em>множества.</em> Всего есть четыре способа набрать яблок в пакет:</p><ol><li>Пакет с яблоком васей, <code>{ вася }</code> — множества пишут как элементы в фигурных скобках.</li><li>Пакет с яблоком петей, <code>{ петя }</code>, ничего нового.</li><li>Пакет с двумя яблоками, <code>{ вася, петя }</code>. В каком порядке мы их туда клали — совершенно неважно. Не хочу вас пугать, но такое множество называют <em>универсальным,</em> потому что сейчас в нашей модели мира нет ничего кроме этих двух яблок.</li><li>Еще можно вообще ничего не класть в пакет, получится <em>пустое множетсво.</em> Для него есть особый символ ∅</li></ol><p>Множества часто рисуют как диаграммы Венна — как будто все элементы разложены на плоскости, и мы обводим их кружочками:</p><p><img src="/images/ts-sets/apples.png" alt=""></p><p>Вместо того, чтобы перечислять все элементы, множество можно определить условием. Напирмер, &quot;R — множетсво красных яблок&quot; это R = { вася } (если вася — красный, а петя — белый).</p><p>Многжество A называют подмножеством B, если все элементы A входят в B. В нашем яблочном мире { вася } - подмножество { вася, петя }, но { петя } — не подмножетсво { вася }. Обратите внимание:</p><ul><li>Любое множество — подмножество самого себя</li><li>Любое множество — подмножество универсального множества</li><li>Пустое множетсво — подмножество любого множества</li></ul><p>Несколько полезных операций с множествами:</p><ul><li>Объединение <em>C = A ∪ B</em> — множетство всех элементов, котороые входят хотя бы в A или в B (свалили два пакета в один). Конечно же <em>A ∪ ∅ = A</em></li><li>Пересечение <em>C = A ∩ B</em> — все элементы из A, которые входят еще и в B. Логично, что <em>A ∩ ∅ = ∅</em></li><li>Разность <em>C = A \ B</em> — все элементы из A, которых <em>нет</em> в B. Конечно, <em>A \ ∅ = A</em></li></ul><p>Всё, этого должно хватить, чтобы разобраться в тайпскрипте. Посмотрим, как применить эти понятия к типам.</p><h2>Казалось бы, при чем тут типы?</h2><p>Итак, невероятный поворот: в принципе, <em>тип</em> — множество JavaScript значений. Подробнее:</p><ol><li>Универсальное множество — вообще все значения, которые могут появиться в JS-программе.</li><li>Тип (даже не TS-тип, просто <em>тип</em>) — какой-то набор JS-значений.</li><li>TS может описать некоторые типы, а некоторые — не может. Не верите? Попробуйте написать тип &quot;все числа, кроме 0&quot;</li><li><code>A extends B</code> из <a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" target="_blank" rel="noopener">условных типов</a> и <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints" target="_blank" rel="noopener">джинерик-констрейнов</a> можно читать как &quot;A — подмножество B&quot;.</li><li>TS-операторы <code>|</code> и <code>&amp;</code> — как раз объединение и пересечение типов как множеств.</li><li><code>Exclude&lt;A, B&gt;</code> по идее моделирует разность множеств, но этот джинерик работает не для всех A и B (вспоминаем пример с числом-кроме-0, <code>Exclude&lt;number, 0&gt;</code> не работает)</li><li><code>never</code> — пустон множество. Доказательство: для любого A <code>A &amp; never = never</code> b <code>A | never = A</code>, а <code>Exclude&lt;0, 0&gt; = never</code>.</li></ol><p>Я понимаю, что сложно сразу впустить эту идею в свою душу, так что давайте попробууем на примере.</p><h2>Булевы типы</h2><p>Сделаем вид, что в JS есть только булевы значения (я не хотел бы писать на этом). Таких значений ровно два: <code>true</code> и <code>false</code>, или, как говорил наш препод, трюэ и фалзё. Это на удивление похоже на пример с яблочками, только мы назвали их немного иначе. На булевых значениях можно составить 4 типа:</p><ul><li>Типы-литералы <code>true</code> и <code>false</code>, в каждом — по одному значению.</li><li><code>boolean</code>, тип из обоих булевых значений.</li><li>И <code>never</code> в роли пустого множества.</li></ul><p>Диаграмма получится та же, что и для яблок:</p><p><img src="/images/ts-sets/bool.png" alt=""></p><p>Теперь поупражняемся в телепортации из мира множеств в мир типов:</p><ul><li><code>boolean</code> — то же, что <code>true | false</code> (на удивление, именно так этот тип и реализован в TS)</li><li><code>true</code> — подмножество (или подтип) <code>boolean</code></li><li><code>never</code> — пустое множество, значит, <code>never</code> — подмножество типов <code>true</code>, <code>false</code> и <code>boolean</code></li><li><code>&amp;</code> — пересечение, значит, <code>false &amp; true = never</code>, <code>boolean &amp; true = { true, false } | { true } = true</code> (то есть универсальный <code>boolean</code> не влияет на пересечение), <code>true &amp; never = never</code> и так далее.</li><li><code>|</code> — объединение, значит, <code>true | never = true</code>, а <code>boolean | true = boolean</code> (то есть универсальный <code>boolean</code> &quot;проглатывает&quot; все остальные элементы объединения, потому что они уже являются его подмножествами).</li><li>И даже <code>Exclude</code> правильно вычисляет разность множеств: <code>Exclude&lt;boolean, true&gt; = false</code> (в общем случае для других типов это не так).</li></ul><p>Теперь потренируемся на extends-условиях:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">boolean</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">false</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">D</span></span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>Если вспомнить, что <code>extends</code> можно читать как &quot;является подмножеством&quot;, ответить легко — A0,B1,C1,D1. Хотя интуитивно сложно понять, как <code>never</code> может что-то экстендить. Это успех.</p><p>Типы <code>null</code> и <code>undefined</code> устроены так же, как и <code>boolean</code>, но в каждом из них всего по одному значению (или по два TS-типа с учетом <code>never</code>). <code>null &amp; boolean = null &amp; undefined = boolean &amp; undefined = never</code>, потому что одно значение никак не может быть сразу двух JS-типов (то есть базовые JS-типы — непересекающиеся множества). Нанесем всё это на нашу карту:</p><p><img src="/images/ts-sets/finites.png" alt=""></p><h2>Строки и другие примитивы</h2><p>Окей, с простыми типами разобрались, перейдем к строкам. На первый взгляд кажется, что тут всё то же самое: <code>string</code> — тип всех JS-строк, а у каждой конкретной строки есть свой литерал-тип: <code>const str: 'hi' = 'hi'</code>. Но есть один маленький нюанс — строк, в отличие от булевых значений, бесконечно много. (В память компьютера влезет только конечное количество строк? Не душните, их достаточно, чтобы перечислять все было непрактично. К тому же, системе типов негоже ограничивать себя грязным реальным миром)..</p><p>Как и множества вообще, строковые типы в TS можно определять несколькими способами:</p><ul><li>Через объединение <code>|</code> можно задать любое конечное множество (тип) строк — например, <code>type Country = 'de' | 'us'</code>. А вот бесконечное (например, все строки длиннее двух символов) — нельзя, потому что написать бесконечный список элементов довольно проблематично.</li><li>(Относительно) свежая фича TS — <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html" target="_blank" rel="noopener">шаблонные строковые типы</a> — умеет определять <em>некоторые</em> бесконечные множества — например, type V = <code>v${string}</code> — множество всех строк, которые начинаются с <code>v</code></li></ul><p>Возможные типы можно ещё немного расширить, объединяя и пересекая шаблоны и литералы. TS достаточно крут, чтобы смержить шаблон и объединение литералов: <code>'a' | 'b' &amp;</code>a${string}<code>= 'a'</code>. Ещё TS старается смержить пересечение шаблонов, но получается не всегда: <code>a${string}</code> &amp; <code>b${string}</code> — очень извращённая запись <code>never</code>, потому что строка не может одновременно начинаться и с <code>a</code>, и с <code>b</code>.</p><p>Но как бы мы ни старались, некоторые строковые типы описать в TS не выйдет. Из простого — попробуйте придумать тип для любой строки, кроме <code>&quot;a&quot;</code>&quot;. На ум приходит <code>Exclude&lt;string, 'a'&gt;</code>, но, посколько TS не моделирует тип <code>string</code> как обединение всех возможных литералов, это не сработает и в результате мы получим снова <code>string</code>. Шаблоны тоже не могут выразить этот тип.</p><p>Типы чисел, символов и бигинтов работают так же, но там даже нет шаблонов, так что мы ограничены конечными множествами. А мне бы пригодились типы &quot;целое число&quot;, &quot;число от 0 до 1&quot; или &quot;положительное число&quot;. Ну да ладно, всё вместе:</p><p><img src="/images/ts-sets/primitives.png" alt=""></p><p>Уф, примитивы обсудили! Надеюсь, мы научились переходить с языка типов на язык множеств и обратно. Заодно мы убедились, что вовсе не все типы можно записать на TS. Теперь — самое сложное.</p><h2>Интерфейсы и типы объектов</h2><p>Если вы совершенно уверены, что <code>const x: {} = 9</code> — баг TS, сейчас мы вместе убедимся что это не так. Оказывается, в этом есть логика, просто наше представление о TS-объектах (они же интерфейсы, они же Record) построено на неправильных предпосылках.</p><p>Во первых, по аналогии с примитивными типами логично предположить, что <code>type Sum9 = { sum: 9 }</code> — такой тип для &quot;объекта-литерала&quot;, в который влезет только объект <code>{ sum: 9 }</code>. Так вот, это работает совсем наоборот. Тип <code>Sum9</code> стоит читать как &quot;штучка, у которой по ключу <code>sum</code> можно достать число <code>9</code>&quot;. То есть каждый тип поля в интерфейсе — условие, которое отсекает что-то от множества &quot;штук&quot;. И обычно такой подход довольно полезен — ведь все любят пихать в функцию <code>(data: Sum9) =&gt; number</code> объекты с дополнительными свойствами вроде <code>obj = { sum: 9, date: '2022-09-13' }</code> без ругани от TS.</p><p>Значит, и <code>type O = {}</code> — не тип &quot;пустой объект&quot; для литерала <code>{}</code>, а &quot;штучка, у котороый можно получать доступ к свойствам, но в целом свойства мне не нужны&quot;. Становится понятнее, как работает наш &quot;баг&quot;: если <code>x = 9</code>, то штучка <code>x</code> уболетворяет нашему описанию в интерфейсе <code>{}</code>. Спасибо <a href="https://javascript.plainenglish.io/javascript-boxing-wrappers-5b5ff9e5f6ab" target="_blank" rel="noopener">автобоксингу,</a> можно делать даже более смелые утверждения вроде <code>const x: { toString(): string } = 9</code> — мы же можем вызвать <code>x.toString()</code> и получить строку? Можем. Все честно. А вот <code>null</code> и <code>undefined</code> в наш интерфейс не влезут, потому что у них принципиально нельзя получить никакое свойство. Не могу сказать, что это супер-интуитивно, но теперь по крайней мере логично.</p><p>Если помните, я часто путаю <code>|</code> и <code>&amp;</code>. Так вот, эти операторы действуют на типы как на &quot;множества объектов&quot;, а не на &quot;форму объектов&quot; или &quot;множества свойств&quot;. Если мне нужны объекты, у которых есть и <code>name</code>, и <code>age</code>, то нужно использовать объединение — <code>{ name: string } &amp; { age: number }</code>.</p><p>А что насчет типа <code>object</code>? Поскольку каждое свойство в интерфейсе &quot;отрезает&quot; какую-то часть значений от множества почти-всех-значений, у нас не выйдет аккуратно убрать все примитивы. И поэтому в TS есть специальный базовый тип, который как раз и обозначает &quot;JS-объект, а не примитив&quot;. Конечно, интерфейс можно пересекать с типом <code>object</code>, чтобы получить &quot;JS-объекты с нужными свойствами, но не примитивы&quot; — например, <code>object &amp; { toString(): string }</code> не содержит число <code>9</code>.</p><p>Добавим эти типы на нашу схему (почти закончили):</p><p><img src="/images/ts-sets/everything.png" alt=""></p><h2>Пара слов про extends</h2><p>Для последнего рывка нужно хорошенько разобраться с <code>extends</code>. Это слово из ООП, где тип &quot;расширяет&quot; своего родителя в смысле &quot;добавления новой функциональности&quot;, а с точки зрения множеств оно скорее путает нас — ведь <em>расширенное</em> множество в геометрическом смысле должно быть больше исходного.</p><p>Я предлагаю не зацикливаться на этом и не представлять &quot;цепочки наследования&quot;, которых тут нет. Просто читайте <code>A extends B</code> как &quot;A является подмножеством B&quot;. На примерах:</p><ul><li><code>0 | 1 extends 0</code> — ложь, потому что <code>{0, 1}</code> — не подмножество <code>{0}</code> (даже хотя <code>{0,1}</code> <em>расширяет</em> <code>{1}</code> в геометрическом смысле).</li><li><code>never extends T</code> всегда правда, потому что пустое множество <code>never</code> — подмножество любого другого множества. Какого-то здравого смысла тут нет, просто так работает модель.</li><li><code>T extends never</code> выполняется только для <code>T = never</code>, потому что у пустого множества нет подмножеств кроме себя.</li><li>В <code>T extends string</code> без проблем влезут и литерал, и шаблон, и любое их объединение, и сам <code>string</code>, потому что все они — подмножества <code>string</code>.</li><li>А вот <code>T extends string ? string extends T ?</code> проверяет, что T <em>точно совпадает</em> с типом <code>string</code>, потому что только <code>string</code> является одновременно и подмножеством, и надмножеством <code>string</code>.</li></ul><h2>unknown и any</h2><p>В TS есть не один, а целых два типа, которые моделируют произвольное JS-значение: <code>unknown</code> and <code>any</code>. В чём разница? <code>unknown</code> хорошо ложится в наше объяснение с множествами. Это универсальное множество всех JS-значений, без каких-то конкретных обещаний. Тут есть и <code>null</code>, и <code>undefined</code>, и любой объект, и число:</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// Тут будет 1</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">Y</span></span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> object <span class="token operator">|</span> bigint <span class="token operator">|</span> <span class="token builtin">symbol</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// Покороче, с учетом странностей {}</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">Y2</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><br><span class="token comment">// Для всех остальных типов тут будет 0:</span><br><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">N</span></span> <span class="token operator">=</span> <span class="token builtin">unknown</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>Хотя есть и странность. <code>unknown</code> <em>не</em> реализован как объединение всех базовых типов, так что сделать <code>Exclude&lt;unknown, string&gt;</code> не выйдет. <code>unknown extends string | number | boolean | object | bigint | symbol | null | undefined</code> не выполняется, из чего теоретически следует что в JS бывают ещё какие-то другие значения (это не так). Ну, что делать, деталь реализации.</p><p>А вот <code>any</code> с точки зрения типов-множеств ведет себя странно:</p><ul><li><code>any extends string ? 1 : 0</code> возвращает <code>0 | 1</code>, то есть &quot;не знаю&quot;.</li><li>И даже <code>any extends never ? 1 : 0</code> возвращает <code>0 | 1</code>, то есть <code>any</code> может быть и пустым множеством.</li></ul><p>Из этого можно было бы заключить, что <code>any</code> — &quot;какое-то множество, но мы не знаем, какое&quot; — вроде <code>NaN</code> в мире типов. Но эта гипотеза ломается о то, что на вопросы <code>string extends any</code>, <code>unknown extends any</code> и даже <code>any extends any</code> TS уверенно отвечает &quot;да&quot; вместо &quot;не знаю&quot;. Так что <code>any</code> — парадокс множеств, и анализировать его с этой точки зрения бессмысленно.Единственная хорошая новость — <code>any extends unknown</code>, так что в <code>any</code> не входит никаких &quot;чудо-значений&quot;, и <code>unknown</code> — все еще все JS-значения.</p><p>Закончим нашу великолепную карту типов, завернув её в <code>unknown</code>, и добавим <code>any</code> в роли перста Божьего:</p><p><img src="/images/ts-sets/all.png" alt=""></p><hr><p>Сегодня мы узнали, что типы TS — просто множества JS-значений. Вот небольшой множество-типовой разговорник:</p><ul><li><code>unknown</code> — универсальное множество (все JS-значения)</li><li><code>never</code> — пустое множество</li><li><code>A extends B</code> — А является подмножеством B</li><li><code>|</code> — объединение множеств, <code>&amp;</code> — пересечение</li><li><code>Exclude</code> — непереводимый фольклор, примерно соответствующий разности множеств.</li></ul><p>С этими новыми знаниями вернемся к моим вопросам:</p><ul><li><p>Если мне нужен объект, который реализует и <code>{ name: string }</code>, и <code>{ age: number }</code>, нужно эти типы <code>&amp;</code> (пересечь) или <code>|</code> (объединить)? В каждом вариатне можно найти логику, потому что я хочу левое <em>и</em> правое, но, с другой стороны, мне нужно <em>объединение</em> интерфейсов.</p></li><li><p>Сработает ли <code>type &lt;T&gt; = T extends string ? ...</code>, если <code>T</code> — юнион строк, вроде <code>'ru' | 'de'</code>?</p></li><li><p>В чем разница межу <code>any</code> и <code>unknown</code>? Лучшее предложение интернета — дурацкие мнемоники типа &quot;Avoid Any, Use Unknown&quot;. Братан, а что не так с <code>any</code>?</p></li><li><p>А <code>never</code> — что за тип? &quot;never по-английски значит НИКОГДА, и это значение НИКОГДА не должно появляться в вашей программе&quot; звучит очень драматично, но не помогает проникнуть в сусть вещей.</p></li><li><p>Если <code>never</code> это какой-то взрыв, то почему я могу <code>const x: number = y as never</code>? И почему <code>never extends X</code> всегда выполняется?</p></li><li><p>К слову, почему <code>whatever | never === whatever</code>, а <code>whatever &amp; never === never</code>?</p></li><li><p><code>const x: {} = true;</code> — правильно типизиорованный код. Ну как это вообще, а? <code>true</code> точно не пустой объект.</p></li><li><p><code>object</code> — это для лентяев, которые не могут перечислить свойства, или что-то вроде <code>any</code>?</p></li><li><p><code>0 | 1 extends 0</code> is false because <em>{0,1}</em> is <em>not</em> a subset of <em>{0}</em></p></li><li><p><code>&amp;</code> and <code>|</code> work on sets, not on object shapes. <code>A &amp; B</code> is a set of things that satisfy both <code>A</code> and <code>B</code>.</p></li><li><p><code>unknown</code> is the set of all JS values. <code>any</code> is a paradoxical set that includes everything, but <em>might</em> also be empty.</p></li><li><p>Intersecting with <code>never</code> gives you <code>never</code> because it's an empty set. <code>never</code> has no effect in a union.</p></li><li><p><code>const x: {} = true;</code> works because TS interfaces work by <em>constraining</em> the property values, and we haven't constrained anything here, so <code>true</code> fits.</p></li></ul><p>We still have a lot of TS mysteries to solve, so stay tuned!</p>