<p>In the world of JS libraries, <a href="https://github.com/lodash/lodash" target="_blank" rel="noopener">lodash</a> is a champion.</p><p><img src="/images/lodash-popularity.png" alt="Lodash"></p><p>https://npmtrends.com/@babel/core-vs-express-vs-lodash-vs-ramda-vs-react</p><p>But in 2023, I can't recommend new projects to</p><h2>Issues with lodash</h2><h3>Size issues</h3><h3>Conservatie browser target</h3><h3>Excessive polymorphism</h3><h2>Alternatives</h2><h3>Built-in ES methods</h3><p>Lodash has, incredibly, over 300 helpers. It's been around since 2012, and has been <em>very</em> conservative about removing features, so many, naturally, come built-in with modern ES standards.</p><ul><li>Most array methods are in the core, with very similar names:<ul><li><code>_.compact(arr) -&gt; arr.filter(Boolean)</code></li><li><code>_.concat(arr, arr2) -&gt; arr.concat(arr2)</code></li><li><code>_.difference(arr, arr2) -&gt; arr.filter(x =&gt; !arr2.includes(x))</code></li><li><code>_.drop(arr, 5) -&gt; arr.slice(5)</code></li><li><code>_.dropRight(arr, 5) -&gt; arr.slice(0, -5)</code></li><li><code>_.fill(arr, 'x') -&gt; arr.fill('x')</code></li><li><code>_.findIndex(arr, x =&gt; x &gt; 2) -&gt; arr.findIndex(x =&gt; x &gt; 2)</code></li><li><code>_.findLastIndex(arr, x =&gt; x &gt; 2) -&gt; arr.findLastIndex(x =&gt; x &gt; 2)</code></li><li><code>_.flatten(arr) -&gt; [].concat(...arr)</code></li><li><code>_.fromPairs([['key', 'value']]) -&gt; Object.fromEntries([['key', 'value']])</code></li><li><code>_.head(arr) -&gt; arr[0]</code></li><li><code>_.indexOf(arr, item) -&gt; arr.indexOf(item)</code></li><li><code>_.initial(arr) -&gt; arr.slice(0, -1)</code></li><li><code>_.difference(arr, arr2) -&gt; arr.filter(x =&gt; arr2.includes(x))</code></li><li><code>_.join(arr, ', ') -&gt; arr.join(', ')</code></li><li><code>_.last(arr) -&gt; arr.at(-1)</code></li><li><code>_.lastIndexOf(arr, item) -&gt; arr.lastIndexOf(item)</code></li><li><code>_.nth(arr, 10) -&gt; arr.at(10)</code></li><li><code>_.reverse(arr) -&gt; arr.reverse()</code></li><li><code>_.slice(arr, 1, 3) -&gt; arr.slice(1, 3)</code></li><li><code>_.tail(arr) -&gt; arr.slice(1)</code></li><li><code>_.take(arr, count) -&gt; arr.slice(0, count)</code></li><li><code>_.takeRight(arr, count) -&gt; arr.slice(-count)</code></li><li><code>_.union(arr1, arr2) -&gt; [...new Set([...arr1, ...arr2])]</code></li><li><code>_.uniq(arr) -&gt; [...new Set(arr)]</code></li></ul></li><li>Many object methods are easy using static <code>Object</code> methods:<ul><li><code>_.assign(obj2, obj2) -&gt; Object.assign(obj1, obj2)</code> or even <code>{ ...obj1, ...obj2 }</code> if you don't want to mutate.</li><li><code>_.create -&gt; Object.create</code></li><li><code>_.defaults(obj, def) -&gt; obj = { ...def, ...obj }</code></li><li><code>_.entries(obj) -&gt; Object.entries(obj)</code></li><li><code>_.findKey(obj, pred) -&gt; Object.entries(obj).find(pred)?.[0]</code></li><li><code>_.invert -&gt; Object.fromEntries(Object.entries(obj).map(([k, v]) =&gt; [v, k]))</code></li><li><code>_.keys(obj) -&gt; Object.keys(obj)</code></li><li><code>_.mapKeys(obj, map) -&gt; Object.fromEntries(Object.entries(obj).map(([k, v]) =&gt; [map(k), v]))</code></li><li><code>_.mapValues(obj, map) -&gt; Object.fromEntries(Object.entries(obj).map(([k, v]) =&gt; [k, map(v)]))</code></li><li><code>_.transform(obj, reducer, acc) -&gt; Object.entries(obj).reduce(reducer, acc)</code></li><li><code>_.values(obj) -&gt; Object.values(obj)</code></li></ul></li></ul><p>Most useful string helpers are built-in, as well. Now, there still are a few categories that haven't been covered by the ES evolution. Lodash function module still includes very useful helpers like <code>once, memoize, debounce, throttle</code>. Lodash also supports</p><p>You can also argue that lodash offers better performance by avoiding intermediate objects. This is a controversial claim, but the main thing here is that you are not likely to deal with object big enough for any performance difference to become noticeable. One actually <em>good</em> argument in favor of lodash is that it offers a higher-level API that makes it clear what you're trying doing without getting lost in the implementation details.</p><p>Whatever reasons you have to cling onto lodash, I have not <em>one,</em> but <em>five</em> excellent libraries that</p><h3>Alternative libraries</h3><p>Of course,</p><p><a href="https://github.com/remeda/remeda" target="_blank" rel="noopener">remeda</a> and <a href="https://github.com/selfrefactor/rambda" target="_blank" rel="noopener">rambda</a> are two utility libraries heavily influenced by ramda. In the same family, we have <a href="https://github.com/Tinkoff/utils.js" target="_blank" rel="noopener">@tinkoff/utils</a> â€” 173 helpers, 1 import per helper. Conservative browser target.</p><p><a href="https://github.com/angus-c/just" target="_blank" rel="noopener">just</a> is a family of 82 libraries that cover most of your needs, and are <em>extremely</em> lightweight.</p><p>Finally, <a href="https://github.com/marpple/FxTS" target="_blank" rel="noopener">@fxts/core</a> contains 96 helpers in a tree-shakable package. Lazy evaluation support.</p><p>The libraries offer similar feature sets</p><ul><li>just is published as a set of separate libraries</li><li>tinkoff requires you to import</li></ul><p>All the libraries are well-tested.</p><p>These libraries are, of course, <a href="https://npmtrends.com/@fxts/core-vs-@tinkoff/utils-vs-just-debounce-it-vs-lodash-vs-rambda-vs-remeda" target="_blank" rel="noopener">dwarfed</a> in comparison to lodash, but they are by no means obscure. Let me put things into perspective by comparing these to sell-known UI frameworks (as of 2023):</p><ul><li>rambda is the most popular of the bunch, and has roughly the same downloads as svelte, quite a popular framework.</li><li>remeda and just (even though it's hard to measure given the separate packages) are <a href="https://npmtrends.com/alpinejs-vs-just-debounce-it-vs-remeda-vs-stimulus" target="_blank" rel="noopener">roughly on the order of alipine and stimulus,</a> solid production-grade choices.</li><li><code>@tinkoff/utils</code> and <code>@fxts/core</code> seem like outliers even it this league, at 100x fewer installs. I'm pretty confident about tinkoff utils, given that it powers one of Russia's largest banks. Fxts is the least mature library of the bunch (it's at <code>v0.13</code>), but still good to keep an eye on.</li></ul><hr>