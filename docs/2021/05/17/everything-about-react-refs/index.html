<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta property="og:type" content="article"><meta property="og:title" content="So you think you know everything about React refs"><meta property="og:url" content="https://blog.thoughtspile.tech/2021/05/17/everything-about-react-refs/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/react-ref-order.png"><meta property="article:published_time" content="2021-05-17T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="react"><meta property="article:tag" content="programming"><meta property="article:tag" content="frontend"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/react-ref-order.png"><title>So you think you know everything about React refs</title><link rel="stylesheet" href="/css/style.css"><link rel="canonical" href="https://blog.thoughtspile.tech/2021/05/17/everything-about-react-refs/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">So you think you know everything about React refs</h1></header><div class="content" itemprop="articleBody"><p>React <a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">refs</a> appear to be a very simple feature. You pass a special prop to a DOM component, and you can access <em>the current DOM node</em> for that component in your JS. This is one of those great APIs that work just the way you'd expect, so you don't even think about how, exactly, it happens. Along my descent into React internals I started noticing that there was more to the ref API than I always thought. I dug deeper, and in this post I'll share my findings with you and provide a few neat ref tricks to help you write better code.</p><h2>How react refs are set</h2><p>To get the basics out of the way, <code>ref</code> is set to the DOM node when it's mounted, and set to null when the DOM node is removed. No surprises this far.</p><p>One thing to note here is that a ref is, strictly speaking, never <em>updated.</em> If a DOM node is replaced by some other node (say, its DOM tag or <code>key</code> changes), the ref is <em>unset,</em> and then set to a new node. (You may think I'm being picky here, but it's goint to prove useful in a minute.) The following code would log <code>null -&gt; &lt;div&gt;</code> on rerender (also see <a target="_blank" href="https://codesandbox.io/s/stoic-tereshkova-h51o2?file=/src/App.js" rel="noopener">sandbox</a>):</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"ref"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token punctuation">[</span>iter<span class="token punctuation">,</span> rerender<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token punctuation">(</span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span></span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>iter<span class="token punctuation">}</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">rerender</span><span class="token punctuation">(</span>iter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>    click to remount<br>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The part I was not aware of is that the identity of <code>ref</code> prop also forces it to update. When a <code>ref</code> prop is added, it's set to DOM node. When a <code>ref</code> prop is removed, the old ref is set to null. Here, again, the ref is unset, than set again. This means that if you pass an inline arrow as a <code>ref</code>, it'll go through <em>unset / set</em> cycle on every render (<a href="https://codesandbox.io/s/reverent-stallman-swv7q?file=/src/App.js" target="_blank" rel="noopener">sandbox</a>):</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> rerender <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token punctuation">(</span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"ref"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">rerender</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>    click to remount<br>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>So, why does it work that way? In short, it allows you to attach <code>refs</code> conditionally and even swap them between components, as in</p><pre class="language-jsx"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text"><br>  </span><span class="token punctuation">{</span>items<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><br>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>i <span class="token operator">===</span> items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> lastRef <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>e<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text"><br>  ))}<br></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text"></span></code></pre><p>So far we've leant that refs are <em>set</em> node when the DOM mounts <em>or</em> when the ref prop is added, and <em>unset</em> when the DOM unmounts <em>or</em> the ref prop is removed. As far as I'm concerned, nothing else causes a ref to update. A changing ref always goes through <code>null</code>. If you're fluent in hooks, it works as if the code for DOM components had:</p><pre class="language-jsx"><code class="language-jsx"><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    ref<span class="token punctuation">.</span>current <span class="token operator">=</span> domNode<span class="token punctuation">;</span><br>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> ref<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ref<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2>Ref update ordering</h2><p>Another important principle specifies the order in which refs are set and unset. The part we rely on the most is that the ref is always set <em>before</em> <code>useLayoutEffect / componentDidMount / Update</code> for the corresponing DOM update is called. This, in turn, means that <code>useEffect</code> and parent <code>useLayoutEffect</code> are also called after the ref is set.</p><p>In a single render, all the ref <em>unsets</em> happen before any <em>set</em> — otherwise, you'd get a chance to unset a ref that's already been set during this render.</p><p>Next, <code>useLayoutEffect</code> cleanup during re-rendering runs right between ref unset and set, meaning that <code>ref.current</code> is always <code>null</code> there. To be honest, I'm not sure why it works this way, as it's a prime way to shoot yourself in the foot, but this seems to be the case for all react versions with hooks. <a href="https://codesandbox.io/s/polished-sunset-fbs6q?file=/src/App.js" target="_blank" rel="noopener">See for yourself</a>.</p><p>In contrast, <code>componentWillUnmount</code> and unmount <code>useLayoutEffect()</code> cleanup are called <em>before</em> the ref is unset, so that you get a chance to cleanup anything you've attached to the DOM node, as you can see in a <a href="https://codesandbox.io/s/determined-hamilton-05t27?file=/src/App.js" target="_blank" rel="noopener">sandbox</a>.</p><p>Here's a chart that summarizes all this timing:</p><p><img src="/images/react-ref-order.png" alt=""></p><p>Now I feel like we're getting somewhere in our understanding of <code>refs</code> — but does it have any practical value? Read on!</p><h2>Don't use ref.current in useLayoutEffect cleanup</h2><p>First off — using dynamic refs in <code>useLayoutEffect</code> cleanup callback is unsafe since you can get an unexpected <code>null</code>. Store <code>ref.current</code> in a closure variable and use that instead:</p><pre class="language-jsx"><code class="language-jsx"><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">.</span> <span class="token punctuation">[</span>onClick<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// becomes...</span><br><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> node <span class="token operator">=</span> ref<span class="token punctuation">.</span>current<br>  node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> node<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">.</span> <span class="token punctuation">[</span>onClick<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Granted, this only works for arrow refs or when you attach a ref conditionaly, but better safe than sorry, right? At least it's good to know exactly why this breaks and not wrap everything in <code>if (ref.current)</code> just in case.</p><h2>You can side effect in ref callback</h2><p>A cool and useful implication of this is that you can safely put expensive side effects in a callback ref (or a <code>set current()</code> of a ref object) as long as ref identity does not change. For example, a typical DOM measuring logic:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token punctuation">[</span>size<span class="token punctuation">,</span> setSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">setSize</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>el<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span></code></pre><p>Becomes...</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>size<span class="token punctuation">,</span> setSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> measureRef <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token parameter">node</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">setSize</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>measureRef<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span></code></pre><p>Which is slightly cleaner and has one variable less.</p><h2>Ref arrows</h2><p>There's a subtle difference between having an arrow as your <code>ref</code> prop and a ref object or a stable callback — the arrow has a new identity on every render, forcing the ref to go through an update cycle <code>null</code>. This is normally not too bad, but good to know.</p><pre class="language-jsx"><code class="language-jsx"><span class="token comment">// this does node -> null -> node on every render</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span>node <span class="token operator">=</span> e<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><br><span class="token comment">// this doesn't</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span>node <span class="token operator">=</span> e<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><br><span class="token comment">// neither does this</span><br><span class="token function-variable function">setRef</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span>node <span class="token operator">=</span> e<span class="token punctuation">;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>setRef<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><br><span class="token comment">// this is fine, too</span><br><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre><h2>setState can be a callback ref</h2><p>If you want setting ref to trigger a rerender, you can just pass <code>setState</code> updater as a ref prop. This code will give <code>children</code> access to root DOM node, and will not fall into infinite re-rendering or anything:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>root<span class="token punctuation">,</span> setRoot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token punctuation">(</span><br>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>setRoot<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RootContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> root<span class="token punctuation">,</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>            </span><span class="token punctuation">{</span>root <span class="token operator">?</span> children <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token plain-text"><br>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RootContext.Provider</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><br><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2>Merging refs is hard</h2><p>Finally, if you implement some kind of ref merging (when you have a <code>forwardRef</code> / <code>innerRef</code>, but also need te DOM node for yourself), you should take care to preserve the guarantees native ref provides, because they are there for a reason. Almost all ref merging mechanisms I've seen in the wild miss some points we've discussed today. The web is full of tutorials that offer you subtly broken solutions. A library with 22K stars <a href="https://github.com/streamich/react-use/blob/master/src/useEnsuredForwardedRef.ts" target="_blank" rel="noopener">fails to do it right.</a> Here's <a href="https://github.com/VKCOM/VKUI/blob/master/src/hooks/useExternRef.ts" target="_blank" rel="noopener">my best shot</a> at this problem, and I'm still not sure it ticks all the boxes:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">useExternRef</span><span class="token punctuation">(</span><span class="token parameter">externRef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> stableRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><br>    <span class="token keyword">get</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">return</span> stableRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token keyword">set</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      stableRef<span class="token punctuation">.</span>current <span class="token operator">=</span> el<span class="token punctuation">;</span><br>      <span class="token function">setRef</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> externRef<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>externRef<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Knowing this, I wouldn't be comfortable with any advanced ref patterns (conditional refs / side effects) on non-DOM components.</p><hr><p>Now on to a brief recap:</p><ul><li>Refs are set when the DOM is mounted or a <code>ref</code> prop is added.</li><li>Refs are unset when the DOM is removed or a <code>ref</code> prop is removed.</li><li>Refs are always unset, then set, and never switch between two nodes directly.</li><li>It's safe to use <code>refs</code> conditionaly and even move them between nodes.</li><li>The order in which refs are set and unset relative to <code>useLayoutEffect</code> and lifecycle hooks is well defined.</li><li>Callback ref can be a side effect or a <code>useState</code> setter</li><li>Useing <code>ref.current</code> in <code>useLayoutEffect</code> cleanup is unsafe.</li><li>Merging refs is hard, so take care yourself and don't trust the <code>ref</code> prop in components you didn't write.</li></ul><p>Phew. Now I think we really know everything about react refs.</p></div><span class="share"><div><a href="https://twitter.com/share?url=&text= by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2021/05/17/everything-about-react-refs/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/react" rel="tag">react</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a> <a class="tag-link-link" href="/tags/frontend" rel="tag">frontend</a> <a class="tag-link-link" href="/tags/hooks" rel="tag">hooks</a></div><div class="post-actions">Written in <time>2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank" rel="noopener">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" href="https://buymeacoffee.com/thoughtspile" target="_blank" rel="noopener">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/04/07/better-usecallback/"><div class="post-siblings__direction">Older</div><span class="link__text">Did I just build a better useCallback?</span> </a><a class="link--bare" href="/2021/05/31/moar-coverage/"><div class="post-siblings__direction">Newer</div><span class="link__text">How to increase test coverage FAST</span></a></div></article><script async src="/js/share.js"></script></div></body></html>