<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta name="color-scheme" content="dark light"><meta property="og:type" content="article"><meta property="og:title" content="SemVer: The Tricky Parts"><meta property="og:url" content="https://blog.thoughtspile.tech/2021/11/08/semver-challenges/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/semver.jpg"><meta property="og:image" content="https://blog.thoughtspile.tech/images/bmc.png"><meta property="article:published_time" content="2021-11-08T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="open source"><meta property="article:tag" content="programming"><meta property="article:tag" content="javascript"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/semver.jpg"><title>SemVer: The Tricky Parts</title><link rel="stylesheet" href="/css/style.css?ts=1676310823156"><link rel="canonical" href="https://blog.thoughtspile.tech/2021/11/08/semver-challenges/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">SemVer: The Tricky Parts</h1><div class="post__date">Written in <time>2021</time></div></header><div class="content" itemprop="articleBody"><p>Semantic versioning, is the way to version packages in JS ecosystem. I always thought I understood semver, but that illusion disappeared once I started maintaining libraries myself. Semver has tricky edge cases where it's unclear what the new version number should be:</p><ul><li>Should you bump anything after a refactoring? Can you have a refactor-only release at all?</li><li>What's the new version after updating a dependency? (spoiler: it <em>depends</em>)</li><li>Is dropping IE11 support a minor or major?</li><li>Is fixing a bug always a patch-level change? (Spoiler: no)</li><li>Does rewording &quot;support multi-line content in button&quot; to &quot;fix multi-line button&quot; turn a minor into a patch?</li><li>What if a bug can't be fixed without a breaking change?</li></ul><p>In this post, I'll explore these problems in depth, and share my tips on handling them.</p><p><img src="/images/semver.jpg" alt=""></p><h2>A quick intro to SemVer</h2><p>A Semanic Version, or semver, has a format of <code>major.minor.patch-(maybe) prerelease</code> — three numbers and some gibberish after a dash that we'll ignore for today. As <a href="https://semver.org/" target="_blank" rel="noopener">the semver spec</a> explains it:</p><ul><li>MAJOR makes incompatible API changes,</li><li>MINOR adds functionality in a backwards compatible manner, and</li><li>PATCH makes backwards compatible bug fixes.</li></ul><p>The trick is, SemVer talks about the public API of your package, and the concept of <em>API</em> is a bit fuzzy, so it's not really as strict as you'd expect.</p><p>In product front-end development, life is simple. Your product has no public API, no other code depends on it, so you don't really care. Three-number semver format is still useful, since many node tools support it, but you can do whatever you like with the numbers. Using a single number, incrementing it on every build, is just fine: <code>0.0.123 -&gt; 0.0.124</code>, why not. Classic git flow works well with two numbers: minor for releases, patch for hotfixes: <code>1.1.0 -&gt; 1.2.0</code>, then <code>1.2.1</code> if you fix a bug. You can also increment the major version to congratulate yourself on a particularly big feature: <code>1.2.0 -&gt; 2.0.0</code> = <em>well done, Vladimir.</em> Really, anything works.</p><p>Once your code becomes a library (and I expect this to happen more often as micro-frontends grow), you need a way to communicate the API compatibility of your new releases to consumers. You need real semver, and you have two conflicting goals. First, you must follow the <em>semantic</em> part of semver to tell the consumers if they can safely update. This also helps package managers decide if a particular version can be reused between several consumers, or must be duplicated. <em>But</em> you also want to increment the version as slowly as possible — frequent breaking changes and even large minor increments are scary for your consumers, and may lead to duplicate versions of your library in the final app.</p><h2>SemVer no-ops</h2><p>Sometimes you haven't really done anything visible from the outside, but still want to release. Refactorings, performance improvements, documentation changes fall in this category. In all these cases, I usually go with a patch update, because:</p><ul><li>Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version — <a href="https://semver.org/#spec-item-3" target="_blank" rel="noopener">semver spec says so.</a></li><li>It's hard to re-release a version with the same number anyways.</li><li>It provides a way to identify the version if you created some new bugs.</li></ul><p>On the other hand, <a href="https://semver.org/#spec-item-7" target="_blank" rel="noopener">spec p. 7</a> allows you to bump minor for <em>&quot;substantial new functionality or improvements are introduced within the private code&quot;</em> but come figure what <em>substantial</em> means. Anyways, see an <a href="https://github.com/semver/semver/issues/146" target="_blank" rel="noopener">official discussion</a>.</p><h2>Changelog</h2><p>SemVer is useless without a changelog: have a breaking change? Amazing, but what is it and what should your users do about it? Good places to maintain the changelog are <a href="https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository" target="_blank" rel="noopener">GitHub releases,</a>, <code>CHANGELOG.md</code>, confluence / dropbox paper / whatever for internal projects, a dedicated page in the docs, or even a pinned message in the support chat. Just make sure all your users know where to look for it.</p><h2>Releases with multiple changes</h2><p>This one is clear, but keep an eye out: if you release changes in batches, the new version must be the largest of versions from each change. Some examples of a release after <code>1.2.3</code>:</p><ul><li>3 bug fixes = patch, <code>1.2.4</code></li><li>3 bug fixes + 1 feature = minor, <code>1.3.0</code></li><li>3 bug fixes + 1 breaking change = major, <code>2.0.0</code></li><li>1 feature + 1 breaking change = major, <code>2.0.0</code></li></ul><p>If you have a patch release planned, but add a feature to it, don't forget to change it to a minor release, etc.</p><h2>Breaking bug fixes</h2><p>Say you release a buggy <code>1.2.3</code> — a dropdown component calls <code>onClose</code> on open. Strictly speaking, if you now stop calling <code>onClose</code> on open, you must release <code>2.0.0</code>, because it's a breaking change — your fix breaks apps that rely on <code>onClose</code> firing on open. On the other hand, a major release is likely to confuse everyone and scare them away from updating, so you should prefer <code>1.2.4</code>. There's no hard rule for situations like this, use your best judgement to decide if you can get away releasing the patch. Some things to consider:</p><ul><li>Can you know for sure if anyone actually relies on the broken behavior? Maybe search the codebase for internal projects, or ask around.</li><li>Does the broken behavior make no sense or contradict the documentation?</li><li>Has the bug been there for a long time? If you've been calling <code>onClose</code> on open for 2 years, since <code>0.0.1</code>, some users may well rely on it, especially if you didn't have an <code>onOpen</code>. If you just released it 5 minutes ago, just patch and deprecate the broken version ASAP.</li><li>Can you support <em>both</em> the broken and the fixed versions? This is often the case for typos, like <code>onColse -&gt; onClose</code>. If you can — go with it, <a href="/2021/09/22/dev-warnings/">warn</a> on the old name and don't forget to remove it in the next major release.</li></ul><p>If you do release the breaking bufix as a patch, consider deprecating the broken version <a href="https://docs.npmjs.com/deprecating-and-undeprecating-packages-or-package-versions" target="_blank" rel="noopener">via npm,</a> mentioning it in the changelog and notifying your users in the support chat / twitter.</p><h2>Feature-like bug fixes</h2><p><em>Bug fix</em> in semver terms is loosely related to normal person's idea of bug vs feature. Sometimes you can't fix a bug in the current API. In this case, <em>fixing</em> it is a <em>feature,</em> so you must release a <em>minor.</em></p><p>For example, your button component looks bad when you pass multi-line content. If you edit some CSS or adjust the display based on <code>offsetHeight</code>, it's a patch. If you add a special <code>multiline</code> option that users should pass for multiline content, you've just implemented a feature — <em>support multi-line content in buttons,</em> so a <em>minor.</em></p><h2>Feature vs Enhancement</h2><p>The <a href="https://stackoverflow.com/questions/27572557/scrum-terminology-what-is-the-difference-between-a-new-feature-and-an-enhanceme" target="_blank" rel="noopener">feature / enhancement distinction</a> happens to be much more practical in SemVer. Say, you improve the positioning of a dropdown so that it detects scroll overflow and automatically chooses the up / down direction. Is it a bug fix, because the old behavior was <em>incorrect,</em> or a feature, because now your library does something it didn't do before?</p><p>I usually go for a feature (<em>minor</em> increment) in these cases, because a <em>patch</em> seems confusing, and a <em>major</em> is scary, but you can choose a different path. Some PRs to semver spec (<a href="https://github.com/semver/semver/pull/415" target="_blank" rel="noopener">#415</a> or <a href="https://github.com/semver/semver/pull/588" target="_blank" rel="noopener">#588</a>) allow you to make such changes in a patch, since it does not affect the API.</p><h2>Type updates</h2><p>Obviously, if your library has a TypeScript / Flow / whatever interface, any change to the interface type should be reflected in the version number. A type-only change, like exporting an interface that was internal, is a feature that deserves a minor bump.</p><h2>Dependency updates</h2><p>What should the new version of your package be if you update a package B you depend on? Summary of the <a href="https://github.com/semver/semver/issues/148" target="_blank" rel="noopener">official discussion:</a></p><ul><li>If your library completely wraps the dependency and your users can't interact with package B, ignore it and version as per <em>your</em> change.</li><li>If your library exposes the underlying package B by letting the users access its objects or passing through user options, find out if the minor / breaking changes in B affects the <em>exact part</em> you expose. A safe &amp; lazy option is to match your major / minor / patch update to the update in B.</li><li>Updating a <em>peer</em> dependency (like <code>React</code>), requires the users of your lib to also update that dependency, so it's breaking.</li><li>Updating a <em>dev</em> dependency is usually a no-op. Caveat: <em>if</em> you update TypeScript <em>and</em> use some new features in your public types, it's essentially a <em>peer</em> dep update, so breaking.</li></ul><p>I often see libraries update deps in a minor. I'd rather not do that, but I'm not completely against it, as long as the update path for package B is safe. Updating peer major in a minor release is pure evil, though.</p><h2>Compatibility changes</h2><p>Most libraries increase the major version when dropping runtime support. If your library runs in IE11, but then you add an unpolyfilled <code>.closest</code>, it's a breaking change because it may <em>break</em> some apps that were supposed to run in IE11. <em>Increasing</em> runtime compatibility (like adding a polyfill) is a no-op. The key here is the public compatibility guarantees you give — if you say &quot;runs in IE11&quot; in your docs, it's your API now, and dropping it is breaking. If you never promised IE11, you can argue that it just <em>happens</em> to work as an implementation detail and ignore it in your versioning.</p><hr><p>Here are my 10 semver lessons from 2 years of open-source work:</p><ol><li>Internal changes, like optimizations and refactorings, get either a <em>patch</em> bump or a <em>minor</em> bump if they're <em>substantial,</em> whatever that means.</li><li>Semver is useless without a good changelog detailing the chagnes.</li><li>Bump the highest component in releases with multiple changes: <em>bug fix + feature = minor.</em></li><li>A breaking change in a patch may be OK if it fixes a bug, and users are unlikely to depend on the broken behavior.</li><li><em>Features</em> don't change the API can fit into a <em>patch.</em></li><li>If a <em>bug fix</em> touches the API, it's a <em>feature,</em> so it gets a <em>minor</em> bump.</li><li>Your public types affect semver, too.</li><li>Updating dependencies affects your version as much as you expose their API.</li><li>Updating peer dependencies is <em>breaking.</em></li><li>Dropping browser / runtime compatibility is <em>breaking.</em></li></ol></div><span class="share"><div><a href="https://twitter.com/share?url=https://blog.thoughtspile.tech/2021/11/08/semver-challenges/&text=SemVer: The Tricky Parts by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2021/11/08/semver-challenges/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="social-links"><a href="https://twitter.com/thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="https://mastodon.online/@thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a><a href="https://www.linkedin.com/in/vklepov/" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="/atom.xml" class="link--bare" target="_blank"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="rss" class="svg-inline--fa fa-rss fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM128 416c0 35.3-28.7 64-64 64s-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a></div><a href="https://buymeacoffee.com/thoughtspile" class="link--bare bmc-card" target="_blank" rel="noopener"><div><b>Hello, friend!</b> My name is Vladimir, and I love writing about web development. If you got down here, you probably enjoyed this article. My goal is to become an independent content creator, and you'll help me get there by <span class="bmc">buying me a coffee!</span></div><img src="/images/bmc.png" class="bmc-image"></a><div class="post-related"><div class="post-sibling"><span class="post-siblings__direction">More?</span> <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/open source" rel="tag">open source</a> <a class="tag-link-link" href="/tags/programming" rel="tag">programming</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a></div><a class="link--bare post-sibling" href="/2021/10/27/better-react-context/"><span class="post-siblings__direction">Older?</span> <span class="link__text">Why I always wrap Context.Provider and useContext</span> </a><a class="link--bare post-sibling" href="/2021/11/15/unintentional-layout-effect/"><span class="post-siblings__direction">Newer?</span> <span class="link__text">useEffect sometimes fires before paint</span></a></div></article><script async src="/js/share.js"></script></div></body></html>