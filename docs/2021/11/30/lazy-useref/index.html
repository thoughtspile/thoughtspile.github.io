<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta name="color-scheme" content="dark light"><meta property="og:type" content="article"><meta property="og:title" content="Make useRef lazy — 4 ways"><meta property="og:url" content="https://blog.thoughtspile.tech/2021/11/30/lazy-useref/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/lazy-useref-sofa.jpg"><meta property="article:published_time" content="2021-11-30T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="react"><meta property="article:tag" content="javascript"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/lazy-useref-sofa.jpg"><title>Make useRef lazy — 4 ways</title><link rel="stylesheet" href="/css/style.css?ts=1683654986339"><link rel="canonical" href="https://blog.thoughtspile.tech/2021/11/30/lazy-useref/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Make useRef lazy — 4 ways</h1><div class="post__date">Written in <time>2021</time></div></header><div class="content" itemprop="articleBody"><p>I love <code>useRef</code>, but it lacks the lazy initializer functionality found in other hooks (<code>useState</code> / <code>useReducer</code> / <code>useMemo</code>). <code>useRef({ x: 0, y: 0 })</code> creates an object <code>{ x: 0, y: 0 }</code> on every render, but only uses it when mounting — it subsequent renders it's thrown away. With <code>useState</code>, we can replace the initial <em>value</em> with an <em>initializer</em> that's only called on first render — <code>useState(() =&gt; ({ x: 0, y: 0 }))</code> (I've explored this and other <code>useState</code> features in my <a href="/2021/09/27/usestate-tricks/">older post</a>). Creating functions is very cheap in modern JS runtimes, so we skip allocating memory and building the object for a slight performance boost (see <a href="https://jsbench.me/p3kwj6ojfs" target="_blank" rel="noopener">benchmark</a>).</p><p>I'm not super excited about doing useless work, and <code>useRef</code> is your primary tool for <a href="/2021/10/18/non-react-state/">avoiding useless re-renders.</a> In this post, I'll show you four ways to support lazy initializer in <code>useRef</code>:</p><ol><li>Move initialization to <code>useEffect</code></li><li>Sync lazy <code>useRef</code> initializer that works like <code>useState</code> initializer.</li><li>Lazy <code>useRef</code> on top of <code>useState</code> (almost zero code!)</li><li>A <code>useRef</code> that only computes the value when you read <code>.current</code></li></ol><p><img src="/images/lazy-useref-sofa.jpg" alt=""></p><h2>Use cases</h2><p>Any ref that involves an object can benefit from lazy initialization. I use such refs a lot for <a href="/2021/10/18/non-react-state/">tracking gestures:</a></p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> touch <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token function-variable function">onTouchMove</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  touch<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">x</span><span class="token operator">:</span> e<span class="token punctuation">.</span>touches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>clientX<span class="token punctuation">,</span> <br>    <span class="token literal-property property">y</span><span class="token operator">:</span> e<span class="token punctuation">.</span>touches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>clientY<span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>A lazy initializer is useless for atomic values like <code>useRef(9)</code>, since those are cheap to create, too.</p><p>For a slightly different use case, sometimes we want a stateful object (often a Resize/IntersectionObserver) with a stable identity — <code>useMemo</code> <a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">does not guarantee it.</a> We don't really want to reassign <code>current</code>, so a <code>RefObject</code> API is not needed:</p><pre class="language-js"><code class="language-js"><span class="token comment">// Would be nice</span><br><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useStableMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Why write observer.current if you never swap an observer?</span><br><span class="token keyword">const</span> rootRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=></span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current<span class="token punctuation">;</span></code></pre><p>For each technique, we'll see how good it is at supporting both use cases.</p><h2>The async way</h2><p>The most intuitive way to lazy-initialize a ref is combining a value-less <code>useRef()</code> with a mount effect:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  ref<span class="token punctuation">.</span>current <span class="token operator">=</span> initialValue<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Nicely, init inside an effect does not (<a href="/2021/11/15/unintentional-layout-effect/">normally</a>) block the paint, allowing you to paint a touch faster. However, this implementation is not always convenient, because the <code>.current</code> value is not accessible before the effect — in the first render phase, in DOM refs, <code>useLayoutEffect</code>, and even in some other <code>useEffect</code>s (inside child components and ones scheduled before the <em>init</em> effect) — try it yourself in a <a href="https://codepen.io/thoughtspile/pen/wvrvQjN?editors=0011" target="_blank" rel="noopener">codepen</a>. If the whole <code>useRef</code> + <code>useEffect</code> construction is written inline in a component, you at least see that the initialization is delayed. Wrapping it into a custom hook increases the chances of a misuse:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// spot the bug</span><br><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  observer<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The logic relying on <code>.current</code> is awkwardly pushed into effects, complicating your code:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span> setWidth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <br>  <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>e<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setWidth</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>borderBoxSize<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  observer<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>current<span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>node<span class="token punctuation">}</span></span> <span class="token attr-name">data-width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre><p>Replacing <code>useEffect</code> with <code>useLayoutEffect</code> does not help much — a bunch of places that can't access the <code>current</code> still exists (first render, DOM refs, child <code>useLayoutEffect</code>s), <em>and</em> now the initialization blocks the paint. As we'll see now, better ways to initialize early exist.</p><p>The <code>useEffect</code> approach works OK if you only need <code>.current</code> <em>later</em> — in other effects, timeouts or event handlers (and you're 100% sure those won't fire during the first paint). It's my least favorite approach, because the other ones work better and avoid the &quot;pre-initialization gap&quot;.</p><h2>The DIY way</h2><p>If we want the <code>.current</code> value to be available at all times, but without re-creation on every render (a lot like <code>useState</code> / <code>useMemo</code>), we can just build a custom hook over bare <code>useRef</code> ourselves (see <a href="https://codepen.io/thoughtspile/pen/MWEWzMe?editors=0011" target="_blank" rel="noopener">codepen</a>):</p><pre class="language-js"><code class="language-js"><span class="token comment">// none is a special value used to detect an uninitialized ref</span><br><span class="token keyword">const</span> none <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// not initialized yet</span><br>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// if it's not initialized (1st render)</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current <span class="token operator">===</span> none<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// we initialize it</span><br>    ref<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// new we return the initialized ref</span><br>  <span class="token keyword">return</span> ref<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This implementation is a good default for custom <code>useLazyRef</code> hooks: it works <em>anywhere</em> — inside render, in effects and layout effects, in listeners, with no chance of misuse, and is similar to the built-in <code>useState</code> and <code>useMemo</code>. To turn it into a readonly ref / stable memo, just return <code>ref.current</code> — it's already initialized before <code>useLazyRef</code> returns.</p><blockquote><p>Note that using <code>null</code> as the un-initialized value breaks if <code>init()</code> returns <code>null</code>, and setting <code>ref.current = null</code> triggers an accidental re-initialization on next render. <code>Symbol</code> works well and might be more convenient for debugging.</p></blockquote><p>This is the most convenient approach for storing <code>observers</code>, because they're safe to use from DOM refs:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span> setWidth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <br>  <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>e<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setWidth</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>borderBoxSize<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current<span class="token punctuation">;</span><br><span class="token keyword">const</span> nodeRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current<span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>nodeRef<span class="token punctuation">}</span></span> <span class="token attr-name">data-width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre><p>The only downside is that the initializer runs even if we never read the value. I'll show you how to avoid this, but first let's see how we can (and can't) build <em>this</em> flavor of lazy <code>useRef</code> over other hooks.</p><h2>The resourceful way</h2><p>If <code>useState</code> has the lazy initializer feature we want, why not just use it instead of writing custom code (<a href="https://codepen.io/thoughtspile/pen/eYGYbYg?editors=0011" target="_blank" rel="noopener">codepen</a>)?</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>We <code>useState</code> with a lazy initializer that mimics the shape of a RefObject, and throw away the update handle because we'll never use it — ref identity must be stable. For readonly ref / stable-memo we can skip the <code>{ current }</code> trick and just <code>useState(init)[0]</code>. Storing a mutable object in <code>useState</code> is not the most orthodox thing to do, but it works pretty well here. I imagine that at some point future react <em>might</em> choose to rebuild the current <code>useState</code> by re-initializing and re-applying all the updates (e.g. for HMR), but I haven't heard of such plans, and this will break a lot of stuff.</p><p>As usual, anything doable with <code>useState</code> can also be done with <code>useReducer</code>, but it's slightly more complicated:</p><pre class="language-js"><code class="language-js"><span class="token function">useReducer</span><span class="token punctuation">(</span><br>  <span class="token comment">// any reducer works, it never runs anyways</span><br>  <span class="token parameter">v</span> <span class="token operator">=></span> v<span class="token punctuation">,</span> <br>  <span class="token comment">// () => {} and () => 9 work just as well</span><br>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// And here's the stable memo:</span><br><span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> v<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>The most obvious base hook, <code>useMemo</code>, doesn't work well. <code>useMemo(() =&gt; ({ current: init() }), [])</code> currently returns a stable object, but React docs <a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">warn against relying</a> on this, since a future React version might re-initialize the value when it feels like it. If you're OK with that, you didn't need <code>ref</code> in the first place.</p><p><code>useImperativeHandle</code> is not recommended, too — it <a href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" target="_blank" rel="noopener">has something to do with refs,</a> but its <a href="https://github.com/facebook/react/blob/82c8fa90be86fc0afcbff2dc39486579cff1ac9a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1777" target="_blank" rel="noopener">implemented</a> to set the value in a layout effect, similar to the worst one of our <code>async</code> options. Also, it</p><p>So, <code>useState</code> allows you to build a <em>lazy ref</em> with almost zero code, at a minor risk of breaking in a future react version. Choosing between this and a DIY lazy ref is up to you, they work the same.</p><h2>The really lazy way</h2><p>I'd argue that what we've discussed so far isn't really <em>lazy</em> — sure, you avoid useless job on re-render, but you still eagerly compute the initial value on first render. What if we only computed the value on demand, when someone reads <code>.current</code>?</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> none <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">useJitRef</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><br>    <span class="token keyword">get</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>current <span class="token operator">===</span> none<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        value<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">return</span> value<span class="token punctuation">.</span>current<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token keyword">set</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      value<span class="token punctuation">.</span>current <span class="token operator">=</span> v<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> ref<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Tricky! See <a href="https://codepen.io/thoughtspile/pen/YzrzdyJ?editors=0011" target="_blank" rel="noopener">codepen</a>, and let me break it down for you:</p><ul><li>Wrap the bare ref with a get / set interceptor</li><li>Reading <code>current</code> goes through the <code>get()</code>, computing the value on first read and returning the cached value later.</li><li>Assigning <code>current</code> updates the value instantly and removes the need to initialize.</li><li>The wrapper object is a <code>useLazyRef</code> itself to preserve the builtin <code>useRef</code> guarantee of stable identity and avoid extra object creation.</li></ul><p>For readonly ref / stable memo, try the simpler <em>getter function</em> approach <a href="https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily" target="_blank" rel="noopener">suggested in react docs:</a></p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> none <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">useMemoGet</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>current <span class="token operator">===</span> none<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      value<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> value<span class="token punctuation">.</span>current<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Is it worth the trouble? Maybe, maybe not. The code is more complicated than the eager <code>useLazyRef</code>. If the initializer is <em>really</em> heavy, and you use the value conditionally, and you often end up not needing it, sure, it's a good fit. Honestly, I have yet to see a use case that fits these conditions.</p><p>This is a very interesting and flexible technique that supports many variations:</p><ul><li>Pre-compute the value, e.g. in <code>requestIdleCallback(() =&gt; ref.current)</code></li><li>Allow for lazy updates — don't set the explicit value, but provide a new way to compute it: <code>ref.current = () =&gt; el.clientWidth</code></li><li>Replace <em>updating</em> with <em>invalidation</em> — say, with <code>getWidth = useMemoGet(() =&gt; el.clientWidth)</code> you can mark the cached value as stale with <code>getWidth.invalidate()</code> on content change.</li></ul><hr><p>We've covered 4 good base techniques (<code>useState</code> is an alternative implementation of ) for creating lazy useRef. They all have different characteristics that make them useful for different problems:</p><ul><li>Initialize in <code>useEffect</code> — not recommended because it's easy to hit un-initialized <code>.current</code>.</li><li>Sync custom-built <code>useRef</code> works well, but blocks first render. Good enough for most cases.</li><li>Putting the value into <code>useState</code>'s initializer, but hiding the update handle. Least code, but a chance of breaking in future react versions.</li><li>On-demand <code>useRef</code> that only computes the value when you read <code>.current</code> — complicated, but flexible and never computes values you don't use.</li></ul><p>Hope you find this useful! If you want to learn more about react, check out my <a href="/">other posts.</a></p></div><span class="share"><div><a href="https://twitter.com/share?url=https://blog.thoughtspile.tech/2021/11/30/lazy-useref/&text=Make useRef lazy — 4 ways by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2021/11/30/lazy-useref/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="social-links"><a href="https://twitter.com/thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="https://mastodon.online/@thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a><a href="https://www.linkedin.com/in/vklepov/" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="/atom.xml" class="link--bare" target="_blank"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="rss" class="svg-inline--fa fa-rss fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM128 416c0 35.3-28.7 64-64 64s-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a></div><a href="https://buymeacoffee.com/thoughtspile" class="link--bare bmc-card" target="_blank" rel="noopener"><div><b>Hello, friend!</b> My name is Vladimir, and I love writing about web development. If you got down here, you probably enjoyed this article. My goal is to become an independent content creator, and you'll help me get there by <span class="bmc">buying me a coffee!</span></div><img src="/images/bmc.png" data-no-preview class="bmc-image"></a><div class="post-related"><div class="post-sibling"><span class="post-siblings__direction">More?</span> <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/react" rel="tag">react</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/hooks" rel="tag">hooks</a></div><a class="link--bare post-sibling" href="/2021/11/20/open-source-starter/"><span class="post-siblings__direction">Older?</span> <span class="link__text">Open source starter pack for JS devs</span> </a><a class="link--bare post-sibling" href="/2022/01/17/jsx-conditionals/"><span class="post-siblings__direction">Newer?</span> <span class="link__text">Good advice on JSX conditionals</span></a></div></article><script async src="/js/share.js"></script></div></body></html>