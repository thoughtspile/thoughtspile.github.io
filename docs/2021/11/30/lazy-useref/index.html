<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta name="color-scheme" content="dark light"><meta property="og:type" content="article"><meta property="og:title" content="Make useRef lazy — 4 ways"><meta property="og:url" content="https://blog.thoughtspile.tech/2021/11/30/lazy-useref/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/lazy-useref-sofa.jpg"><meta property="article:published_time" content="2021-11-30T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="react"><meta property="article:tag" content="javascript"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/lazy-useref-sofa.jpg"><title>Make useRef lazy — 4 ways</title><link rel="stylesheet" href="/css/style.css?ts=1675532594114"><link rel="canonical" href="https://blog.thoughtspile.tech/2021/11/30/lazy-useref/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Make useRef lazy — 4 ways</h1></header><div class="content" itemprop="articleBody"><p>I love <code>useRef</code>, but it lacks the lazy initializer functionality found in other hooks (<code>useState</code> / <code>useReducer</code> / <code>useMemo</code>). <code>useRef({ x: 0, y: 0 })</code> creates an object <code>{ x: 0, y: 0 }</code> on every render, but only uses it when mounting — it subsequent renders it's thrown away. With <code>useState</code>, we can replace the initial <em>value</em> with an <em>initializer</em> that's only called on first render — <code>useState(() =&gt; ({ x: 0, y: 0 }))</code> (I've explored this and other <code>useState</code> features in my <a href="/2021/09/27/usestate-tricks/">older post</a>). Creating functions is very cheap in modern JS runtimes, so we skip allocating memory and building the object for a slight performance boost (see <a href="https://jsbench.me/p3kwj6ojfs" target="_blank" rel="noopener">benchmark</a>).</p><p>I'm not super excited about doing useless work, and <code>useRef</code> is your primary tool for <a href="/2021/10/18/non-react-state/">avoiding useless re-renders.</a> In this post, I'll show you four ways to support lazy initializer in <code>useRef</code>:</p><ol><li>Move initialization to <code>useEffect</code></li><li>Sync lazy <code>useRef</code> initializer that works like <code>useState</code> initializer.</li><li>Lazy <code>useRef</code> on top of <code>useState</code> (almost zero code!)</li><li>A <code>useRef</code> that only computes the value when you read <code>.current</code></li></ol><p><img src="/images/lazy-useref-sofa.jpg" alt=""></p><h2>Use cases</h2><p>Any ref that involves an object can benefit from lazy initialization. I use such refs a lot for <a href="/2021/10/18/non-react-state/">tracking gestures:</a></p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> touch <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token function-variable function">onTouchMove</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  touch<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token punctuation">{</span><br>    <span class="token literal-property property">x</span><span class="token operator">:</span> e<span class="token punctuation">.</span>touches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>clientX<span class="token punctuation">,</span> <br>    <span class="token literal-property property">y</span><span class="token operator">:</span> e<span class="token punctuation">.</span>touches<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>clientY<span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>A lazy initializer is useless for atomic values like <code>useRef(9)</code>, since those are cheap to create, too.</p><p>For a slightly different use case, sometimes we want a stateful object (often a Resize/IntersectionObserver) with a stable identity — <code>useMemo</code> <a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">does not guarantee it.</a> We don't really want to reassign <code>current</code>, so a <code>RefObject</code> API is not needed:</p><pre class="language-js"><code class="language-js"><span class="token comment">// Would be nice</span><br><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useStableMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// Why write observer.current if you never swap an observer?</span><br><span class="token keyword">const</span> rootRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=></span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current<span class="token punctuation">;</span></code></pre><p>For each technique, we'll see how good it is at supporting both use cases.</p><h2>The async way</h2><p>The most intuitive way to lazy-initialize a ref is combining a value-less <code>useRef()</code> with a mount effect:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  ref<span class="token punctuation">.</span>current <span class="token operator">=</span> initialValue<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Nicely, init inside an effect does not (<a href="/2021/11/15/unintentional-layout-effect/">normally</a>) block the paint, allowing you to paint a touch faster. However, this implementation is not always convenient, because the <code>.current</code> value is not accessible before the effect — in the first render phase, in DOM refs, <code>useLayoutEffect</code>, and even in some other <code>useEffect</code>s (inside child components and ones scheduled before the <em>init</em> effect) — try it yourself in a <a href="https://codepen.io/thoughtspile/pen/wvrvQjN?editors=0011" target="_blank" rel="noopener">codepen</a>. If the whole <code>useRef</code> + <code>useEffect</code> construction is written inline in a component, you at least see that the initialization is delayed. Wrapping it into a custom hook increases the chances of a misuse:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// spot the bug</span><br><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  observer<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The logic relying on <code>.current</code> is awkwardly pushed into effects, complicating your code:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span> setWidth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <br>  <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>e<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setWidth</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>borderBoxSize<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  observer<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>current<span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>node<span class="token punctuation">}</span></span> <span class="token attr-name">data-width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre><p>Replacing <code>useEffect</code> with <code>useLayoutEffect</code> does not help much — a bunch of places that can't access the <code>current</code> still exists (first render, DOM refs, child <code>useLayoutEffect</code>s), <em>and</em> now the initialization blocks the paint. As we'll see now, better ways to initialize early exist.</p><p>The <code>useEffect</code> approach works OK if you only need <code>.current</code> <em>later</em> — in other effects, timeouts or event handlers (and you're 100% sure those won't fire during the first paint). It's my least favorite approach, because the other ones work better and avoid the &quot;pre-initialization gap&quot;.</p><h2>The DIY way</h2><p>If we want the <code>.current</code> value to be available at all times, but without re-creation on every render (a lot like <code>useState</code> / <code>useMemo</code>), we can just build a custom hook over bare <code>useRef</code> ourselves (see <a href="https://codepen.io/thoughtspile/pen/MWEWzMe?editors=0011" target="_blank" rel="noopener">codepen</a>):</p><pre class="language-js"><code class="language-js"><span class="token comment">// none is a special value used to detect an uninitialized ref</span><br><span class="token keyword">const</span> none <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">// not initialized yet</span><br>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// if it's not initialized (1st render)</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current <span class="token operator">===</span> none<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// we initialize it</span><br>    ref<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">// new we return the initialized ref</span><br>  <span class="token keyword">return</span> ref<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>This implementation is a good default for custom <code>useLazyRef</code> hooks: it works <em>anywhere</em> — inside render, in effects and layout effects, in listeners, with no chance of misuse, and is similar to the built-in <code>useState</code> and <code>useMemo</code>. To turn it into a readonly ref / stable memo, just return <code>ref.current</code> — it's already initialized before <code>useLazyRef</code> returns.</p><blockquote><p>Note that using <code>null</code> as the un-initialized value breaks if <code>init()</code> returns <code>null</code>, and setting <code>ref.current = null</code> triggers an accidental re-initialization on next render. <code>Symbol</code> works well and might be more convenient for debugging.</p></blockquote><p>This is the most convenient approach for storing <code>observers</code>, because they're safe to use from DOM refs:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span> setWidth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <br>  <span class="token keyword">new</span> <span class="token class-name">ResizeObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>e<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setWidth</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>borderBoxSize<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current<span class="token punctuation">;</span><br><span class="token keyword">const</span> nodeRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current<span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>nodeRef<span class="token punctuation">}</span></span> <span class="token attr-name">data-width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>width<span class="token punctuation">}</span></span> <span class="token spread"><span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></code></pre><p>The only downside is that the initializer runs even if we never read the value. I'll show you how to avoid this, but first let's see how we can (and can't) build <em>this</em> flavor of lazy <code>useRef</code> over other hooks.</p><h2>The resourceful way</h2><p>If <code>useState</code> has the lazy initializer feature we want, why not just use it instead of writing custom code (<a href="https://codepen.io/thoughtspile/pen/eYGYbYg?editors=0011" target="_blank" rel="noopener">codepen</a>)?</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>We <code>useState</code> with a lazy initializer that mimics the shape of a RefObject, and throw away the update handle because we'll never use it — ref identity must be stable. For readonly ref / stable-memo we can skip the <code>{ current }</code> trick and just <code>useState(init)[0]</code>. Storing a mutable object in <code>useState</code> is not the most orthodox thing to do, but it works pretty well here. I imagine that at some point future react <em>might</em> choose to rebuild the current <code>useState</code> by re-initializing and re-applying all the updates (e.g. for HMR), but I haven't heard of such plans, and this will break a lot of stuff.</p><p>As usual, anything doable with <code>useState</code> can also be done with <code>useReducer</code>, but it's slightly more complicated:</p><pre class="language-js"><code class="language-js"><span class="token function">useReducer</span><span class="token punctuation">(</span><br>  <span class="token comment">// any reducer works, it never runs anyways</span><br>  <span class="token parameter">v</span> <span class="token operator">=></span> v<span class="token punctuation">,</span> <br>  <span class="token comment">// () => {} and () => 9 work just as well</span><br>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token comment">// And here's the stable memo:</span><br><span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> v<span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>The most obvious base hook, <code>useMemo</code>, doesn't work well. <code>useMemo(() =&gt; ({ current: init() }), [])</code> currently returns a stable object, but React docs <a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener">warn against relying</a> on this, since a future React version might re-initialize the value when it feels like it. If you're OK with that, you didn't need <code>ref</code> in the first place.</p><p><code>useImperativeHandle</code> is not recommended, too — it <a href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" target="_blank" rel="noopener">has something to do with refs,</a> but its <a href="https://github.com/facebook/react/blob/82c8fa90be86fc0afcbff2dc39486579cff1ac9a/packages/react-reconciler/src/ReactFiberHooks.new.js#L1777" target="_blank" rel="noopener">implemented</a> to set the value in a layout effect, similar to the worst one of our <code>async</code> options. Also, it</p><p>So, <code>useState</code> allows you to build a <em>lazy ref</em> with almost zero code, at a minor risk of breaking in a future react version. Choosing between this and a DIY lazy ref is up to you, they work the same.</p><h2>The really lazy way</h2><p>I'd argue that what we've discussed so far isn't really <em>lazy</em> — sure, you avoid useless job on re-render, but you still eagerly compute the initial value on first render. What if we only computed the value on demand, when someone reads <code>.current</code>?</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> none <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">useJitRef</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useLazyRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><br>    <span class="token keyword">get</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>current <span class="token operator">===</span> none<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        value<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">return</span> value<span class="token punctuation">.</span>current<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token keyword">set</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      value<span class="token punctuation">.</span>current <span class="token operator">=</span> v<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> ref<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Tricky! See <a href="https://codepen.io/thoughtspile/pen/YzrzdyJ?editors=0011" target="_blank" rel="noopener">codepen</a>, and let me break it down for you:</p><ul><li>Wrap the bare ref with a get / set interceptor</li><li>Reading <code>current</code> goes through the <code>get()</code>, computing the value on first read and returning the cached value later.</li><li>Assigning <code>current</code> updates the value instantly and removes the need to initialize.</li><li>The wrapper object is a <code>useLazyRef</code> itself to preserve the builtin <code>useRef</code> guarantee of stable identity and avoid extra object creation.</li></ul><p>For readonly ref / stable memo, try the simpler <em>getter function</em> approach <a href="https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily" target="_blank" rel="noopener">suggested in react docs:</a></p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> none <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">useMemoGet</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>current <span class="token operator">===</span> none<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      value<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> value<span class="token punctuation">.</span>current<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Is it worth the trouble? Maybe, maybe not. The code is more complicated than the eager <code>useLazyRef</code>. If the initializer is <em>really</em> heavy, and you use the value conditionally, and you often end up not needing it, sure, it's a good fit. Honestly, I have yet to see a use case that fits these conditions.</p><p>This is a very interesting and flexible technique that supports many variations:</p><ul><li>Pre-compute the value, e.g. in <code>requestIdleCallback(() =&gt; ref.current)</code></li><li>Allow for lazy updates — don't set the explicit value, but provide a new way to compute it: <code>ref.current = () =&gt; el.clientWidth</code></li><li>Replace <em>updating</em> with <em>invalidation</em> — say, with <code>getWidth = useMemoGet(() =&gt; el.clientWidth)</code> you can mark the cached value as stale with <code>getWidth.invalidate()</code> on content change.</li></ul><hr><p>We've covered 4 good base techniques (<code>useState</code> is an alternative implementation of ) for creating lazy useRef. They all have different characteristics that make them useful for different problems:</p><ul><li>Initialize in <code>useEffect</code> — not recommended because it's easy to hit un-initialized <code>.current</code>.</li><li>Sync custom-built <code>useRef</code> works well, but blocks first render. Good enough for most cases.</li><li>Putting the value into <code>useState</code>'s initializer, but hiding the update handle. Least code, but a chance of breaking in future react versions.</li><li>On-demand <code>useRef</code> that only computes the value when you read <code>.current</code> — complicated, but flexible and never computes values you don't use.</li></ul><p>Hope you find this useful! If you want to learn more about react, check out my <a href="/">other posts.</a></p></div><span class="share"><div><a href="https://twitter.com/share?url=&text= by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2021/11/30/lazy-useref/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/react" rel="tag">react</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/hooks" rel="tag">hooks</a></div><div class="post-actions">Written in <time>2021</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank" rel="noopener">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" href="https://buymeacoffee.com/thoughtspile" target="_blank" rel="noopener">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/11/20/open-source-starter/"><div class="post-siblings__direction">Older</div><span class="link__text">Open source starter pack for JS devs</span> </a><a class="link--bare" href="/2022/01/17/jsx-conditionals/"><div class="post-siblings__direction">Newer</div><span class="link__text">Good advice on JSX conditionals</span></a></div></article><script async src="/js/share.js"></script></div></body></html>