<!doctype html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><meta name="google-site-verification" content="1-m0w7Up8df1sn0230jxfTKKZ4jLeln_Em1tcyfU0qw"><meta name="color-scheme" content="dark light"><meta property="og:type" content="article"><meta property="og:title" content="Are many useStates better than useState(object)?"><meta property="og:url" content="https://blog.thoughtspile.tech/2021/10/11/usestate-object-vs-multiple/"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/usestate-perf.png?invert"><meta property="article:published_time" content="2021-10-11T00:00:00.000Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta property="article:tag" content="javascript"><meta property="article:tag" content="frontend"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@thoughtspile"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/usestate-perf.png?invert"><title>Are many useStates better than useState(object)?</title><link rel="stylesheet" href="/css/style.css?ts=1682338985578"><link rel="canonical" href="https://blog.thoughtspile.tech/2021/10/11/usestate-object-vs-multiple/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script defer="defer" data-domain="blog.thoughtspile.tech" src="https://t.thoughtspile.tech/js/script.js"></script></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Are many useStates better than useState(object)?</h1><div class="post__date">Written in <time>2021</time></div></header><div class="content" itemprop="articleBody"><p>Lately I've converted <em>a lot of</em> class components to functional. One question left me curious every time — why do I feel like splitting the old class <code>state</code> into so many <code>useState(atom)</code> — one for each state key? Is there any real benefit in it? Should I just leave a single <code>useState(whatever this.state was)</code> to touch as little code as possible during refactoring? Today, we'll discuss if having many <code>useState(atom)</code> is better than one single <code>useState(object)</code> — and, exactly, why. (Spoiler: it depends).</p><h2>Collection =&gt; object state</h2><p>To get the obvious out of the way: if your state is a collection — multiple similar values, probably dynamic quantity, normally in an array or a key:value object — you have to use object state. Someone with a dirty mind could work around that with serialization or recursive components, but let's not go there.</p><h2>State decomposition</h2><p>Common architectural sense tells us to split totally unrelated pieces of state into multiple <code>useStates</code>. The ability of separating state like that is one of the better features hooks offer. If you have a component that tracks input value, but <em>also</em> happens to track wheter the input has focus, go ahead and separate focus-state and value-state:</p><pre class="language-js"><code class="language-js"><span class="token comment">// no</span><br><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> value<span class="token punctuation">,</span> isFocused <span class="token punctuation">}</span><span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>  <span class="token literal-property property">isFocused</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token operator">&lt;</span>input<br>  value<span class="token operator">=</span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>value<span class="token punctuation">}</span><br>  data<span class="token operator">-</span>focus<span class="token operator">=</span><span class="token punctuation">{</span>isFocused<span class="token punctuation">}</span><br>  onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span> isFocused <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br>  onFocus<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">,</span> <span class="token literal-property property">isFocused</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br>  onBlur<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">,</span> <span class="token literal-property property">isFocused</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><span class="token operator">/</span><span class="token operator">></span><br><br><span class="token comment">// yes</span><br><span class="token keyword">const</span> <span class="token punctuation">[</span>isFocused<span class="token punctuation">,</span> setFocused<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">return</span> <span class="token operator">&lt;</span>input<br>  value<span class="token operator">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><br>  data<span class="token operator">-</span>focus<span class="token operator">=</span><span class="token punctuation">{</span>isFocused<span class="token punctuation">}</span><br>  onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setValue</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><br>  onFocus<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setFocused</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br>  onBlur<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setFocused</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><span class="token operator">/</span><span class="token operator">></span></code></pre><p>I'm getting a bit ahead of myself, but the second variant is shorter and looks clearer to me. You also get to use the extra convenience useState provides for atomic values (more on that in a moment). Also, if at some point you decide to extract focus-management into a custom hook, you're well prepared.</p><p>— But wait, Vladimir, didn't you just tell us to <a href="/2021/10/04/react-context-dangers">wrap context value in an object,</a> even if it has a single item?</p><p>— Yes, but this time it's different! To change context value from atom to an object, you must edit all the places where you read the context — that's your whole codebase. Component state is local, so it takes a single destructuring — <code>[value, setValue] = useState(0) -&gt; [{ value }, setValue] = useState({ value: 0 })</code>. Besides, unlike context, state shape is not likely to be your public API.</p><h2>useState(atom) benefits</h2><p>Now let's see, exactly, why useState works better with atomic values.</p><h3>Convention</h3><p>The feeling that <code>useState</code> should be used with atoms is there for a reason — the API is designed to push you towards this idea.</p><p>First, <code>setState({ value: 0 })</code> sets the state to that exact object — <code>{ 'value': 0 }</code>. Class component's <code>this.setState({ value: 0 })</code> will merge the update with the current state. You can <a href="https://ru.react.js.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener">mimic this behavior</a> with a spread: <code>setState({ ...state, value: 0 })</code>, but note how you're fighting react. Manually constructing the next state object without spreads: <code>setState({ focus, value: 0 })</code> is explosive — it's easy to miss an update site if you're adding a new key to your state and erase a part of the state.</p><p>Next, as explained in my post on <a href="/2021/09/27/usestate-tricks">useState tricks</a>, <code>setState(value)</code> does nothing when value is equal to the current state. Working with atomic values makes it trivial to use this feature, because atoms are compared by value. By contrast, <code>this.setState({ value })</code> in a <code>PureComponent</code> is followed by a shallow object equality check.</p><p>So, while class components were designed to work best with objects (indeed, component state is always an object), <code>useState</code> has a speacial optimization for atomic values, and does includes no conveniences for working with objects. You can work around both issues with a custom hook, but why fight React if it politely asks you to prefer atomic state?</p><h3>Bundle size</h3><p>One possible advantage of not using objects is the reduced bundle size — the <a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">original hooks announcement</a> by React team specifiaclly mentioned that <em>classes don’t minify very well.</em> Let's pass our sample component that tracks focus and value through the normal build toolchain — babel + terser + gzip, and see if that's true.</p><p>Looking at the minified object-state variant, we can see that the minifier can't do anything about the keys of our object. Terser is very smart, but it has no idea if <code>isFocused</code> and <code>value</code> keys mean anything to that <code>useState</code> function we're passing our object through, so it can't mangle the keys. Note, however, that this has nothing to do with <em>classes</em> — any object has the same problem. Here's the component — It's 338 bytes raw, and 128 bytes under gzip:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">isFocused</span><span class="token operator">:</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token literal-property property">value</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token operator">=</span>n<span class="token punctuation">.</span>value<span class="token punctuation">,</span>o<span class="token operator">=</span>n<span class="token punctuation">.</span>isFocused<span class="token punctuation">,</span>u<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span>state<span class="token punctuation">.</span>value<span class="token punctuation">,</span><span class="token string-property property">"data-focus"</span><span class="token operator">:</span>o<span class="token punctuation">,</span><span class="token function-variable function">onChange</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span><span class="token literal-property property">isFocused</span><span class="token operator">:</span>o<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token function-variable function">onFocus</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span>r<span class="token punctuation">,</span><span class="token literal-property property">isFocused</span><span class="token operator">:</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token function-variable function">onBlur</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span>r<span class="token punctuation">,</span><span class="token literal-property property">isFocused</span><span class="token operator">:</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Now let's try the object-free version. It doesn't pass the state object anywhere, and symbolic variable names are successfully mangled:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>r<span class="token operator">=</span>t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>o<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>u<span class="token operator">=</span>o<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">=</span>o<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span>u<span class="token punctuation">,</span><span class="token string-property property">"data-focus"</span><span class="token operator">:</span>n<span class="token punctuation">,</span><span class="token function-variable function">onChange</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">i</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token function-variable function">onFocus</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token function-variable function">onBlur</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>This minified component is 273 bytes. So, case solved — at 65 bytes, or 20% off, atoms win, objects suck, right? Not so fast: the gzip size is 112 bytes, only 16 bytes / 12.5% smaller, and that's an abyssmal difference, especially in absolute terms.</p><p>In case you're curious, I included React in both bundles to gize gzip some warm-up data. I also transpiled down to IE11. Have fun with your own measurements if you feel I missed something!</p><p>So, you'd have to try very hard, with hundreds of components, to get any meaningful post-gzip bundle size reduction from using atomic state over objects. Still, the difference exists, so that's half a point to atoms.</p><h2>Should you ever useState(object)?</h2><p>So far, we've seen that multiple <code>useState(atom)</code> work well for breaking state into independent fragments. Atomic state is often more convenient, more conventional and gives you a slightly smaller bundle. So, are there any reasons to use object state in hooks, other than managing collections? There is a couple.</p><h3>Update batching</h3><p>As we've discussed <a href="/2021/09/27/usestate-tricks">before</a>, React &lt;18 will not batch state updates from outside event handlers. Let's look at a familiar data-fetch example:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Hints</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>isLoading<span class="token punctuation">,</span> setLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>hints<span class="token punctuation">,</span> setHints<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/hints'</span><span class="token punctuation">)</span><br>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token function">setHints</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">setLoading</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>    </span><span class="token punctuation">{</span>isLoading<br>      <span class="token operator">?</span> <span class="token string">'loading...'</span> <span class="token operator">:</span><br>      hints<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">h</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>h<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text"><br>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>The component mounts with a loading indicator, calls an API endpoint, then disables the loader and shows some data once loaded. The only problem here is that since <code>loading</code> and <code>hints</code> are set via 2 different state updates from a promise (that's not an event handler), you end up rendering and modifying the DOM twice after load.</p><p>Grouping the loading flag and data into an object allows us to update the state in one call, eliminating the extra render:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> isLoading<span class="token punctuation">,</span> hints <span class="token punctuation">}</span><span class="token punctuation">,</span> setSuggest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>  <span class="token literal-property property">isLoading</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><br>  <span class="token literal-property property">hints</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/hints'</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token function">setSuggest</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>        <span class="token literal-property property">hints</span><span class="token operator">:</span> data<span class="token punctuation">,</span><br>        <span class="token literal-property property">isLoading</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><br>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Granted, you can also work around this issue while keeping your state split with a scary-sounding <code>unstable_batchedUpdates</code> from <code>react-dom</code>:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>isLoading<span class="token punctuation">,</span> setLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">const</span> <span class="token punctuation">[</span>hints<span class="token punctuation">,</span> setHints<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/hints'</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token comment">// triggers just one render</span><br>      <span class="token function">unstable_batchedUpdates</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token function">setHints</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">setLoading</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Still, I'd prefer grouping state in an object over using <code>unstable_</code> things and trying not to forget it every time I update the state. That's one use case where wrapping related state in an object makes sense — until react 18, it produces fewer renders when updating these related values.</p><h3>Arrow updates</h3><p><a href="/2021/09/27/usestate-tricks">If you recall,</a> <code>useState</code> allows you to update state using a callback AKA <em>mini-reducer.</em> The callback gets the current value as an agrument. We can use it to avoid data fetch race condition in a typeahead:</p><pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Hints</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token punctuation">[</span>search<span class="token punctuation">,</span> setSearch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>    <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span><br>    <span class="token literal-property property">hints</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/hints/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>search<span class="token punctuation">.</span>query<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><br>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">hints</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token function">setSearch</span><span class="token punctuation">(</span><span class="token parameter">s</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>          <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>query <span class="token operator">!==</span> search<span class="token punctuation">.</span>query<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token comment">// skip the update if query has changed</span><br>            <span class="token keyword">return</span> s<span class="token punctuation">;</span><br>          <span class="token punctuation">}</span><br>          <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>search<span class="token punctuation">,</span> hints <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><span class="token punctuation">)</span><br>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>search<span class="token punctuation">.</span>query<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text"><br>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span><br>      <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>query<span class="token punctuation">}</span></span><br>      <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setSearch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>search<span class="token punctuation">,</span> <span class="token literal-property property">query</span><span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><br>    <span class="token punctuation">/></span></span><span class="token plain-text"><br>    </span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>hints<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">h</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>h<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text"><br>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Here, we look at the <em>current</em> query after loading the hints, and only show the hints we loaded if the query has not changed since. Not the most elegant solution, but it works, and so it's a valid state model. If you were to split query and hints into separate states, you'd lose the ability to read current query when setting hints, and have to solve this problem some other way.</p><p>More generally (maybe too generally), if updates to state B depend on state A, states A and B should probably we wrapped in an object.</p><h2>Appendix A: useObjectState</h2><p>I promised you can have all the convenience of class <code>setState</code> in a custom hook. Here we go:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">useObjectState</span><span class="token punctuation">(</span><span class="token parameter">init</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> patch</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> changed <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>patch<span class="token punctuation">)</span><br>      <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!==</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> changed <span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token operator">...</span>s<span class="token punctuation">,</span> <span class="token operator">...</span>patch <span class="token punctuation">}</span> <span class="token operator">:</span> s<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span> init<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Here, we merge old and new state, and also preserve the old state object reference if the patch contains no changes. Easy breezy.</p><h2>Appendix B: Runtime performance</h2><p>For a tie-breaker, let's see if the amount of <code>useState</code> calls impacts your application performance.</p><p>I expect the runtime performance difference between single object state and multiple atomic states to be even more negligible than that of bundle size. Still, the fact that it could go both ways is made me curious: object state allocates an extra object (or function, with a lazy initializer) on every render, but atoms call more react internals. Is there a winner?</p><p>I've made a tiny <a href="https://jsbench.me/qvkumpoejp/1" target="_blank" rel="noopener">benchmark</a> comparing several useState calls, single <code>useState(object)</code> call and single <code>useState(() =&gt; lazy object)</code>. The results are available in a <a href="https://docs.google.com/spreadsheets/d/1IpPuc77S9UODSpLELqGSy-_06xYo11BIEcHVadId1H0/edit?usp=sharing" target="_blank" rel="noopener">google sheet</a>. I've also made a nice chart that shows percent increase in mount time over baseline — no hooks, just a stateless render:</p><p><img src="/images/usestate-perf.png?invert" alt=""></p><p>I wouldn't dare interpret these results given how cool optimizing compilers are, but the general as I see it pattern makes sense:</p><ul><li>1 <code>useState</code> with atom is slightly better than with object because we skip object allocation.</li><li><code>useState</code> calls are more expensive than object allocations, so for 3+ items <code>useState(object)</code> wins.</li><li>Lazy initializer beats object creation — not sure why, if the initializer is always called on mount.</li></ul><p>Note that the difference here is in sub-microsecond range (yes, MICROsecond, 1/1000th of a millisecond, or 1/16000th of a 60FPS frame), so any practical implications are laughable. Still, good to know that using hooks is almost free.</p><hr><p>So, useState is probably better suited for storing atomic values, but object state still has its uses. Here's what we learnt:</p><ul><li><code>useState</code> update handle skips re-render by checking for <code>===</code> equality, and that's easier to achieve with atomic values.</li><li><code>useState</code> has no built-in object merging mechanism.</li><li>Atomic state makes your bundle a <em>little bit</em> smaller, because object keys are hard to mangle.</li><li>Collection state only works as an object.</li><li>Until React 18, async updates to several <code>useStates</code> result in useless renders. Use object state or <code>unstable_batchedUpdates</code> to render once.</li><li>You can't access the current state of another <code>useState</code> in a state update callback (ouch, that's a complex statement with many states involved) — use object state for values that depend on each other during update.</li><li>Any performace difference between <code>useState</code> variants is negligible.</li></ul><p>I feel the deciding factor here is state modelling — grouping several state items in an object signals that they are closely related, while splitting them apart shows they are orthogonal. Please model your state based on common sense, not some prejudices agains objects. Ah, and also — everything we just discussed also applies to <code>useReducer</code>, because <code>useState</code> is <code>useReducer</code>. Good luck and see you next time!</p></div><span class="share"><div><a href="https://twitter.com/share?url=https://blog.thoughtspile.tech/2021/10/11/usestate-object-vs-multiple/&text=Are many useStates better than useState(object)? by @thoughtspile" target="_blank" rel="noopener">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2021/10/11/usestate-object-vs-multiple/" target="_blank" rel="noopener">Discuss on Twitter</a></div></span><div class="social-links"><a href="https://twitter.com/thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="https://mastodon.online/@thoughtspile" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="mastodon" class="svg-inline--fa fa-mastodon fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"></path></svg></a><a href="https://www.linkedin.com/in/vklepov/" class="link--bare" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a><a href="/atom.xml" class="link--bare" target="_blank"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="rss" class="svg-inline--fa fa-rss fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM128 416c0 35.3-28.7 64-64 64s-64-28.7-64-64s28.7-64 64-64s64 28.7 64 64zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"></path></svg></a></div><a href="https://buymeacoffee.com/thoughtspile" class="link--bare bmc-card" target="_blank" rel="noopener"><div><b>Hello, friend!</b> My name is Vladimir, and I love writing about web development. If you got down here, you probably enjoyed this article. My goal is to become an independent content creator, and you'll help me get there by <span class="bmc">buying me a coffee!</span></div><img src="/images/bmc.png" data-no-preview class="bmc-image"></a><div class="post-related"><div class="post-sibling"><span class="post-siblings__direction">More?</span> <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/react" rel="tag">react</a> <a class="tag-link-link" href="/tags/hooks" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/javascript" rel="tag">javascript</a> <a class="tag-link-link" href="/tags/frontend" rel="tag">frontend</a></div><a class="link--bare post-sibling" href="/2021/10/06/babel-runtime-version/"><span class="post-siblings__direction">Older?</span> <span class="link__text">Is your babel's transform-runtime getting lazy? You better check.</span> </a><a class="link--bare post-sibling" href="/2021/10/13/really-declarative/"><span class="post-siblings__direction">Newer?</span> <span class="link__text">Thanks React, I'm fine with an imperative setInterval</span></a></div></article><script async src="/js/share.js"></script></div></body></html>