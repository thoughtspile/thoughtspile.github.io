<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2022/01/17/jsx-conditionals/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="Conditional rendering is a cornerstone of any templating language. React &#x2F; JSX bravely chose not to have a dedicated conditional syntax, like ng-if&#x3D;&quot;condition&quot;, relying on JS boolean operato"><meta property="og:type" content="article"><meta property="og:title" content="Good advice on JSX conditionals"><meta property="og:url" content="https://thoughtspile.github.io/2022/01/17/jsx-conditionals/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="Conditional rendering is a cornerstone of any templating language. React &#x2F; JSX bravely chose not to have a dedicated conditional syntax, like ng-if&#x3D;&quot;condition&quot;, relying on JS boolean operato"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://thoughtspile.github.io/images/jsx-conditional-cheatsheet.png"><meta property="article:published_time" content="2022-01-17T15:58:03.000Z"><meta property="article:modified_time" content="2022-01-17T17:34:39.956Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="programming"><meta property="article:tag" content="frontend"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://thoughtspile.github.io/images/jsx-conditional-cheatsheet.png"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>Good advice on JSX conditionals</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://thoughtspile.github.io/2022/01/17/jsx-conditionals/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Good advice on JSX conditionals</h1></header><div class="content" itemprop="articleBody"><p>Conditional rendering is a cornerstone of any templating language. React / JSX bravely chose not to have a dedicated conditional syntax, like <code>ng-if=&quot;condition&quot;</code>, <a target="_blank" rel="noopener" href="https://reactjs.org/docs/conditional-rendering.html">relying</a> on JS <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">boolean operators</a> instead:</p><ul><li><code>condition &amp;&amp; &lt;JSX /&gt;</code> renders <code>&lt;JSX /&gt;</code> iff <code>condition</code> is truthy,</li><li><code>condition ? &lt;JsxTrue /&gt; : &lt;JsxFalse /&gt;</code> renders <code>&lt;JsxTrue /&gt;</code> or <code>&lt;JsxFalse /&gt;</code> depending on the truthiness of <code>condition</code>.</li></ul><p>Courageous, but not always as intuitive as you’d expect. Time after time I shoot myself in the foot with JSX conditionals. In this article, I look at the trickier corners of JSX conditionals, and share some tips for staying safe:</p><ol><li>Number <code>0</code> likes to leak into your markup.</li><li>Compound conditions with <code>||</code> can surprise you because precedence</li><li>Ternaries don’t scale.</li><li><code>props.children</code> is not something to use as a condition</li><li>How to manage update vs remount in conditionals.</li></ol><p>If you’re in a hurry, I’ve made a cheat sheet:</p><p><img src="/images/jsx-conditional-cheatsheet-b8767f76d64c89489aee556042b356d5.png"></p><h2 id="Beware-of-zero"><a href="#Beware-of-zero" class="headerlink" title="Beware of zero"></a>Beware of zero</h2><p>Rendering on <em>numerical</em> condition is a common use case. It’s helpful for rendering a collection only if it’s loaded and non-empty:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;gallery.length &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Gallery</span> <span class="attr">slides</span>=<span class="string">&#123;gallery&#125;</span>&gt;</span>&#125;</span></span><br></pre></td></tr></table></figure><p>However, if the gallery <em>is</em> empty, we get an annoying <code>0</code> in out DOM instead of nothing. That’s because of the way <code>&amp;&amp;</code> works: a falsy left-hand side (like 0) is returned immediately. In JS, boolean operators do not cast their result to boolean — and for the better, since you don’t want the right-hand JSX to turn into <code>true</code>. React then proceeds to put that 0 into the DOM — unlike <code>false</code>, it’s a valid react node (again, for good — in <code>you have &#123;count&#125; tickets</code> rendering 0 is perfectly expected).</p><p>The fix? I have two. Cast the condition to boolean explicitly in any way you like. Now the expression value is <code>false</code>, not <code>0</code>, and <code>false</code> is not rendered:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gallery.length &gt; <span class="number">0</span> &amp;&amp; jsx</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">!!gallery.length &amp;&amp; jsx</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">Boolean</span>(gallery.length) &amp;&amp; jsx</span><br></pre></td></tr></table></figure><p>Alternatively, replace <code>&amp;&amp;</code> with a ternary to explicitly provide the falsy value — <code>null</code> works like a charm:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;gallery.length ? <span class="xml"><span class="tag">&lt;<span class="name">Gallery</span> <span class="attr">slides</span>=<span class="string">&#123;gallery&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Mind-the-precedence"><a href="#Mind-the-precedence" class="headerlink" title="Mind the precedence"></a>Mind the precedence</h2><p><em>And</em> (<code>&amp;&amp;</code>) has a higher precedence than <em>or</em> (<code>||</code>) — that’s how <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a> works. However, this also means that you must be very careful with JSX conditions that contain <code>||</code>. Watch as I try to render an access error for anonymous <em>or</em> restricted users…</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.anonymous || user.restricted &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>… and I screw up! The code above is actually equivalent to:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.anonymous || (user.restricted &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure><p>Which is <em>not</em> what I want. For anonymous users, you get <code>true || ...whatever...</code>, which is <code>true</code>, because JS <em>knows</em> the or-expression is true just by looking at the left-hand side and skips (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12554578/does-javascript-have-short-circuit-evaluation">short-circuits</a>) the rest. React doesn’t render <code>true</code>, and even if it did, <code>true</code> is not the error message you expect.</p><p>As a rule of thumb, parenthesize the condition as soon as you see the OR:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(user.anonymous || user.restricted) &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>For a more sneaky case, consider this ternary-inside-the-condition:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;user.registered ? user.restricted : user.rateLimited &amp;&amp;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>Parentheses still help, but avoiding ternaries in conditions is a better option — they’re very confusing, because you can’t even read the expression out in English (if the user is registered then if the user is restricted otherwise if the user is rate-limited, please make it stop).</p><h2 id="Don’t-get-stuck-in-ternaries"><a href="#Don’t-get-stuck-in-ternaries" class="headerlink" title="Don’t get stuck in ternaries"></a>Don’t get stuck in ternaries</h2><p>A ternary is a fine way to switch between <em>two</em> pieces of JSX. Once you go beyond 2 items, the lack of an <code>else if ()</code> turns your logic into a bloody mess real quick:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;isEmoji</span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">EmojiButton</span> /&gt;</span></span></span><br><span class="line">    : isCoupon</span><br><span class="line">        ? <span class="xml"><span class="tag">&lt;<span class="name">CouponButton</span> /&gt;</span></span></span><br><span class="line">        : isLoaded &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">ShareButton</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>Any extra conditions inside a ternary branch, be it a nested ternary or a simple <code>&amp;&amp;</code>, are a red flag. Sometimes, a series of <code>&amp;&amp;</code> blocks works better, at the expense of duplicating some conditions:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;isEmoji &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">EmojiButton</span> /&gt;</span></span>&#125;</span><br><span class="line">&#123;isCoupon &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">CouponButton</span> /&gt;</span></span>&#125;</span><br><span class="line">&#123;!isEmoji &amp;&amp; !isCoupon &amp;&amp; isLoaded &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">ShareButton</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>Other times, a good old <code>if / else</code> is the way to go. Sure, you can’t inline these in JSX, but you can always extract a function:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getButton = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmoji) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EmojiButton</span> /&gt;</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (isCoupon) <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CouponButton</span> /&gt;</span></span>;</span><br><span class="line">    <span class="keyword">return</span> isLoaded ? <span class="xml"><span class="tag">&lt;<span class="name">ShareButton</span> /&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Don’t-conditional-on-JSX"><a href="#Don’t-conditional-on-JSX" class="headerlink" title="Don’t conditional on JSX"></a>Don’t conditional on JSX</h2><p>In case you’re wondering, react elements passed via props don’t work as a condition. Let me try wrapping the children in a div <em>only</em> if there are children:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Wrap = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!props.children) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>I expect <code>Wrap</code> to render <code>null</code> when there is no content wrapped, but React doesn’t work like that:</p><ul><li><code>props.children</code> can be an empty array, e.g. <code>&lt;Wrap&gt;&#123;[].map(e =&gt; &lt;div /&gt;)&#125;&lt;/Wrap&gt;</code></li><li><code>children.length</code> fails, too: <code>children</code> can <em>also</em> be a single element, not an array (<code>&lt;Wrap&gt;&lt;div /&gt;&lt;/Wrap&gt;</code>).</li><li><code>React.Children.count(props.children)</code> <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactchildrencount">supports</a> both single and multiple children, but thinks that <code>&lt;Wrap&gt;&#123;false &amp;&amp; &#39;hi&#39;&#125;&#123;false &amp;&amp; &#39;there&#39;&#125;&lt;/Wrap&gt;</code> contains 2 items, while in reality there are none.</li><li>Next try: <code>React.Children.toArray(props.children)</code> <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactchildrentoarray">removes invalid nodes,</a> such as <code>false</code>. Sadly, you still get true for an empty fragment: <code>&lt;Wrap&gt;&lt;&gt;&lt;/&gt;&lt;Wrap&gt;</code>.</li><li>For the final nail in this coffin, if we move the conditional rendering inside a component: <code>&lt;Wrap&gt;&lt;Div hide /&gt;&lt;/Wrap&gt;</code> with <code>Div = (p) =&gt; p.hide ? null : &lt;div /&gt;</code>, we can <em>never</em> know if it’s empty during <code>Wrap</code> render, because react only renders the child <code>Div</code> after the parent, and a stateful child can re-render independently from its parent.</li></ul><p>For the only sane way to change anything if the interpolated JSX is empty, see <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:empty">CSS <code>:empty</code> pseudo-class.</a></p><h2 id="Remount-or-update"><a href="#Remount-or-update" class="headerlink" title="Remount or update?"></a>Remount or update?</h2><p>JSX written in separate ternary branches feels like completely independent code. Consider the following:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;hasItem ? <span class="xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">id</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">Item</span> <span class="attr">id</span>=<span class="string">&#123;2&#125;</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>What happens when <code>hasItem</code> changes? Don’t know about you, but my guess would be that <code>&lt;Item id=&#123;1&#125; /&gt;</code> unmounts, then <code>&lt;Item id=&#123;2&#125; /&gt;</code> mounts, because I wrote 2 separate JSX tags. React, however, doesn’t know or care what I wrote, all it sees is the <code>Item</code> element in the same position, so it keeps the mounted instance, updating props (see <a target="_blank" rel="noopener" href="https://codesandbox.io/s/still-cherry-o123c?file=/src/App.js">sandbox</a>). The code above is equivalent to <code>&lt;Item id=&#123;hasItem ? 1 : 2&#125; /&gt;</code>.</p><blockquote><p>When the branches contain different components, as in <code>&#123;hasItem ? &lt;Item1 /&gt; : &lt;Item2 /&gt;&#125;</code>, React remounts, because <code>Item1</code> can’t be updated to become <code>Item2</code>.</p></blockquote><p>The case above just causes some unexpected behavior that’s fine as long as you properly manage updates, and even a bit more optimal than remounting. However, with uncontrolled inputs you’re in for a disaster:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;mode === <span class="string">&#x27;name&#x27;</span></span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">    : <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>Here, if you input something into <em>name</em> input, then switch the mode, your name unexpectedly leaks into the <em>phone</em> input. (again, see <a target="_blank" rel="noopener" href="https://codesandbox.io/s/still-cherry-o123c?file=/src/App.js">sandbox</a>) This can cause even more havoc with complex update mechanics relying on previous state.</p><p>One workaround here is using the <code>key</code> prop. Normally, we use it for <a target="_blank" rel="noopener" href="https://reactjs.org/docs/lists-and-keys.html">rendering lists,</a> but it’s actually an <em>element identity</em> hint for React — elements with the same <code>key</code> are the same logical element.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remounts on change</span></span><br><span class="line">&#123;mode === <span class="string">&#x27;name&#x27;</span></span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;name&quot;</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">    : <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">key</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>Another option is replacing the ternary with two separate <code>&amp;&amp;</code> blocks. When <code>key</code> is absent, React falls back to the index of the item in <code>children</code> array, so putting distinct elements into distinct positions works just as well as an explicit key:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;mode === <span class="string">&#x27;name&#x27;</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span>&#125;</span><br><span class="line">&#123;mode !== <span class="string">&#x27;name&#x27;</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure><p>Conversely, if you have <em>very different</em> conditional props on the same logical element, you can split the branching into two separate JSX tags for readability with <em>no</em> penalty:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// messy</span></span><br><span class="line">&lt;Button</span><br><span class="line">    aria-busy=&#123;loading&#125;</span><br><span class="line">    onClick=&#123;loading ? <span class="literal">null</span> : submit&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &#123;loading ? <span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span></span> : <span class="string">&#x27;submit&#x27;</span>&#125;</span><br><span class="line">&lt;/Button&gt;</span><br><span class="line"><span class="comment">// maybe try:</span></span><br><span class="line">&#123;loading</span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">aria-busy</span>&gt;</span><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    : <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;submit&#125;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>&#125;</span><br><span class="line"><span class="comment">// or even</span></span><br><span class="line">&#123;loading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">key</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">aria-busy</span>&gt;</span><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>&#125;</span><br><span class="line">&#123;!loading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">key</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;submit&#125;</span>&gt;</span>submit<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>&#125;</span><br><span class="line"><span class="comment">// ^^ bonus: _move_ the element around the markup, no remount</span></span><br></pre></td></tr></table></figure><hr><p>So, here are my top tips for using JSX conditionals like a boss:</p><ul><li><code>&#123;number &amp;&amp; &lt;JSX /&gt;&#125;</code> renders <code>0</code> instead of nothing. Use <code>&#123;number &gt; 0 &amp;&amp; &lt;JSX /&gt;&#125;</code> instead.</li><li>Don’t forget the parentheses around or-conditions: <code>&#123;(cond1 || cond2) &amp;&amp; &lt;JSX /&gt;&#125;</code></li><li>Ternaries don’t scale beyond 2 branches — try an <code>&amp;&amp;</code> block per branch, or extract a function and use <code>if / else</code>.</li><li>You can’t tell if <code>props.children</code> (or any interpolated element) actually contains some content — CSS <code>:empty</code> is your best bet.</li><li><code>&#123;condition ? &lt;Tag props1 /&gt; : &lt;Tag props2 /&gt;&#125;</code> will <em>not</em> remount <code>Tag</code> — use unique <code>key</code> or separate <code>&amp;&amp;</code> branches if you want the remount.</li></ul></div><span class="share"><div><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://thoughtspile.github.io/2022/01/17/jsx-conditionals/&text=Good advice on JSX conditionals by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://thoughtspile.github.io/2022/01/17/jsx-conditionals/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/frontend/" rel="tag">frontend</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/programming/" rel="tag">programming</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2022-01-17T15:58:03.000Z" itemprop="datePublished">2022</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2021/11/30/lazy-useref/"><div class="post-siblings__direction">Older</div><span class="link__text">Make useRef lazy — 4 ways</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-7bc8702b14501402f6b7d1cf149776a9.js"></script>