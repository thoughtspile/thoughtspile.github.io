<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="yandex-verification" content="635edef3908320be"><link href="/ru/2022/02/09/react-global-memo/" rel="alternate" hreflang="ru"><meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc"><meta name="description" content="When our React apps get slow, we usually turn to useMemo to avoid useless job on re-render. It’s a hammer that often works well, and makes it hard to shoot yourself in the foot. But useMemo is not a s"><meta property="og:type" content="article"><meta property="og:title" content="Using global memoization in React"><meta property="og:url" content="https://blog.thoughtspile.tech/2022/02/09/react-global-memo/index.html"><meta property="og:site_name" content="Vladimir Klepov as a Coder"><meta property="og:description" content="When our React apps get slow, we usually turn to useMemo to avoid useless job on re-render. It’s a hammer that often works well, and makes it hard to shoot yourself in the foot. But useMemo is not a s"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.thoughtspile.tech/images/global-memo-cheatsheet.png"><meta property="article:published_time" content="2022-02-09T12:08:54.000Z"><meta property="article:modified_time" content="2022-02-17T09:36:07.872Z"><meta property="article:author" content="Vladimir Klepov"><meta property="article:tag" content="react"><meta property="article:tag" content="hooks"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.thoughtspile.tech/images/global-memo-cheatsheet.png"><meta name="twitter:creator" content="@thoughtspile"><link rel="shortcut icon" href="/images/favicon-6e00c3b618952d5cd6e8942e95a692e1.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192-8b6cc8287c442b221bad9ed73e85331f.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-53bb79233c939b7e4a27b36cab6aec28.png"><title>Using global memoization in React</title><link rel="stylesheet" href="/css/style-6e9addb688f39c95eacb80fa9a450361.css"><link rel="canonical" href="https://blog.thoughtspile.tech/2022/02/09/react-global-memo/"><link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml"><script src="https://storage.yandexcloud.net/thoughtspile/deadman.js" async></script><meta name="generator" content="Hexo 5.4.0"></head><body class="max-width mx-auto px3"><div class="content index"><a href="/" id="header" class="header header--post"><div id="logo"></div><header id="title"><h1>Vladimir Klepov as a Coder</h1></header></a><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Using global memoization in React</h1></header><div class="content" itemprop="articleBody"><p>When our React apps get slow, we usually turn to <code>useMemo</code> to avoid useless job on re-render. It’s a <em>hammer</em> that often works well, and makes it hard to shoot yourself in the foot. But <code>useMemo</code> is not a silver bullet — sometimes it just introduces more useless work instead of making your app faster.</p><p>In this article, I explore the less conventional caching techniques in React that can do wonders to optimize your apps:</p><ol><li>First, we must understand exactly how <code>useMemo</code> works — and why.</li><li>What are some use cases where <code>useMemo</code> does not help much?</li><li>Then, we examine four global caching methods, where cache is shared between components. As usual, they come with different tradeoffs, and some are even dangerous if used carelessly.</li></ol><p>There’s a neat cheat sheet awaiting you at the end. Let’s dive in!</p><h2 id="Inside-useMemo"><a href="#Inside-useMemo" class="headerlink" title="Inside useMemo"></a>Inside useMemo</h2><p>To see if <code>useMemo</code> fits our particular use case, we must know how, precisely, it works. To quote <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#usememo">the docs,</a> <em>useMemo will only recompute the memoized value when one of the dependencies has changed.</em> This is rather ambiguous, so let’s check against <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/9d4e8e84f7fb782385d81ffcdcda73822acf4ad1/packages/react-reconciler/src/ReactFiberHooks.new.js#L1906">the implementation:</a></p><ol><li>The cache is initialized when mounting a component instance, and destroyed when unmounting.</li><li>The cache is never shared between different component instances.</li><li>The cache stores just a single value — the last one.</li></ol><p>This is a sensible default. Storing <em>one</em> value never leaks memory, even if you use an unstable dependency. Say our memo (and <code>useCallback</code> is just a wrapper over <code>useMemo</code>) depends on an unstable arrow, <code>onClick</code>:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">onClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">onClick</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>onClick<span class="token punctuation">,</span> props<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Now we create a new <code>handleClick</code> on every render. If <code>useMemo</code> stored all the previous values, every <code>handleClick</code> would occupy memory forever — bad. Also, storing N values requires N dependency comparisons when reading, which is N times slower than checking once. Sure, <code>useMemo</code> is worthless here, but at least it does not explode.</p><p>Localizing cache to a single component guards against missing deps. Suppose you’re sure a scope variable <em>never</em> changes during the component lifetime, so you just omit it from the dependency array:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">[</span>clicks<span class="token punctuation">,</span> setClicks<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> handleClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token function">setClicks</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=></span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><em>If</em> the cache was shared among multiple components, distinct <code>handleClick</code>s would call the same <code>setClicks</code>, so only one counter would increment — unexpected!</p><p>Good job, React team — thanks for saving us the trouble of debugging this! But this safe implementation has its limitations.</p><h2 id="useMemo-pitfalls"><a href="#useMemo-pitfalls" class="headerlink" title="useMemo pitfalls"></a>useMemo pitfalls</h2><p>While a great default, the locality and single-value limit of <code>useMemo</code> make it useless in some scenarios. For example, consider this attempt at memoizing a large city list:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">RouteItem</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> cities <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Moscow'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'MOW'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Saint Petersburg'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'LED'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 1000 more cities</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span>cities<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>value<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>label<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>If we render a 1000 <code>RouteItem</code>s, each one gets its own array, which is wasteful. In this case, we’d prefer sharing the cache between different instances.</p><p>Another problem point is alternating dependency values. Let’s say we want to generate color scheme based on checkbox value:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">SchemePicker</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isDark<span class="token punctuation">,</span> setDark<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> colors <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    background<span class="token operator">:</span> isDark <span class="token operator">?</span> <span class="token string">'black'</span> <span class="token operator">:</span> <span class="token string">'white'</span><span class="token punctuation">,</span>
    color<span class="token operator">:</span> isDark <span class="token operator">?</span> <span class="token string">'white'</span> <span class="token operator">:</span> <span class="token string">'black'</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>isDark<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>colors<span class="token punctuation">&#125;</span></span> <span class="token spread"><span class="token punctuation">&#123;</span><span class="token operator">...</span>props<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setDark</span><span class="token punctuation">(</span><span class="token operator">!</span>isDark<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      toggle theme
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span>props<span class="token punctuation">.</span>children<span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>Here, we only have two possible dependency values, <code>true</code> and <code>false</code>, so there is no risk of a memory leak. Yet, on every checkbox change, we compute a fresh color scheme. The old one would be just fine, thank you.</p><p>So, in some cases we’d like to:</p><ol><li>Share cache between different component instances.</li><li>Remember several values, not just the last one.</li></ol><p>No problem, with the power of JS at our disposal we can make it happen.</p><h2 id="Global-memo"><a href="#Global-memo" class="headerlink" title="Global memo"></a>Global memo</h2><p>If we want to reuse a value between component instances, no hook can save us, because both <code>useState</code> and <code>useRef</code> are local to component instance. But we can extract the cache into module scope, and work from there:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token comment">// this is shared between all components</span>
<span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token comment">/* some cache */</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">Component</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// cache is always the same object</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre><h3 id="Precomputed-global-constant"><a href="#Precomputed-global-constant" class="headerlink" title="Precomputed global constant"></a>Precomputed global constant</h3><p>The simplest kind of “cache” is one with no dependencies — a constant that’s usable in every component. And the simplest solution is to just to declare this constant right away:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> cities <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Moscow'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'MOW'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Saint Petersburg'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'LED'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token comment">// 1000 more cities</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// yay, every RouteItem refers to the same cities</span>
<span class="token keyword">const</span> <span class="token function-variable function">RouteItem</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span>cities<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>value<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>label<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>Having just <em>one</em> value for all components seems limiting. But, if we know all the possible dependency values in advance, we can just precompute the value for each dependency:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> schemes <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  dark<span class="token operator">:</span> <span class="token punctuation">&#123;</span> background<span class="token operator">:</span> <span class="token string">'black'</span><span class="token punctuation">,</span> color<span class="token operator">:</span> <span class="token string">'white'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  light<span class="token operator">:</span> <span class="token punctuation">&#123;</span> background<span class="token operator">:</span> <span class="token string">'white'</span><span class="token punctuation">,</span> color<span class="token operator">:</span> <span class="token string">'black'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">SchemePicker</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isDark<span class="token punctuation">,</span> setDark<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// we only have 2 values, each one is stable</span>
  <span class="token keyword">const</span> colors <span class="token operator">=</span> schemes<span class="token punctuation">[</span>isDark <span class="token operator">?</span> <span class="token string">'dark'</span> <span class="token operator">:</span> <span class="token string">'light'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></span> <span class="token spread"><span class="token punctuation">&#123;</span><span class="token operator">...</span>props<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setDark</span><span class="token punctuation">(</span><span class="token operator">!</span>isDark<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      toggle theme
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span>props<span class="token punctuation">.</span>children<span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>However, this technique comes with some drawbacks. Building the object in the initial execution phase delays the first paint, even if you don’t need the value right away. All the data needed to construct the value must be available when the script is initially executed. If any of this is a concern, let’s move on to the next technique!</p><h3 id="Lazy-global-constant"><a href="#Lazy-global-constant" class="headerlink" title="Lazy global constant"></a>Lazy global constant</h3><p>So, we want to share a single value between all components, but we want to compute it only when we need it. Fine, it’s a well-known pattern:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">let</span> citiesCache<span class="token punctuation">;</span>
<span class="token comment">// getCities intercepts accessing cities</span>
<span class="token keyword">const</span> <span class="token function-variable function">getCities</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// use cached value if it exists</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>citiesCache<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> citiesCache<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">//  otherwise put the array into the cache</span>
  citiesCache <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Moscow'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'MOW'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Saint Petersburg'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'LED'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 1000 more cities</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> citiesCache<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">RouteItem</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span><span class="token function">getCities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>value<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>label<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>Here, we delay building the value until we actually need it. Great! And we could even pass some data from an API to the builder, as long as it never changes. Fun fact: storing data in a state manager or an API cache is actually an example of this technique.</p><p>But what if we try to generalize this method for multiple values, just like we did with a precomputed map? Oh, that’s a whole different story!</p><h3 id="True-memo"><a href="#True-memo" class="headerlink" title="True memo"></a>True memo</h3><p>Let’s up our game by letting every component get a special version of city list, with one city excluded. We’d still like to share the cache between several instances, just in case. It’s not that hard:</p><pre class="language-jsx" data-language="jsx"><code class="language-jsx"><span class="token keyword">const</span> cities <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Moscow'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'MOW'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token punctuation">&#123;</span> label<span class="token operator">:</span> <span class="token string">'Saint Petersburg'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'LED'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token comment">// 1000 more cities</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> filterCache <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">getCitiesExcept</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">exclude</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// use cached value if it exists</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>filterCache<span class="token punctuation">[</span>exclude<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> filterCache<span class="token punctuation">[</span>exclude<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// otherwise put the filtered array into the cache</span>
  filterCache<span class="token punctuation">[</span>exclude<span class="token punctuation">]</span> <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=></span> c<span class="token punctuation">.</span>value <span class="token operator">!==</span> exclude<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> filterCache<span class="token punctuation">[</span>exclude<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">RouteItem</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> value <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">&#123;</span><span class="token function">getCitiesExcept</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>value<span class="token punctuation">&#125;</span></span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>label<span class="token punctuation">&#125;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>This works, but global caches are vulnerable to infinite growth problem. In a long-lived app, you might eventually get to the point where every possible city was excluded, leaving you with a 1000 copies of your 1000-item array in the cache, most of them useless. To protect against this, we need some way to limit the cache size.</p><h3 id="LRU-cache"><a href="#LRU-cache" class="headerlink" title="LRU cache"></a>LRU cache</h3><p>To restrict cache size, we need some way to choose exactly which elements to “forget”. This is called <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_replacement_policies"><em>cache replacement policy,</em></a> and there are surprisingly many approaches.</p><p>We’ll stick to the simplest method — least-recently used, or LRU cache. We only remember N last values. For example, after passing numbers 1, 2, 3, 1 to an LRU cache of size 2, we only store the values for 3 and 1, while the value for 2 was thrown away. The implementation is not interesting, hope you believe this is doable (see <a target="_blank" rel="noopener" href="https://github.com/lukeed/flru/blob/master/src/index.js">flru</a> for details). It’s worth noting that the original <code>useMemo</code> is actually an LRU cache of size 1, because it only stores one last value.</p><p>While it sounds good on paper, global bounded cache does not actually work that well for our use cases. To see why, let’s consider a cache of size 1. If we have several component instances alive at once, they <em>likely</em> have different dependency values. If they render in alternating order, every instance encounters the value from the previously rendered one, which is a cache miss, and has to recompute. So, we end up recomputing on every render, and doing some useless comparisons.</p><p>More generally, a cache of size N is likely to have misses once N+1 components with different values are alive, and become useless at 2N components. This is not a good quality — a cache shouldn’t care how many consumers exist. We could experiment with other replacement policies — say, frequency-based caches — but they’re way harder to implement, and I feel like React apps don’t have cache usage patterns that could benefit from them.</p><p>There is, however, one case where it works: if you have N possible dependency values, and N is <em>small</em> — say, <code>true</code> / <code>false</code>, or a number 1..10, a cache of size N has you fully covered with 100% cache hits, and only computes values when needed. But if that’s the case, a simple global cache works just the same, without the overhead of tracking usage order.</p><hr><p>Recap time! We’ve started out by looking at <code>useMemo</code> in detail. <code>useMemo</code> cache is never shared between component instances, lives as long as the instance lives, and only stores one last value. There are good reasons for these decisions.</p><p>However, this makes <code>useMemo</code> not usable in some cases:</p><ol><li>When you <em>want</em> to reuse a value between components (e.g. always the same large object)</li><li>When your dependency quickly alternates between several values (e.g. true / false / true etc.)</li></ol><p>Then, we examined 4 (4-and-a-half? 5?) caching techniques with a globally shared cache that overcome these issues:</p><ol><li>Just use a module constant. Simple, reliable, but builds the object during initial script execution — suboptimal if the object is heavy and not needed during initial render.</li><li>Precomputed map — a simple extension of <em>module constant</em> that stores several values. Same drawbacks.</li><li>Lazy constant — delay building the object until it’s needed, then cache forever. Removes module constant init delay during script init time.</li><li>Full memo — saves <em>all</em> the results of function calls with <em>all</em> arguments. Leaks memory when there are many possible dependency values / combinations. Good when there are few possible inputs. Use with care.</li><li>Bounded cache (e.g. LRU). Fixes the memory leak problem, but useless when the number of components alive with different deps is larger than cache size. Not recommended.</li></ol><p>Here’s a cheat sheet to help you remember these techniques:</p><p><img src="/images/global-memo-cheatsheet-f7793d0fbdd8a83447a6776d3384afb3.png"></p><p>These techniques are useful in regular react apps, and can up your performance. But we don’t always need our cache to be shared between component instances. Luckily, all these methods also work when scoped to a component — stay tuned for the next post on alternate <code>useMemo</code> implementations.</p></div><span class="share"><div id="share-twitter"><a target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.thoughtspile.tech/2022/02/09/react-global-memo/&text=Using global memoization in React by @thoughtspile">Tweet</a></div><div id="share-button"><a>Share</a></div><div><a target="_blank" rel="noopener" href="https://twitter.com/search?q=https://blog.thoughtspile.tech/2022/02/09/react-global-memo/">Discuss on Twitter</a></div></span><div class="post-related">More? <a class="tag-link-link" href="/">All articles ever</a> <a class="tag-link-link" href="/tags/hooks/" rel="tag">hooks</a> <a class="tag-link-link" href="/tags/react/" rel="tag">react</a></div><div class="post-actions">Written in <time datetime="2022-02-09T12:08:54.000Z" itemprop="datePublished">2022</time> by&nbsp;your friend, <a href="/">Vladimir.</a> Follow&nbsp;me on&nbsp;<a href="https://twitter.com/thoughtspile" target="_blank">Twitter</a> to&nbsp;get post updates. I&nbsp;have <a href="/atom.xml">RSS,</a> too. And you can <a class="bmc go-bmc link--bare" target="_blank" rel="noopener" href="https://buymeacoffee.com/thoughtspile">buy me a coffee!</a></div><div class="post-siblings"><a class="link--bare" href="/2022/01/25/what-is-react-component/"><div class="post-siblings__direction">Older</div><span class="link__text">What is a react component, anyways?</span> </a><a class="link--bare" href="/2022/02/14/js-automation/"><div class="post-siblings__direction">Newer</div><span class="link__text">Why I prefer JS for front-end build automation</span></a></div></article></div></body></html><script type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-121445688-1","auto"),ga("send","pageview")</script><script src="/js/share-885512d0e95bf6e634870c148cd11707.js"></script><script src="/js/analytics-647bf8f98e22da5a496b8fc658500c0b.js"></script>