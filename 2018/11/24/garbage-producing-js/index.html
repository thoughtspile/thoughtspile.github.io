<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    
      <meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc" />
    
    <meta name="description" content="The reckless coding culture of JS favors producing garbage. In real life, if you’re environmentally conscious (hey there, my European readers), you probably do all sorts of crazy thinks to cut down on">
<meta name="keywords" content="javascript,programming,performance">
<meta property="og:type" content="article">
<meta property="og:title" content="Major Garbage Producers in JS">
<meta property="og:url" content="https://thoughtspile.github.io/2018/11/24/garbage-producing-js/index.html">
<meta property="og:site_name" content="Vladimir Klepov as a Coder">
<meta property="og:description" content="The reckless coding culture of JS favors producing garbage. In real life, if you’re environmentally conscious (hey there, my European readers), you probably do all sorts of crazy thinks to cut down on">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-04-09T18:05:50.250Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Major Garbage Producers in JS">
<meta name="twitter:description" content="The reckless coding culture of JS favors producing garbage. In real life, if you’re environmentally conscious (hey there, my European readers), you probably do all sorts of crazy thinks to cut down on">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Major Garbage Producers in JS</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml" />
    

    <script type='text/javascript' src='//platform-api.sharethis.com/js/sharethis.js#property=5c1957fa423bba0012ec3bd1&product=inline-share-buttons'
      async='async'></script>

</head>

<body class="max-width mx-auto px3">
    <div class="content index my4">
        <a href="/" id="header" class="header header--post">
  
    
    <div id="logo" style="background-image: url(/images/logo.png);"></div>
  
  <header id="title">
    <h1>Vladimir Klepov as a Coder</h1>
  </header>
</a>

        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Major Garbage Producers in JS
    </h1>



    <div class="meta">
      
    <div class="postdate">
        <time datetime="2018-11-24T15:25:43.000Z" itemprop="datePublished">24.11.2018</time>
    </div>


      
    <div class="article-tag">
        <a class="tag-link" href="/tags/javascript/">javascript</a>, <a class="tag-link" href="/tags/performance/">performance</a>, <a class="tag-link" href="/tags/programming/">programming</a>
    </div>


    </div>
  </header>
  <div class="content" itemprop="articleBody">
    <p>The reckless coding culture of JS favors producing garbage. In real life, if you’re environmentally conscious (hey there, my European readers), you probably do all sorts of crazy thinks to cut down on garbage — reject plastic bags in a supermarket, recycle bottles, keep the paper garbage in a closet until the special paper-garbage truck comes on Thursday. But when it comes to JS, the general sentiment magically becomes “let’s litter like crazy, then let the engine designers do their thing and come up with something to make that work at the speed of C”. Apparently, there’s only that much the poor guys can do.</p>
<p>Even if you do a quick complexity analysis here and there, and know your way around a profiler, hot garbage is going to bite you. It won’t be a literal memory leak — occasionally garbage collector would come and clean up your mess — but it places strain on the user’s PC resources, and in the worst case you might end up with a 10+ seconds GC pause.</p>
<p>It’s time that we learn to stand up for ourselves. We should at least identify eco-unfriendly JS patterns, so that we know whom to blame. In this post, I describe three patterns that lead to excess garbage production, and give you an insight into static-memory JS programming — the kind you want to use in low-level hot code.</p>
<h2 id="Array-method-chains"><a href="#Array-method-chains" class="headerlink" title="Array method chains"></a>Array method chains</h2><p>Chaining array methods might be concise and functional, but it’s a terrible memory buster. Count with me:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = arr <span class="comment">// Say we have   110 elements here</span></span><br><span class="line">  .filter(<span class="function"><span class="params">e</span> =&gt;</span> e.user) <span class="comment">// say, + 100 elements</span></span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> e.user) <span class="comment">//         + 100 elements</span></span><br><span class="line">  .map(<span class="function"><span class="params">u</span> =&gt;</span> u.wealth || <span class="number">0</span>) <span class="comment">//  + 100 elements</span></span><br><span class="line">  .reduce(<span class="function">(<span class="params">acc, wealth</span>) =&gt;</span> acc + wealth, <span class="number">0</span>); <span class="comment">// all to get a number!</span></span><br></pre></td></tr></table></figure>
<p>We’ve just allocated 300 elements across 3 arrays, while we only needed one numeric variable (what is it, around 8 bytes?).</p>
<h3 id="Less-calls-larger-functions"><a href="#Less-calls-larger-functions" class="headerlink" title="Less calls, larger functions"></a>Less calls, larger functions</h3><p>Just because you can write every operation as a one-liner arrow, does not mean you should. In the above case, we could rewrite the chain into a non-chain, removing intermediate arrays:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = arr.reduce(<span class="function">(<span class="params">acc, e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wealth = (e &amp;&amp; e.user) ? (e.user.wealth || <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> acc + wealth;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>As you can see in <a href="https://jsperf.com/array-chains" target="_blank" rel="noopener">this jsperf</a>, this solution is several times faster than the excessively chained one.</p>
<p>Of course, this limits the reusability of individual transforms — but, honestly, when was the last time you used non-inline function in a map (<code>.map(mapper)</code>)? Programming is a way of tradeoffs.</p>
<h3 id="for-loops"><a href="#for-loops" class="headerlink" title="for loops"></a><code>for</code> loops</h3><p>For especially hot functions, it makes sense to switch to good old <code>for</code> loops with index:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> e = arr[i];</span><br><span class="line">  <span class="keyword">if</span> (e &amp;&amp; e.user) &#123;</span><br><span class="line">    total += e.user.wealth || <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator-based for..of loops may be the stylish and concise choice here, but, depending on your browser, they may be as fast as the indexed version, or the slowest option, or be not supported at all. When you transpile the code into ES5, for..of loops turn into plain loops and naturally run at the same speed, but you should not assume this would always be the case. Also, the spec requires iterators to produce a new object at any iteration, which complicates the GC job instead of easing it.</p>
<h2 id="Defensive-Cloning"><a href="#Defensive-Cloning" class="headerlink" title="Defensive Cloning"></a>Defensive Cloning</h2><p>This pattern is not as widespread in Redux community as it used to be in Flux / event bus times, but it’s a case where a single statement can stall your program. I’m talking about <code>_.cloneDeep</code> and friends.</p>
<p>The premise of cloning is noble: you have no idea what the consumers will do to your object, but mutating them might break the other consumers’ assumptions. <strong>example</strong> This is most prominent in middlewares and observables, because these patterns assume low coupling, and you have no idea where the object you create goes and what happens to it. If you hand each consumer a unique copy of the object, it can do no harm to others.</p>
<h3 id="Clone-only-what’s-necessary"><a href="#Clone-only-what’s-necessary" class="headerlink" title="Clone only what’s necessary"></a>Clone only what’s necessary</h3><p>The basic redux pattern with object spreads — using <code>{ ...state, user }</code> to overwrite a single property — is already a good enough solution. Even if you overwrite the most deeply nested property, you generally allocate only <code>O(log N)</code> new memory for an N-sized object. That is, if you have a 3-nested object with 6 properties at each level, you only create 3 new object per clone instead of 6^3 = 216. Much better!</p>
<h3 id="Use-Immutable-js"><a href="#Use-Immutable-js" class="headerlink" title="Use Immutable.js"></a>Use Immutable.js</h3><p>Libraries such as Immutable.js give the consumers no way to mutate the original object. They also enable you to change the object in patches, with smaller memory pressure than the naive method. The drawback is that the syntax for working with Immutable objects is more verbose, especially if you’re interfacing with plain JS objects, so this solution works best for apps developed from scratch. As an alternative, you could employ ES6 <code>Object.freeze</code>, but the browser support is not quite there yet.</p>
<p>Unfortunately, this option also imposes runtime performance cost for property access, which might not be the best thing to do out of pure cautiousness.</p>
<h3 id="Make-up-your-mind-about-mutation"><a href="#Make-up-your-mind-about-mutation" class="headerlink" title="Make up your mind about mutation"></a>Make up your mind about mutation</h3><p>My favorite option here is not technological. Impose a global rule over your codebase: <em>do not mutate the objects you did not create.</em> Beat yourself on the fingers with a ruler when you do. Enforce this in code reviews. Explain the problem you’re solving to your colleagues. If you absolutely must mutate the object, clone it as soon as you receive it. That’s 1 explicit clone per 100 calls, not the default case. Much better.</p>
<h2 id="Object-arguments"><a href="#Object-arguments" class="headerlink" title="Object arguments"></a>Object arguments</h2><p>This one is primarily for designing hot-utility libraries. The guys often opt for ease of use and design APIs with <code>options</code> argument that accepts an object:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ugly and inflexible (or is it?)</span></span><br><span class="line">formatGreeting(<span class="string">'Waldemar'</span>) <span class="comment">// hello, Waldemar!</span></span><br><span class="line"><span class="comment">// You don't have to remember arg position! And we can add more options later.</span></span><br><span class="line">formatGreeting(&#123; <span class="attr">name</span>: <span class="string">'Waldemar'</span> &#125;) <span class="comment">// hello, Waldemar!</span></span><br></pre></td></tr></table></figure>
<p>It’s all very nice and convenient until you realize that you have to create an object on every call, then throw it away. Here’s <a href="https://jsperf.com/object-vs-positional-args" target="_blank" rel="noopener">another jsperf</a> that shows just how big a hit this can be.</p>
<p>Make a rule of accepting required arguments positionally in hot utility functions. You can always reserve the last position for an optional argument object a-la python to allow your users to opt-in to extended functionality:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formatGreeting(<span class="string">'Waldemar'</span>, &#123; <span class="attr">lang</span>: <span class="string">'fr'</span> &#125;) <span class="comment">// Bonjour, Waldemar!</span></span><br></pre></td></tr></table></figure>
<hr>
<p>I know, I know, your favourite quote starts with “premature optimization” and ends with “evil”. However, if you don’t take these things into consideration when writing low-level code, you’ll soon find your validations take 400ms per keyword stroke, your visualizations hang the browser, and your node server do GC pauses every other second. I’m not promoting the use of these techniques in all your code, but as soon as you recognize a code path is hot — go for it! At least you’ll know what to look for. Good luck!</p>

  </div>
  <div class="call-to-action clearfix">
    
      <a class="call-to-action__item left" href="/2018/11/05/react-extend-justified/">
        <i class="fas fa-chevron-left fa-3x"></i>
        <span class="call-to-action__item__name">Why you Might Want to Extend React Components</span>
      </a>
    
    
      <a class="call-to-action__item right" href="/2018/12/02/react-keep-mounted/">
        <span class="call-to-action__item__name">Keep a React component mounted</span>
        <i class="fas fa-chevron-right fa-3x"></i>
      </a>
    
  </div>
</article>
<div class="sharethis-inline-share-buttons"></div>



    </div>
    <footer id="footer">
  <a href="/">
    A blog by Vladimir Klepov
  </a>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-121445688-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


