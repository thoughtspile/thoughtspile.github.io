<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    
      <meta name="google-site-verification" content="5nfOA5k_QcuAP9zbAASIV24DlAZG7BWxRVYoNlKCAoc" />
    
    <meta name="description" content="The second most important React optimization technique after shouldComponentUpdate and friends is remount management. Some portions of the UI can be hidden or shown — sidebars, drop-down menus, modals">
<meta name="keywords" content="javascript,programming,frontend,react">
<meta property="og:type" content="article">
<meta property="og:title" content="Keep a React component mounted">
<meta property="og:url" content="https://thoughtspile.github.io/2018/12/02/react-keep-mounted/index.html">
<meta property="og:site_name" content="Vladimir Klepov as a Coder">
<meta property="og:description" content="The second most important React optimization technique after shouldComponentUpdate and friends is remount management. Some portions of the UI can be hidden or shown — sidebars, drop-down menus, modals">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-04-09T18:05:50.254Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keep a React component mounted">
<meta name="twitter:description" content="The second most important React optimization technique after shouldComponentUpdate and friends is remount management. Some portions of the UI can be hidden or shown — sidebars, drop-down menus, modals">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Keep a React component mounted</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Vladimir Klepov as a Coder" type="application/atom+xml" />
    

    <script type='text/javascript' src='//platform-api.sharethis.com/js/sharethis.js#property=5c1957fa423bba0012ec3bd1&product=inline-share-buttons'
      async='async'></script>

</head>

<body class="max-width mx-auto px3">
    <div class="content index my4">
        <a href="/" id="header" class="header header--post">
  
    
    <div id="logo" style="background-image: url(/images/logo.png);"></div>
  
  <header id="title">
    <h1>Vladimir Klepov as a Coder</h1>
  </header>
</a>

        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Keep a React component mounted
    </h1>



    <div class="meta">
      
    <div class="postdate">
        <time datetime="2018-12-02T14:04:51.000Z" itemprop="datePublished">02.12.2018</time>
    </div>


      
    <div class="article-tag">
        <a class="tag-link" href="/tags/frontend/">frontend</a>, <a class="tag-link" href="/tags/javascript/">javascript</a>, <a class="tag-link" href="/tags/programming/">programming</a>, <a class="tag-link" href="/tags/react/">react</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>The second most important React optimization technique after <code>shouldComponentUpdate</code> and friends is remount management. Some portions of the UI can be hidden or shown — sidebars, drop-down menus, modals and draggable widgets are all prominent examples. The basic React pattern for conditional rendering is boolean short-circuiting:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;condition &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">data</span>=<span class="string">&#123;data&#125;</span> /&gt;</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>However, if you go this way, you create DOM elements every time the component is displayed. As the component grows in size, the lag between the interaction and mounting can become noticeable. You can combat this (Vue and Angular even have this functionality built-in) by keeping the component rendered unconditionally and hiding it with CSS:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123; <span class="attr">display</span>: condition ? <span class="literal">null</span> : <span class="string">'none'</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;Component data=&#123;data&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>You also get to preserve <code>Component</code>‘s state for free along with the DOM state (scroll, focus, and input position). However, this solution has drawbacks, too:</p>
<ol>
<li>You mount the component on startup, even if the user never accesses it. Mounting multiple components at the same time can accumulate to very sluggish start-up performance.</li>
<li>You update the component even when it’s invisible, which may or may not be what you want.</li>
</ol>
<p>I’m about to propose a solution that walks the middle ground between the two: you mount the component when the user first sees it, subsequent toggles use CSS. You can also control whether you want the hidden component to update with an option — I’ll provide an extended study of the use cases below.  This is more of a straw-man proposal than something I’m ready to wrap into a library, so any discussion is welcome. Play with the code (I’ve opted for preact to show how this method applies to any JSX-based solution) at <a href="https://codesandbox.io/s/82jo98o708" target="_blank" rel="noopener">codesandbox</a>.</p>
<h2 id="The-solution"><a href="#The-solution" class="headerlink" title="The solution"></a>The solution</h2><p>Let’s start by wrapping the CSS solution into a component with a render prop:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepMounted</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isMounted, render &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">display</span>: isMounted ? <span class="literal">null</span> : <span class="string">'none'</span> &#125;&#125;&gt;</span><br><span class="line">        &#123; render() &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ use as</span></span><br><span class="line"><span class="regexp">&lt;KeepMounted</span></span><br><span class="line"><span class="regexp">  isMounted=&#123;condition&#125;</span></span><br><span class="line"><span class="regexp">  render=&#123;() =&gt; &lt;Component data=&#123;data&#125; /</span>&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>Now we make one minor adjustment: only call <code>render</code> once <code>isMounted</code> has been set to <code>true</code> once. I do it this way:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepMounted</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  hasBeenMounted = <span class="literal">false</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isMounted, render &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">this</span>.hasBeenMounted = <span class="keyword">this</span>.hasBeenMounted || isMounted;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">display</span>: isMounted ? <span class="literal">null</span> : <span class="string">'none'</span> &#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.hasBeenMounted ? render() : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>You might argue that <code>hasBeenMounted</code> belongs in <code>state</code>, but in this case it works better this way. <code>KeepMounted</code> never triggers visibility change by itself, and synchronizing store and prop updates either limits compatibility with older versions of <code>React</code> given the <code>componentWillUpdate</code> havoc, or forces double rendering if using <code>componentDid*</code>. But what was that thing about bypassing updates that I wanted?</p>
<h3 id="Preventing-updates"><a href="#Preventing-updates" class="headerlink" title="Preventing updates"></a>Preventing updates</h3><p>At a first glance, there’s no reason to re-render the component when it’s hidden. But the component can produce very different DOM depending on the state: say, it’s a list that grows from 1 to 1000 items while it’s hidden. In that case, updating it once it’s displayed is not much cheaper than mounting it from scratch. Adding items one at a time while it’s hidden will not be noticeable. There’s no right solution here, simply thinking about this helps a lot.</p>
<p>React component updates when either their parent updates (possibly inducing prop changes), or the component’s own state changes (this includes connecting to a state manager). We can bypass the update-from-parent when the component is hidden by not calling <code>render()</code>. We need some fallback elements to use — the last <code>render</code> output will do.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepMounted</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  children = <span class="literal">null</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// And I even have an option to choose the desired behaviour:</span></span><br><span class="line">    <span class="keyword">const</span> &#123; isMounted, updateUnmounted, render &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">this</span>.children = (isMounted || updateUnmounted) ? render() : <span class="keyword">this</span>.children;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">display</span>: isMounted ? <span class="literal">null</span> : <span class="string">'none'</span> &#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>You also need the wrapped component (the one we return in <code>render()</code>) to be pure — some edge case, but its render method is called on every <code>KeepMounted</code> update if you don’t do that.</p>
<p>Unless you’re too tricky, hidden components don’t call <code>setState</code> — the user has no way to interact with them. This leaves us with preventing the updates from the state manager. Careful there, if we stop listening to store updates altogether, we might render stale UI once we show it again. I haven’t gone too deep, but injecting <code>isMounted</code> through the context and using it right below the connector HOC should do the trick (for HOC-based connectors).</p>
<h2 id="Alternative-designs"><a href="#Alternative-designs" class="headerlink" title="Alternative designs"></a>Alternative designs</h2><p>I’ve also evaluated two alternative designs: using a HOC and <code>children</code>. I find the render-prop-based solution the cleanest and most convenient, but here they are for completeness.</p>
<h3 id="Higher-order-component"><a href="#Higher-order-component" class="headerlink" title="Higher-order component"></a>Higher-order component</h3><p>You can obviously do that. However, render prop allows you to hide an arbitrary segment of layout instead of one single component, and you also have prop name collisions to handle (granted, <code>isMounted</code> is probably not the most popular prop name). You’ll use it like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LazyComponent = keepMounted(&#123; <span class="attr">updateMounted</span>: <span class="literal">true</span> &#125;)(Component);</span><br><span class="line">&lt;LazyComponent isMounted=&#123;cond&#125; data=&#123;data&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="children-trick"><a href="#children-trick" class="headerlink" title="children trick"></a><code>children</code> trick</h3><p>An interesting option since it leaves the <code>&amp;&amp;</code> conditional rendering pattern intact:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage</span></span><br><span class="line">&lt;KeepChildrenMounted&gt;</span><br><span class="line">  &#123; condition &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span> &#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">KeepChildrenMounted</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepChildrenMounted</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  children = <span class="literal">null</span>;</span><br><span class="line">  render(&#123; children &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> emptyChildren = isEmptyChildren(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!emptyChildren) &#123;</span><br><span class="line">      <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">display</span>: emptyChildren ? <span class="string">"none"</span> : <span class="literal">null</span> &#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>However, it requires children introspection (conveniently hidden inside <code>isEmptyChildren</code>). This is not that hard, but always feels hacky. The major problem is that it gives you an impression that you can write:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;KeepChildrenMounted&gt;</span><br><span class="line">  &#123;cond1 &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Component1</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">  &#123;cond2 &amp;&amp; <span class="tag">&lt;<span class="name">Component2</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">KeepChildrenMounted</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>And expect it to keep everything mounted. It is doable, but children need a <code>key</code>, you have to introspect them even more, and track it manually. Very hacky. You could also check the child count and give a warning, but you won’t always hit that condition when testing.</p>
<h2 id="Lazy-loading-and-code-splitting"><a href="#Lazy-loading-and-code-splitting" class="headerlink" title="Lazy loading and code splitting"></a>Lazy loading and code splitting</h2><p>This pattern also enables two more interesting use cases. Since the component does not mount immediately, you can delay fetching the data needed to render it until the user sees it. Also, if the child component is heavy, you can slap a code-split boundary on it and only load the actual code when it’s necessary. This way, the users who never see the component will not have to pay for using it. Very exciting.</p>
<hr>
<p>The idea appears so cool and useful I’m surprised there isn’t an npm module for it yet (have I looked in the wrong place?). <a href="https://codesandbox.io/s/82jo98o708" target="_blank" rel="noopener">Play with the code</a>, choose your preferred API option, point out what gotchas I haven’t thought of. Feel free to wrap it into a library yourself if you’re brave enough. Above all, have a nice weekend.</p>

  </div>
  <div class="call-to-action clearfix">
    
      <a class="call-to-action__item left" href="/2018/11/24/garbage-producing-js/">
        <i class="fas fa-chevron-left fa-3x"></i>
        <span class="call-to-action__item__name">Major Garbage Producers in JS</span>
      </a>
    
    
      <a class="call-to-action__item right" href="/2018/12/17/design-crash-course/">
        <span class="call-to-action__item__name">10 Design Rules for Programmers</span>
        <i class="fas fa-chevron-right fa-3x"></i>
      </a>
    
  </div>
</article>
<div class="sharethis-inline-share-buttons"></div>



    </div>
    <footer id="footer">
  <a href="/">
    A blog by Vladimir Klepov
  </a>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-121445688-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


